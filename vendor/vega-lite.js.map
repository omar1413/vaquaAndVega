{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "node_modules/browserify/node_modules/browser-resolve/empty.js",
    "node_modules/datalib/src/generate.js",
    "node_modules/datalib/src/util.js",
    "node_modules/json-stable-stringify/index.js",
    "node_modules/json-stable-stringify/node_modules/jsonify/index.js",
    "node_modules/json-stable-stringify/node_modules/jsonify/lib/parse.js",
    "node_modules/json-stable-stringify/node_modules/jsonify/lib/stringify.js",
    "src/aggregate.ts",
    "src/axis.ts",
    "src/bin.ts",
    "src/channel.ts",
    "src/compile/axis.ts",
    "src/compile/common.ts",
    "src/compile/compile.ts",
    "src/compile/concat.ts",
    "src/compile/config.ts",
    "src/compile/data/bin.ts",
    "src/compile/data/colorrank.ts",
    "src/compile/data/data.ts",
    "src/compile/data/filter.ts",
    "src/compile/data/filterwith.ts",
    "src/compile/data/formatparse.ts",
    "src/compile/data/formula.ts",
    "src/compile/data/lookup.ts",
    "src/compile/data/nonpositivenullfilter.ts",
    "src/compile/data/nullfilter.ts",
    "src/compile/data/source.ts",
    "src/compile/data/stackscale.ts",
    "src/compile/data/summary.ts",
    "src/compile/data/timeunit.ts",
    "src/compile/data/timeunitdomain.ts",
    "src/compile/facet.ts",
    "src/compile/layer.ts",
    "src/compile/layout.ts",
    "src/compile/legend.ts",
    "src/compile/mark/area.ts",
    "src/compile/mark/bar.ts",
    "src/compile/mark/line.ts",
    "src/compile/mark/mark.ts",
    "src/compile/mark/point.ts",
    "src/compile/mark/rule.ts",
    "src/compile/mark/text.ts",
    "src/compile/mark/tick.ts",
    "src/compile/model.ts",
    "src/compile/repeat.ts",
    "src/compile/scale.ts",
    "src/compile/selections/index.ts",
    "src/compile/selections/interval.ts",
    "src/compile/selections/nearest.ts",
    "src/compile/selections/project.ts",
    "src/compile/selections/scales.ts",
    "src/compile/selections/toggle.ts",
    "src/compile/selections/transforms.ts",
    "src/compile/selections/translate.ts",
    "src/compile/selections/zoom.ts",
    "src/compile/stack.ts",
    "src/compile/time.ts",
    "src/compile/unit.ts",
    "src/config.ts",
    "src/data.ts",
    "src/encoding.ts",
    "src/fielddef.ts",
    "src/legend.ts",
    "src/mark.ts",
    "src/scale.ts",
    "src/shorthand.ts",
    "src/sort.ts",
    "src/spec.ts",
    "src/timeunit.ts",
    "src/type.ts",
    "src/util.ts",
    "src/validate.ts",
    "src/vega.schema.ts",
    "src/vl.ts",
    "../vega2/event-selector/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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C,CAAA;AACzC,IAAY,MAAM,WAAM,QAAQ,CAAC,CAAA;AAEpB,WAAG,GAAG,KAAK,CAAC;AACZ,eAAO,GAAG,SAAS,CAAC;AACpB,eAAO,GAAG,SAAS,CAAC,OAAO,CAAC;AAC5B,cAAM,GAAG,QAAQ,CAAC;AAClB,YAAI,GAAG,MAAM,CAAC;AACd,gBAAQ,GAAG,UAAU,CAAC;AACtB,gBAAQ,GAAG,UAAU,CAAC;AACtB,iBAAS,GAAG,WAAW,CAAC;AACxB,YAAI,GAAG,MAAM,CAAC;AACd,gBAAQ,GAAG,UAAU,CAAC;AACtB,YAAI,GAAG,MAAM,CAAC;AACd,YAAI,GAAG,MAAM,CAAC;AACd,gBAAQ,GAAG,UAAU,CAAC;AAEtB,eAAO,GAAG,aAAa,CAAC;;;AC5BrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "",
    "var util = require('./util'),\n    gen = module.exports;\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x >= min && x <= max) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\n  };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\n  };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\n  };\n  f.cdf = function(x) {\n    // Approximation from West (2009)\n    // Better Approximations to Cumulative Normal Functions\n    var cd,\n        z = (x - mean) / stdev,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n  f.icdf = function(p) {\n    // Approximation of Probit function using inverse error function.\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mean + stdev * Math.SQRT2 * s;\n  };\n  return f;\n};\n\ngen.random.bootstrap = function(domain, smooth) {\n  // Generates a bootstrap sample from a set of observations.\n  // Smooth bootstrapping adds random zero-centered noise to the samples.\n  var val = domain.filter(util.isValid),\n      len = val.length,\n      err = smooth ? gen.random.normal(0, smooth) : null;\n  var f = function() {\n    return val[~~(Math.random()*len)] + (err ? err() : 0);\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  return f;\n};",
    "var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) || u.isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n};\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  /* jshint evil: true */\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n",
    "var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n",
    "exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n",
    "var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n",
    "var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n",
    "\nexport enum AggregateOp {\n    VALUES = 'values' as any,\n    COUNT = 'count' as any,\n    VALID = 'valid' as any,\n    MISSING = 'missing' as any,\n    DISTINCT = 'distinct' as any,\n    SUM = 'sum' as any,\n    MEAN = 'mean' as any,\n    AVERAGE = 'average' as any,\n    VARIANCE = 'variance' as any,\n    VARIANCEP = 'variancep' as any,\n    STDEV = 'stdev' as any,\n    STDEVP = 'stdevp' as any,\n    MEDIAN = 'median' as any,\n    Q1 = 'q1' as any,\n    Q3 = 'q3' as any,\n    MODESKEW = 'modeskew' as any,\n    MIN = 'min' as any,\n    MAX = 'max' as any,\n    ARGMIN = 'argmin' as any,\n    ARGMAX = 'argmax' as any,\n}\n\nexport const AGGREGATE_OPS = [\n    AggregateOp.VALUES,\n    AggregateOp.COUNT,\n    AggregateOp.VALID,\n    AggregateOp.MISSING,\n    AggregateOp.DISTINCT,\n    AggregateOp.SUM,\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.VARIANCE,\n    AggregateOp.VARIANCEP,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MODESKEW,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n    AggregateOp.ARGMIN,\n    AggregateOp.ARGMAX,\n];\n\nexport const SHARED_DOMAIN_OPS = [\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n];\n\n// TODO: move supportedTypes, supportedEnums from schema to here\n",
    "\nexport enum AxisOrient {\n    TOP = 'top' as any,\n    RIGHT = 'right' as any,\n    LEFT = 'left' as any,\n    BOTTOM = 'bottom' as any\n}\n\nexport interface AxisConfig {\n  // ---------- General ----------\n  /**\n   * Width of the axis line\n   */\n  axisWidth?: number;\n  /**\n   * A string indicating if the axis (and any gridlines) should be placed above or below the data marks.\n   */\n  layer?: string;\n  /**\n   * The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.\n   */\n  offset?: number;\n\n  // ---------- Grid ----------\n  /**\n   * A flag indicate if gridlines should be created in addition to ticks. If `grid` is unspecified, the default value is `true` for ROW and COL. For X and Y, the default value is `true` for quantitative and time fields and `false` otherwise.\n   */\n  grid?: boolean;\n\n  // ---------- Labels ----------\n  /**\n   * Enable or disable labels.\n   */\n  labels?: boolean;\n  /**\n   * The rotation angle of the axis labels.\n   */\n  labelAngle?: number;\n  /**\n   * Text alignment for the Label.\n   */\n  labelAlign?: string;\n  /**\n   * Text baseline for the label.\n   */\n  labelBaseline?: string;\n  /**\n   * Truncate labels that are too long.\n   * @minimum 1\n   */\n  labelMaxLength?: number;\n  /**\n   * Whether month and day names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n\n  // ---------- Ticks ----------\n  /**\n   * If provided, sets the number of minor ticks between major ticks (the value 9 results in decimal subdivision). Only applicable for axes visualizing quantitative scales.\n   */\n  subdivide?: number;\n  /**\n   * A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale's range.\n   * @minimum 0\n   */\n  ticks?: number;\n  /**\n   * The padding, in pixels, between ticks and text labels.\n   */\n  tickPadding?: number;\n  /**\n   * The size, in pixels, of major, minor and end ticks.\n   * @minimum 0\n   */\n  tickSize?: number;\n  /**\n   * The size, in pixels, of major ticks.\n   * @minimum 0\n   */\n  tickSizeMajor?: number;\n  /**\n   * The size, in pixels, of minor ticks.\n   * @minimum 0\n   */\n  tickSizeMinor?: number;\n  /**\n   * The size, in pixels, of end ticks.\n   * @minimum 0\n   */\n  tickSizeEnd?: number;\n\n  // ---------- Title ----------\n  /**\n   * A title offset value for the axis.\n   */\n  titleOffset?: number;\n  /**\n   * Max length for axis title if the title is automatically generated from the field's description. By default, this is automatically based on cell size and characterWidth property.\n   * @minimum 0\n   */\n  titleMaxLength?: number;\n  /**\n   * Character width for automatically determining title max length.\n   */\n  characterWidth?: number;\n\n  // ---------- Other ----------\n  /**\n   * Optional mark property definitions for custom axis styling.\n   */\n  properties?: any; // TODO: replace\n}\n\n// TODO: add comment for properties that we rely on Vega's default to produce\n// more concise Vega output.\n\nexport const defaultAxisConfig: AxisConfig = {\n  offset: undefined, // implicitly 0\n  grid: undefined, // automatically determined\n  labels: true,\n  labelMaxLength: 25,\n  tickSize: undefined, // implicitly 6\n  characterWidth: 6\n};\n\nexport const defaultFacetAxisConfig: AxisConfig = {\n  axisWidth: 0,\n  labels: true,\n  grid: false,\n  tickSize: 0\n};\n\nexport interface AxisProperties extends AxisConfig {\n  /**\n   * The rotation angle of the axis labels.\n   */\n  labelAngle?: number;\n  /**\n   * The formatting pattern for axis labels.\n   */\n  format?: string; // default value determined by config.format anyway\n  /**\n   * The orientation of the axis. One of top, bottom, left or right. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).\n   */\n  orient?: AxisOrient;\n  /**\n   * A title for the axis. Shows field name and its function by default.\n   */\n  title?: string;\n  values?: number[];\n}\n",
    "import {Channel, ROW, COLUMN, SHAPE, SIZE} from './channel';\n\n/**\n * Binning properties or boolean flag for determining whether to bin data or not.\n */\nexport interface BinProperties {\n  /**\n   * The minimum bin value to consider. If unspecified, the minimum value of the specified field is used.\n   */\n  min?: number;\n  /**\n   * The maximum bin value to consider. If unspecified, the maximum value of the specified field is used.\n   */\n  max?: number;\n  /**\n   * The number base to use for automatic bin determination (default is base 10).\n   */\n  base?: number;\n  /**\n   * An exact step size to use between bins. If provided, options such as maxbins will be ignored.\n   */\n  step?: number;\n  /**\n   * An array of allowable step sizes to choose from.\n   */\n  steps?: number[];\n  /**\n   * A minimum allowable step size (particularly useful for integer values).\n   */\n  minstep?: number;\n  /**\n   * Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n   */\n  div?: number[];\n  /**\n   * Maximum number of bins.\n   * @minimum 2\n   */\n  maxbins?: number;\n}\n\nexport function autoMaxBins(channel: Channel): number {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n      // Facets and Size shouldn't have too many bins\n      // We choose 6 like shape to simplify the rule\n    case SHAPE:\n      return 6; // Vega's \"shape\" has 6 distinct values\n    default:\n      return 10;\n  }\n}\n",
    "/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {Mark} from './mark';\nimport {contains, without} from './util';\n\nexport enum Channel {\n  X = 'x' as any,\n  Y = 'y' as any,\n  ROW = 'row' as any,\n  COLUMN = 'column' as any,\n  SHAPE = 'shape' as any,\n  SIZE = 'size' as any,\n  COLOR = 'color' as any,\n  TEXT = 'text' as any,\n  DETAIL = 'detail' as any,\n  LABEL = 'label' as any,\n  PATH = 'path' as any,\n  ORDER = 'order' as any\n}\n\nexport const X = Channel.X;\nexport const Y = Channel.Y;\nexport const ROW = Channel.ROW;\nexport const COLUMN = Channel.COLUMN;\nexport const SHAPE = Channel.SHAPE;\nexport const SIZE = Channel.SIZE;\nexport const COLOR = Channel.COLOR;\nexport const TEXT = Channel.TEXT;\nexport const DETAIL = Channel.DETAIL;\nexport const LABEL = Channel.LABEL;\nexport const PATH = Channel.PATH;\nexport const ORDER = Channel.ORDER;\n\nexport const CHANNELS = [X, Y, ROW, COLUMN, SIZE, SHAPE, COLOR, PATH, ORDER, TEXT, DETAIL, LABEL];\n\nexport const UNIT_CHANNELS = without(CHANNELS, [ROW, COLUMN]);\nexport const UNIT_SCALE_CHANNELS = without(UNIT_CHANNELS, [PATH, ORDER, DETAIL, TEXT, LABEL]);\nexport const NONSPATIAL_CHANNELS = without(UNIT_CHANNELS, [X, Y]);\nexport const NONSPATIAL_SCALE_CHANNELS = without(UNIT_SCALE_CHANNELS, [X, Y]);\n\nexport interface SupportedMark {\n  point?: boolean;\n  tick?: boolean;\n  rule?: boolean;\n  circle?: boolean;\n  square?: boolean;\n  bar?: boolean;\n  line?: boolean;\n  area?: boolean;\n  text?: boolean;\n};\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(channel: Channel, mark: Mark) {\n  return !!getSupportedMark(channel)[mark];\n}\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nexport function getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case X:\n    case Y:\n    case COLOR:\n    case DETAIL:\n    case ORDER:\n    case ROW:\n    case COLUMN:\n      return { // all marks\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, line: true, area: true, text: true\n      };\n    case SIZE:\n      return {\n        point: true, tick: true, rule: true, circle: true, square: true,\n        bar: true, text: true\n      };\n    case SHAPE:\n      return {point: true};\n    case TEXT:\n      return {text: true};\n    case PATH:\n      return {line: true};\n  }\n  return {};\n}\n\nexport interface SupportedRole {\n  measure: boolean;\n  dimension: boolean;\n};\n\n/**\n * Return whether a channel supports dimension / measure role\n * @param  channel\n * @return A dictionary mapping role to boolean values.\n */\nexport function getSupportedRole(channel: Channel): SupportedRole {\n  switch (channel) {\n    case X:\n    case Y:\n    case COLOR:\n    case LABEL:\n      return {\n        measure: true,\n        dimension: true\n      };\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    case DETAIL:\n      return {\n        measure: false,\n        dimension: true\n      };\n    case SIZE:\n    case TEXT:\n      return {\n        measure: true,\n        dimension: false\n      };\n    case PATH:\n      return {\n        measure: false,\n        dimension: true\n      };\n  }\n  throw new Error('Invalid encoding channel' + channel);\n}\n\nexport function hasScale(channel: Channel) {\n  return !contains([DETAIL, PATH, TEXT, LABEL, ORDER], channel);\n}\n",
    "import {AxisOrient} from '../axis';\nimport {COLUMN, ROW, X, Y, Channel} from '../channel';\nimport {title as fieldDefTitle, isDimension} from '../fielddef';\nimport {NOMINAL, ORDINAL, TEMPORAL} from '../type';\nimport {contains, keys, extend, truncate, Dict} from '../util';\nimport {VgAxis} from '../vega.schema';\n\nimport {formatMixins} from './common';\nimport {Model} from './model';\nimport {UnitModel} from './unit';\n\n// https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#11-ambient-declarations\ndeclare let exports;\n\nexport function parseAxisComponent(model: Model, axisChannels: Channel[]): Dict<VgAxis> {\n  return axisChannels.reduce(function(axis, channel) {\n    if (model.axis(channel)) {\n      axis[channel] = parseAxis(channel, model);\n    }\n    return axis;\n  }, {} as Dict<VgAxis>);\n}\n\n/**\n * Make an inner axis for showing grid for shared axis.\n */\nexport function parseInnerAxis(channel: Channel, model: Model): VgAxis {\n  const isCol = channel === COLUMN,\n    isRow = channel === ROW,\n    type = isCol ? 'x' : isRow ? 'y': channel;\n\n  // TODO: support adding ticks as well\n\n  // TODO: replace any with Vega Axis Interface\n  let def = {\n    type: type,\n    scale: model.scaleName(channel),\n    grid: true,\n    tickSize: 0,\n    properties: {\n      labels: {\n        text: {value: ''}\n      },\n      axis: {\n        stroke: {value: 'transparent'}\n      }\n    }\n  };\n\n  const axis = model.axis(channel);\n\n  ['layer', 'ticks', 'values', 'subdivide'].forEach(function(property) {\n    let method: (model: Model, channel: Channel, def:any)=>any;\n\n    const value = (method = exports[property]) ?\n                  // calling axis.format, axis.grid, ...\n                  method(model, channel, def) :\n                  axis[property];\n    if (value !== undefined) {\n      def[property] = value;\n    }\n  });\n\n  return def;\n}\n\nexport function parseAxis(channel: Channel, model: Model): VgAxis {\n  const isCol = channel === COLUMN,\n    isRow = channel === ROW,\n    type = isCol ? 'x' : isRow ? 'y': channel;\n\n  const axis = model.axis(channel);\n\n  // TODO: replace any with Vega Axis Interface\n  let def: any = {\n    type: type,\n    scale: model.scaleName(channel)\n  };\n\n  // format mixins (add format and formatType)\n  extend(def, formatMixins(model, channel, model.axis(channel).format));\n\n  // 1.2. Add properties\n  [\n    // a) properties with special rules (so it has axis[property] methods) -- call rule functions\n    'grid', 'layer', 'offset', 'orient', 'tickSize', 'ticks', 'title',\n    // b) properties without rules, only produce default values in the schema, or explicit value if specified\n    'tickPadding', 'tickSize', 'tickSizeMajor', 'tickSizeMinor', 'tickSizeEnd',\n    'titleOffset', 'values', 'subdivide'\n  ].forEach(function(property) {\n    let method: (model: Model, channel: Channel, def:any)=>any;\n\n    const value = (method = exports[property]) ?\n                  // calling axis.format, axis.grid, ...\n                  method(model, channel, def) :\n                  axis[property];\n    if (value !== undefined) {\n      def[property] = value;\n    }\n  });\n\n  // 2) Add mark property definition groups\n  const props = model.axis(channel).properties || {};\n\n  [\n    'axis', 'labels', // have special rules\n    'grid', 'title', 'ticks', 'majorTicks', 'minorTicks' // only default values\n  ].forEach(function(group) {\n    const value = properties[group] ?\n      properties[group](model, channel, props[group] || {}, def) :\n      props[group];\n    if (value !== undefined && keys(value).length > 0) {\n      def.properties = def.properties || {};\n      def.properties[group] = value;\n    }\n  });\n\n  return def;\n}\n\nexport function offset(model: Model, channel: Channel) {\n  return model.axis(channel).offset;\n}\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function gridShow(model: Model, channel: Channel) {\n  const grid = model.axis(channel).grid;\n  if (grid !== undefined) {\n    return grid;\n  }\n\n  return !model.isOrdinalScale(channel) && !model.fieldDef(channel).bin;\n}\n\nexport function grid(model: Model, channel: Channel) {\n  if (channel === ROW || channel === COLUMN) {\n    // never apply grid for ROW and COLUMN since we manually create rule-group for them\n    return undefined;\n  }\n\n  return gridShow(model, channel) && (\n    // TODO refactor this cleanly -- essentially the condition below is whether\n    // the axis is a shared / union axis.\n    (channel === Y || channel === X) && !(model.parent() && model.parent().isFacet())\n  );\n}\n\nexport function layer(model: Model, channel: Channel, def) {\n  const layer = model.axis(channel).layer;\n  if (layer !== undefined) {\n    return layer;\n  }\n  if (def.grid) {\n    // if grid is true, need to put layer on the back so that grid is behind marks\n    return 'back';\n  }\n  return undefined; // otherwise return undefined and use Vega's default.\n};\n\nexport function orient(model: Model, channel: Channel) {\n  const orient = model.axis(channel).orient;\n  if (orient) {\n    return orient;\n  } else if (channel === COLUMN) {\n    // FIXME test and decide\n    return AxisOrient.TOP;\n  }\n  return undefined;\n}\n\nexport function ticks(model: Model, channel: Channel) {\n  const ticks = model.axis(channel).ticks;\n  if (ticks !== undefined) {\n    return ticks;\n  }\n\n  // FIXME depends on scale type too\n  if (channel === X && !model.fieldDef(channel).bin) {\n    // Vega's default ticks often lead to a lot of label occlusion on X without 90 degree rotation\n    return 5;\n  }\n\n  return undefined;\n}\n\nexport function tickSize(model: Model, channel: Channel) {\n  const tickSize = model.axis(channel).tickSize;\n  if (tickSize !== undefined) {\n    return tickSize;\n  }\n  return undefined;\n}\n\n\nexport function title(model: Model, channel: Channel) {\n  const axis = model.axis(channel);\n  if (axis.title !== undefined) {\n    return axis.title;\n  }\n\n  // if not defined, automatically determine axis title from field def\n  const fieldTitle = fieldDefTitle(model.fieldDef(channel));\n\n  let maxLength;\n  if (axis.titleMaxLength) {\n    maxLength = axis.titleMaxLength;\n  } else if (channel === X && !model.isOrdinalScale(X)) {\n    const unitModel: UnitModel = model as any; // only unit model has channel x\n    // For non-ordinal scale, we know cell size at compile time, we can guess max length\n    maxLength = unitModel.config().cell.width / model.axis(X).characterWidth;\n  } else if (channel === Y && !model.isOrdinalScale(Y)) {\n    const unitModel: UnitModel = model as any; // only unit model has channel y\n    // For non-ordinal scale, we know cell size at compile time, we can guess max length\n    maxLength = unitModel.config().cell.height / model.axis(Y).characterWidth;\n  }\n\n  // FIXME: we should use template to truncate instead\n  return maxLength ? truncate(fieldTitle, maxLength) : fieldTitle;\n}\n\nexport namespace properties {\n  export function axis(model: Model, channel: Channel, axisPropsSpec, def) {\n    const axis = model.axis(channel);\n\n    return extend(\n      axis.axisWidth !== undefined ?\n        { strokeWidth: {value: axis.axisWidth} } :\n        {},\n      axisPropsSpec || {}\n    );\n  }\n\n  export function labels(model: Model, channel: Channel, labelsSpec, def) {\n    const fieldDef = model.fieldDef(channel);\n    const axis = model.axis(channel);\n\n    if (!axis.labels) {\n      return extend({\n        text: ''\n      }, labelsSpec);\n    }\n\n    if (contains([NOMINAL, ORDINAL], fieldDef.type) && axis.labelMaxLength) {\n      // TODO replace this with Vega's labelMaxLength once it is introduced\n      labelsSpec = extend({\n        text: {\n          template: '{{ datum.data | truncate:' + axis.labelMaxLength + '}}'\n        }\n      }, labelsSpec || {});\n    }\n\n    // Label Angle\n    if (axis.labelAngle !== undefined) {\n      labelsSpec.angle = {value: axis.labelAngle};\n    } else {\n      // auto rotate for X and Row\n      if (channel === X && (isDimension(fieldDef) || fieldDef.type === TEMPORAL)) {\n        labelsSpec.angle = {value: 270};\n      }\n    }\n\n    if (axis.labelAlign !== undefined) {\n      labelsSpec.align = {value: axis.labelAlign};\n    } else {\n      // Auto set align if rotated\n      // TODO: consider other value besides 270, 90\n      if (labelsSpec.angle) {\n        if (labelsSpec.angle.value === 270) {\n          labelsSpec.align = {\n            value: def.orient === 'top' ? 'left':\n                   def.type === 'x' ? 'right' :\n                   'center'\n          };\n        } else if (labelsSpec.angle.value === 90) {\n          labelsSpec.align = {value: 'center'};\n        }\n      }\n    }\n\n    if (axis.labelBaseline !== undefined) {\n      labelsSpec.baseline = {value: axis.labelBaseline};\n    } else {\n      if (labelsSpec.angle) {\n        // Auto set baseline if rotated\n        // TODO: consider other value besides 270, 90\n        if (labelsSpec.angle.value === 270) {\n          labelsSpec.baseline = {value: def.type === 'x' ? 'middle' : 'bottom'};\n        } else if (labelsSpec.angle.value === 90) {\n          labelsSpec.baseline = {value: 'bottom'};\n        }\n      }\n    }\n\n    return labelsSpec || undefined;\n  }\n}\n",
    "import {COLUMN, ROW, X, Y, SIZE, COLOR, SHAPE, TEXT, LABEL, Channel} from '../channel';\nimport {FieldDef, field, OrderChannelDef} from '../fielddef';\nimport {SortOrder} from '../sort';\nimport {QUANTITATIVE, ORDINAL, TEMPORAL} from '../type';\nimport {contains, union, isArray, array, extend, keys, isString} from '../util';\n\nimport {FacetModel} from './facet';\nimport {RepeatModel, RepeatValues} from './repeat';\nimport {LayerModel} from './layer';\nimport {ConcatModel} from './concat';\nimport {Model, isLayerModel} from './model';\nimport {format as timeFormatExpr} from './time';\nimport {UnitModel} from './unit';\nimport {Spec, isUnitSpec, isFacetSpec, isRepeatSpec, isLayerSpec, isConcatSpec} from '../spec';\nimport {Selection, Resolutions} from './selections';\n\nexport function buildModel(spec: Spec, parent: Model, parentGivenName: string, repeatValues: RepeatValues): Model {\n  if (isFacetSpec(spec)) {\n    return new FacetModel(spec, parent, parentGivenName, repeatValues);\n  }\n\n  if (isRepeatSpec(spec)) {\n    return new RepeatModel(spec, parent, parentGivenName, repeatValues);\n  }\n\n  if (isLayerSpec(spec)) {\n    return new LayerModel(spec, parent, parentGivenName, repeatValues);\n  }\n\n  if (isConcatSpec(spec)) {\n    return new ConcatModel(spec, parent, parentGivenName, repeatValues);\n  }\n\n  if (isUnitSpec(spec)) {\n    return new UnitModel(spec, parent, parentGivenName, repeatValues);\n  }\n\n  console.error('Invalid spec.');\n  return null;\n}\n\nvar RESOLVE_OPS = {};\nRESOLVE_OPS[Resolutions.UNION] = RESOLVE_OPS[Resolutions.UNION_OTHERS] = ' || ';\nRESOLVE_OPS[Resolutions.INTERSECT] = RESOLVE_OPS[Resolutions.INTERSECT_OTHERS] = ' && ';\nexport function compileSelectionPredicate(model: UnitModel, sel) {\n  var recurse = compileSelectionPredicate.bind(null, model),\n      predicate, children, parent;\n\n  if (isArray(sel)) {\n    sel = { or: sel };  // Default OR.\n  }\n\n  if (isString(sel)) {\n    sel = model.selection(sel);\n    if (sel.resolve === Resolutions.SINGLE || sel.resolve === Resolutions.INDEPENDENT) {\n      predicate = sel.predicate;\n    } else {\n      // Layer children build up selections, so only get the last child.\n      // Resolution happens across other composites.\n      parent = model.parent();\n      if (isLayerModel(parent)) parent = parent.parent();\n\n      children = parent.children();\n      if (sel.resolve === Resolutions.UNION_OTHERS || sel.resolve == Resolutions.INTERSECT_OTHERS) {\n        children = children.filter((c) => c !== model);\n      }\n\n      predicate = children.map((c) => c.selection(sel._name).predicate)\n        .join(RESOLVE_OPS[sel.resolve]);\n    }\n  }\n\n  return predicate ? '(' + predicate + ')' :\n    sel.or ? array(sel.or).map(recurse).join(' || ') :\n      sel.and ? array(sel.and).map(recurse).join(' && ') :\n        sel.not ? '(!' + recurse(sel.not) + ')' : null;\n}\n\nexport function compileIfThenElse(model: UnitModel, channel: Channel, output, cb) {\n  const ruleDef = model.fieldDefs(channel);\n\n  // RuleDef is just a regular FieldDef.\n  if (!isArray(ruleDef)) return extend(output, cb(ruleDef));\n\n  array(ruleDef).forEach(function(fieldDef) {\n    var selection = fieldDef.if || fieldDef.elseif,\n        predicate = selection && compileSelectionPredicate(model, selection);\n\n    const property = cb(fieldDef);\n    keys(property).forEach(function(k) {\n      const o = isArray(output[k]) && output[k] || (output[k] = []);\n      if (predicate) property[k].test = predicate;\n      o.push(property[k]);\n    });\n  });\n}\n\n// TODO: figure if we really need opacity in both\nexport const STROKE_CONFIG = ['stroke', 'strokeWidth',\n  'strokeDash', 'strokeDashOffset', 'strokeOpacity', 'opacity'];\n\nexport const FILL_CONFIG = ['fill', 'fillOpacity',\n  'opacity'];\n\nexport const FILL_STROKE_CONFIG = union(STROKE_CONFIG, FILL_CONFIG);\n\nexport function applyColorAndOpacity(p, model: UnitModel) {\n  const filled = model.config().mark.filled,\n        property = filled ? 'fill' : 'stroke';\n\n  // Apply fill stroke config first so that color field / value can override\n  // fill / stroke\n  if (filled) {\n    applyMarkConfig(p, model, FILL_CONFIG);\n  } else {\n    applyMarkConfig(p, model, STROKE_CONFIG);\n  }\n\n  compileIfThenElse(model, COLOR, p, function(fieldDef) {\n    let props = {};\n    if (fieldDef.field) {\n      props[property] = {\n        scale: model.scaleName(COLOR),\n        field: model.field(COLOR,\n          fieldDef.type === ORDINAL ? {prefn: 'rank_'} : {}, fieldDef)\n      };\n    } else if (fieldDef.value) {\n      props[property] = { value: fieldDef.value };\n    } else {\n      props[property] = p[property] || { value: model.config().mark.color };\n    }\n    return props;\n  });\n}\n\nexport function applyConfig(properties, config, propsList: string[]) {\n  propsList.forEach(function(property) {\n    const value = config[property];\n    if (value !== undefined) {\n      properties[property] = { value: value };\n    }\n  });\n  return properties;\n}\n\nexport function applyMarkConfig(marksProperties, model: UnitModel, propsList: string[]) {\n  return applyConfig(marksProperties, model.config().mark, propsList);\n}\n\n\n/**\n * Builds an object with format and formatType properties.\n *\n * @param format explicitly specified format\n */\nexport function formatMixins(model: Model, channel: Channel, format: string) {\n  const fieldDef = model.fieldDef(channel);\n\n  if(!contains([QUANTITATIVE, TEMPORAL], fieldDef.type)) {\n    return {};\n  }\n\n  let def: any = {};\n\n  if (fieldDef.type === TEMPORAL) {\n    def.formatType = 'time';\n  }\n\n  if (format !== undefined) {\n    def.format = format;\n  } else {\n    switch (fieldDef.type) {\n      case QUANTITATIVE:\n        def.format = model.config().numberFormat;\n        break;\n      case TEMPORAL:\n        def.format = timeFormat(model, channel) || model.config().timeFormat;\n        break;\n    }\n  }\n\n  if (channel === TEXT) {\n    // text does not support format and formatType\n    // https://github.com/vega/vega/issues/505\n\n    const filter = (def.formatType || 'number') + (def.format ? ':\\'' + def.format + '\\'' : '');\n    return {\n      text: {\n        template: '{{' + model.field(channel, { datum: true }) + ' | ' + filter + '}}'\n      }\n    };\n  }\n\n  return def;\n}\n\nfunction isAbbreviated(model: Model, channel: Channel, fieldDef: FieldDef) {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case X:\n    case Y:\n      return model.axis(channel).shortTimeLabels;\n    case COLOR:\n    case SHAPE:\n    case SIZE:\n      return model.legend(channel).shortTimeLabels;\n    case TEXT:\n      return model.config().mark.shortTimeLabels;\n    case LABEL:\n      // TODO(#897): implement when we have label\n  }\n  return false;\n}\n\n\n\n/** Return field reference with potential \"-\" prefix for descending sort */\nexport function sortField(orderChannelDef: OrderChannelDef) {\n  return (orderChannelDef.sort === SortOrder.DESCENDING ? '-' : '') + field(orderChannelDef);\n}\n\n/**\n * Returns the time format used for axis labels for a time unit.\n */\nexport function timeFormat(model: Model, channel: Channel): string {\n  const fieldDef = model.fieldDef(channel);\n  return timeFormatExpr(fieldDef.timeUnit, isAbbreviated(model, channel, fieldDef));\n}\n",
    "/**\n * Module for compiling Vega-lite spec into Vega spec.\n */\n\nimport {LAYOUT} from '../data';\nimport {Model} from './model';\nimport {normalize, ExtendedSpec} from '../spec';\nimport {extend} from '../util';\n\nimport {buildModel} from './common';\n\nexport function compile(inputSpec: ExtendedSpec) {\n  // 1. Convert input spec into a normal form\n  // (Decompose all extended unit specs into composition of unit spec.)\n  const spec = normalize(inputSpec);\n\n  // 2. Instantiate the model with default properties\n  const model = buildModel(spec, null, '', null);\n\n  // 3. Parse each part of the model to produce components that will be assembled later\n  // We traverse the whole tree to parse once for each type of components\n  // (e.g., data, layout, mark, scale).\n  // Please see inside model.parse() for order for compilation.\n  model.parse();\n\n  // 4. Assemble a Vega Spec from the parsed components in 3.\n  return assemble(model);\n}\n\nfunction assemble(model: Model) {\n  const config = model.config();\n\n  // TODO: change type to become VgSpec\n  const output = extend(\n    {\n      // Set size to 1 because we rely on padding anyway\n      width: 1,\n      height: 1,\n      padding: 'auto'\n    },\n    config.viewport ? { viewport: config.viewport } : {},\n    config.background ? { background: config.background } : {},\n    {\n      signals: model.assembleSignals([]),\n      data: [].concat(\n        model.assemblePreSelectionData([]),\n        model.assembleData([]),\n        model.assembleLayout([]),\n        model.assemblePostSelectionData([])\n      ),\n      marks: [assembleRootGroup(model)]\n    });\n\n  return {\n    spec: output\n    // TODO: add warning / errors here\n  };\n}\n\nexport function assembleRootGroup(model: Model) {\n  let rootGroup:any = extend({\n      name: model.name('root'),\n      type: 'group',\n    },\n    model.description() ? {description: model.description()} : {},\n    {\n      from: {data: LAYOUT},\n      properties: {\n        update: extend(\n          {\n            width: {field: 'width'},\n            height: {field: 'height'}\n          },\n          model.assembleParentGroupProperties(model.config().cell)\n        )\n      }\n    });\n\n  return extend(rootGroup, model.assembleGroup());\n}\n",
    "import {Channel} from '../channel';\nimport {keys, duplicate, mergeDeep, flatten, unique, isArray, vals, forEach, hash, Dict, extend} from '../util';\nimport {defaultConfig, Config} from '../config';\nimport {ConcatSpec, isConcatSpec, isUnitSpec} from '../spec';\nimport {assembleData, parseConcatData} from './data/data';\nimport {assembleLayout, parseConcatLayout} from './layout';\nimport {Model, isUnitModel} from './model';\nimport {UnitModel} from './unit';\nimport {buildModel} from './common';\nimport {FieldDef} from '../fielddef';\nimport {ScaleComponents} from './scale';\nimport {VgData, VgAxis, VgLegend, isUnionedDomain, isDataRefDomain, VgDataRef} from '../vega.schema';\nimport {RepeatValues} from './repeat';\nimport {LAYOUT} from '../data';\nimport * as selections from './selections';\n\nexport class ConcatModel extends Model {\n  _direction;\n  public _select: any;  // To collate all the child selections\n\n  constructor(spec: ConcatSpec, parent: Model, parentGivenName: string, repeatValues: RepeatValues) {\n    super(spec, parent, parentGivenName, repeatValues);\n\n    this._select = {};\n    this._direction = 'vertical';\n    this._config = this._initConfig(spec.config, parent);\n    this._children = spec.vconcat.map((child, i) => {\n      if (isUnitSpec(child)) {\n        child.select = extend(this._select, child.select);\n        extend(this._select, child.select);\n      }\n\n      return buildModel(child, this, this.name('child_' + i), repeatValues);\n    });\n  }\n\n  private _initConfig(specConfig: Config, parent: Model) {\n    return mergeDeep(duplicate(defaultConfig), specConfig, parent ? parent.config() : {});\n  }\n\n  public has(channel: Channel): boolean {\n    // concat does not have any channels\n    return false;\n  }\n\n  public isOrdinalScale(channel: Channel) {\n    return null;\n  }\n\n  public dataTable(): string {\n    // FIXME: remove this hack\n    return this._children[0].dataTable();\n  }\n\n  public isRepeatRef(channel: Channel) {\n    // todo\n    return false;\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    return null; // layer does not have field defs\n  }\n\n  public stack() {\n    return null; // this is only a property for UnitModel\n  }\n\n  public parseSelection() {\n    this._select = {};\n    this.component.selection = [];\n    this._children.forEach((child) => {\n      // Children within layers can reference selections defined prior.\n      // We first parse a child's selections, then extend them with their siblings'.\n      child.parseSelection();\n      if (isUnitModel(child)) {\n        extend(this._select, child._select);\n        this.component.selection.push.apply(this.component.selection, child.selection());\n      }\n    });\n  }\n\n  public parseData() {\n    this._children.forEach((child) => {\n      child.parseData();\n    });\n    this.component.data = parseConcatData(this);\n  }\n\n  public parseLayoutData() {\n    // TODO: correctly union ordinal scales rather than just using the layout of the first child\n    this._children.forEach((child) => {\n      child.parseLayoutData();\n    });\n    this.component.layout = parseConcatLayout(this);\n  }\n\n  public parseScale() {\n    this._children.forEach(function(child) {\n      child.parseScale();\n    });\n  }\n\n  public parseMark() {\n    this._children.forEach(function(child) {\n      child.parseMark();\n    });\n  }\n\n  public parseAxis() {\n    this._children.forEach(function(child) {\n      child.parseAxis();\n    });\n  }\n\n  public parseAxisGroup() {\n    return null;\n  }\n\n  public parseGridGroup() {\n    return null;\n  }\n\n  public parseLegend() {\n    this.component.legend = {} as Dict<VgLegend>;\n\n    this._children.forEach(function(child) {\n      child.parseLegend();\n    });\n  }\n\n  public assembleParentGroupProperties() {\n    return {\n      unitName: { value: this.name() }\n    };\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    // Prefix traversal – parent data might be referred to by children data\n    assembleData(this, data);\n    this._children.forEach((child) => {\n      child.assembleData(data);\n    });\n    return data;\n  }\n\n  public assemblePreSelectionData(data: VgData[]): VgData[] {\n    this._children.forEach((child) => child.assemblePreSelectionData(data));\n    return selections.assembleCompositeData(this, data);\n  }\n\n  public assemblePostSelectionData(data: VgData[]): VgData[] {\n    this._children.forEach((child) => child.assemblePostSelectionData(data));\n    return selections.assembleCompositeData(this, data);\n  }\n\n  public assembleSignals(signals) {\n    this._children.forEach((child) => child.assembleSignals(signals));\n    return selections.assembleCompositeSignals(this, signals);\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    // Postfix traversal – layout is assembled bottom-up\n    this._children.forEach((child) => {\n      child.assembleLayout(layoutData);\n    });\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks(): any[] {\n    const offset = +this.children()[0].component.layout.height.formula[0].expr + 60;\n    return flatten(this._children.map((child, i) => {\n      return extend(\n        {\n          name: child.name('cell'),\n          type: 'group',\n          from: {data: child.dataName(LAYOUT)},\n          properties: {\n            update: getConcatGroupProperties(this, child, i > 0 ? offset: 0)\n          }\n        },\n        // Call child's assembleGroup to add marks and axes (legends and scales should have been moved up).\n        // Note that we can call child's assembleGroup() here because parseMark()\n        // is the last method in compile() and thus the child is completely compiled\n        // at this point.\n        child.assembleGroup()\n      );\n    }));\n  }\n\n  public channels() {\n    return [];\n  }\n\n  protected mapping() {\n    return null;\n  }\n\n  public isConcat() {\n    return true;\n  }\n\n  public compatibleSource(child: UnitModel) {\n    const sourceUrl = this.data() && this.data().url;\n    const childData = child.component.data;\n    const compatible = !childData.source || (sourceUrl && sourceUrl === childData.source.url);\n    return compatible;\n  }\n}\n\nfunction getConcatGroupProperties(model: ConcatModel, child: Model, offset: number) {\n  const mergedCellConfig = extend({}, child.config().cell, child.config().facet.cell);\n\n  return extend(model._direction === 'vertical' ? {\n      y: {value: offset},\n      width: {field: child.sizeName('width')},\n      height: {field: child.sizeName('height')}\n    }:{\n      x: {value: offset},\n      width: {field: child.sizeName('width')},\n      height: {field: child.sizeName('height')}\n    },\n    child.assembleParentGroupProperties(mergedCellConfig)\n  );\n}\n",
    "import {X, DETAIL} from '../channel';\nimport {Config} from '../config';\nimport {Encoding} from '../encoding';\nimport {isAggregate, has} from '../encoding';\nimport {isMeasure} from '../fielddef';\nimport {POINT, LINE, TICK, CIRCLE, SQUARE, RULE, Mark} from '../mark';\nimport {contains, extend} from '../util';\n\n/**\n * Augment config.mark with rule-based default values.\n */\nexport function initMarkConfig(mark: Mark, encoding: Encoding, config: Config) {\n   return extend(\n     ['filled', 'opacity', 'orient', 'align'].reduce(function(cfg, property: string) {\n       const value = config.mark[property];\n       switch (property) {\n         case 'filled':\n           if (value === undefined) {\n             // Point, line, and rule are not filled by default\n             cfg[property] = mark !== POINT && mark !== LINE && mark !== RULE;\n           }\n           break;\n         case 'opacity':\n           if (value === undefined && contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n             // point-based marks and bar\n             if (!isAggregate(encoding) || has(encoding, DETAIL)) {\n               cfg[property] = 0.7;\n             }\n           }\n           break;\n         case 'orient':\n           const xIsMeasure = isMeasure(encoding.x);\n           const yIsMeasure = isMeasure(encoding.y);\n\n           // When unambiguous, do not allow overriding\n           if (xIsMeasure && !yIsMeasure) {\n             cfg[property] = 'horizontal'; // implicitly vertical\n           } else if (!xIsMeasure && yIsMeasure) {\n             cfg[property] = undefined; // implicitly vertical\n           }\n\n           // In ambiguous cases (QxQ or OxO) use specified value\n           // (and implicitly vertical by default.)\n           break;\n         // text-only\n         case 'align':\n          if (value === undefined) {\n            cfg[property] = has(encoding, X) ? 'center' : 'right';\n          }\n       }\n       return cfg;\n     }, {}),\n     config.mark\n   );\n}\n",
    "import {autoMaxBins} from '../../bin';\nimport {Channel, COLOR} from '../../channel';\nimport {field, FieldDef} from '../../fielddef';\nimport {extend, vals, flatten, hash, Dict} from '../../util';\nimport {VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from './../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model} from '../model';\n\nimport {DataComponent} from './data';\n\nexport namespace bin {\n  function parse(model: Model): Dict<VgTransform[]> {\n    return model.reduce(function(binComponent, fieldDef: FieldDef, channel: Channel) {\n      const bin = model.fieldDef(channel).bin;\n      if (bin) {\n        let binTrans = extend({\n          type: 'bin',\n          field: fieldDef.field,\n          output: {\n            start: field(fieldDef, { binSuffix: '_start' }),\n            mid: field(fieldDef, { binSuffix: '_mid' }),\n            end: field(fieldDef, { binSuffix: '_end' })\n          }\n        },\n          // if bin is an object, load parameter here!\n          typeof bin === 'boolean' ? {} : bin\n        );\n\n        if (!binTrans.maxbins && !binTrans.step) {\n          // if both maxbins and step are not specified, need to automatically determine bin\n          binTrans.maxbins = autoMaxBins(channel);\n        }\n\n        const transform = [binTrans];\n        const isOrdinalColor = model.isOrdinalScale(channel) || channel === COLOR;\n        // color ramp has type linear or time\n        if (isOrdinalColor) {\n          transform.push({\n            type: 'formula',\n            field: field(fieldDef, { binSuffix: '_range' }),\n            expr: field(fieldDef, { datum: true, binSuffix: '_start' }) +\n            ' + \\'-\\' + ' +\n            field(fieldDef, { datum: true, binSuffix: '_end' })\n          });\n        }\n        // FIXME: current merging logic can produce redundant transforms when a field is binned for color and for non-color\n        const key = hash(bin) + '_' + fieldDef.field + 'oc:' + isOrdinalColor;\n        binComponent[key] = transform;\n      }\n      return binComponent;\n    }, {});\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let binComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      // FIXME: current merging logic can produce redundant transforms when a field is binned for color and for non-color\n      extend(binComponent, childDataComponent.bin);\n      delete childDataComponent.bin;\n    }\n    return binComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let binComponent = parse(model);\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(binComponent, childDataComponent.bin);\n        delete childDataComponent.bin;\n      }\n    });\n\n    return binComponent;\n  }\n\n  export function parseRepeat(model: RepeatModel) {\n    let binComponent = parse(model);\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(binComponent, childDataComponent.bin);\n        delete childDataComponent.bin;\n      }\n    });\n\n    return binComponent;\n  }\n\n  export function parseConcat(model: ConcatModel) {\n    let binComponent = parse(model);\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(binComponent, childDataComponent.bin);\n        delete childDataComponent.bin;\n      }\n    });\n\n    return binComponent;\n  }\n\n  export function assemble(component: DataComponent) {\n    return flatten(vals(component.bin));\n  }\n}",
    "import {COLOR} from '../../channel';\nimport {ORDINAL} from '../../type';\nimport {extend, vals, flatten, hash, Dict} from '../../util';\nimport {VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from './../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model} from '../model';\n\nimport {DataComponent} from './data';\n\n\n/**\n * We need to add a rank transform so that we can use the rank value as\n * input for color ramp's linear scale.\n */\nexport namespace colorRank {\n  /**\n   * Return hash dict from a color field's name to the sort and rank transforms\n   */\n  export function parseUnit(model: Model) {\n    let colorRankComponent: Dict<VgTransform[]> = {};\n    if (model.has(COLOR) && model.fieldDef(COLOR).type === ORDINAL) {\n      // TODO(domoritz): what is the right thing?\n      colorRankComponent[hash(model.field(COLOR))] = [{\n        type: 'sort',\n        by: model.field(COLOR)\n      }, {\n        type: 'rank',\n        field: model.field(COLOR),\n        output: {\n          rank: model.field(COLOR, { prefn: 'rank_' })\n        }\n      }];\n    }\n    return colorRankComponent;\n  }\n\n  export function parseFacet(model: FacetModel) {\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then consider merging\n    if (!childDataComponent.source) {\n      // TODO: we have to see if color has union scale here\n\n      // For now, let's assume it always has union scale\n      const colorRankComponent = childDataComponent.colorRank;\n      delete childDataComponent.colorRank;\n      return colorRankComponent;\n    }\n    return {} as Dict<VgTransform[]>;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let colorRankComponent = {} as Dict<VgTransform[]>;\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(colorRankComponent, childDataComponent.colorRank);\n        delete childDataComponent.colorRank;\n      }\n    });\n\n    return colorRankComponent;\n  }\n\n  export function parseRepeat(model: RepeatModel) {\n    let colorRankComponent = {} as Dict<VgTransform[]>;\n\n    // TODO(kanitw): consider merging multiple transform into one? \n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(colorRankComponent, childDataComponent.colorRank);\n        delete childDataComponent.colorRank;\n      }\n    });\n\n    return colorRankComponent;\n  }\n\n  export function parseConcat(model: ConcatModel) {\n    let colorRankComponent = {} as Dict<VgTransform[]>;\n\n    // TODO(kanitw): consider merging multiple transform into one? \n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(colorRankComponent, childDataComponent.colorRank);\n        delete childDataComponent.colorRank;\n      }\n    });\n\n    return colorRankComponent;\n  }\n\n  export function assemble(component: DataComponent) {\n    return flatten(vals(component.colorRank));\n  }\n}",
    "import {Formula, Lookup} from '../../transform';\nimport {keys, Dict, StringSet, extend, isArray, isObject} from '../../util';\nimport {VgData, VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {RepeatModel} from '../repeat';\nimport {LayerModel} from '../layer';\nimport {ConcatModel} from './../concat';\nimport {Model} from '../model';\nimport {UnitModel} from '../unit';\n\nimport {source} from './source';\nimport {formatParse} from './formatparse';\nimport {nullFilter} from './nullfilter';\nimport {filter} from './filter';\nimport {filterWith} from './filterwith';\nimport {bin} from './bin';\nimport {formula} from './formula';\nimport {nonPositiveFilter} from './nonpositivenullfilter';\nimport {summary} from './summary';\nimport {stackScale} from './stackscale';\nimport {timeUnit} from './timeunit';\nimport {timeUnitDomain} from './timeunitdomain';\nimport {colorRank} from './colorrank';\nimport {lookup} from './lookup';\n\n\n/**\n * Composable component instance of a model's data.\n */\nexport interface DataComponent {\n  source: VgData;\n\n  /** Mapping from field name to primitive data type.  */\n  formatParse: Dict<string>;\n\n  /** String set of fields for null filtering */\n  nullFilter: Dict<boolean>;\n\n  /** Hashset of a formula object */\n  calculate: Dict<Formula>;\n\n  /** Filter test expression */\n  filter: string;\n\n  /** Filter test expression against selections */\n  filterWith: string;\n\n  /** Dictionary mapping a bin parameter hash to transforms of the binned field */\n  bin: Dict<VgTransform[]>;\n\n  /** Dictionary mapping an output field name (hash) to the time unit transform  */\n  timeUnit: Dict<VgTransform>;\n\n  /** String set of fields to be filtered */\n  nonPositiveFilter: Dict<boolean>;\n\n  /** Data source for feeding stacked scale. */\n  // TODO: need to revise if single VgData is sufficient with layer / concat\n  stackScale: VgData;\n\n  /** Dictionary mapping an output field name (hash) to the sort and rank transforms  */\n  colorRank: Dict<VgTransform[]>;\n\n  /** String set of time units that need their own data sources for scale domain */\n  timeUnitDomain: StringSet;\n\n  /** Array of summary component object for producing summary (aggregate) data source */\n  summary: SummaryComponent[];\n\n  /** Hashset of looup objects */\n  lookup?: Dict<Lookup>;\n}\n\n/**\n * Composable component for a model's summary data\n */\nexport interface SummaryComponent {\n  /** Name of the summary data source */\n  name: string;\n\n  /** String set for all dimension fields  */\n  dimensions: StringSet;\n\n  /** dictionary mapping field name to string set of aggregate ops */\n  measures: Dict<StringSet>;\n}\n\n// TODO: split this file into multiple files and remove this linter flag\n/* tslint:disable:no-use-before-declare */\n\nexport function parseUnitData(model: UnitModel): DataComponent {\n  return {\n    formatParse: formatParse.parseUnit(model),\n    nullFilter: nullFilter.parseUnit(model),\n    filter: filter.parseUnit(model),\n    nonPositiveFilter: nonPositiveFilter.parseUnit(model),\n    filterWith: filterWith.parseUnit(model),\n\n    source: source.parseUnit(model),\n    lookup: lookup.parseUnit(model),\n    bin: bin.parseUnit(model),\n    calculate: formula.parseUnit(model),\n    timeUnit: timeUnit.parseUnit(model),\n    timeUnitDomain: timeUnitDomain.parseUnit(model),\n    summary: summary.parseUnit(model),\n    stackScale: stackScale.parseUnit(model),\n    colorRank: colorRank.parseUnit(model)\n  };\n}\n\nexport function parseFacetData(model: FacetModel): DataComponent {\n  return {\n    formatParse: formatParse.parseFacet(model),\n    nullFilter: nullFilter.parseFacet(model),\n    filter: filter.parseFacet(model),\n    nonPositiveFilter: nonPositiveFilter.parseFacet(model),\n    filterWith: filterWith.parseFacet(model),\n\n    source: source.parseFacet(model),\n    lookup: lookup.parseFacet(model),\n    bin: bin.parseFacet(model),\n    calculate: formula.parseFacet(model),\n    timeUnit: timeUnit.parseFacet(model),\n    timeUnitDomain: timeUnitDomain.parseFacet(model),\n    summary: summary.parseFacet(model),\n    stackScale: stackScale.parseFacet(model),\n    colorRank: colorRank.parseFacet(model)\n  };\n}\n\nexport function parseLayerData(model: LayerModel): DataComponent {\n  return {\n    // filter and formatParse could cause us to not be able to merge into parent\n    // so let's parse them first\n    formatParse: formatParse.parseLayer(model),\n    nullFilter: nullFilter.parseLayer(model),\n    filter: filter.parseLayer(model),\n    nonPositiveFilter: nonPositiveFilter.parseLayer(model),\n    filterWith: filterWith.parseLayer(model),\n\n    // everything after here does not affect whether we can merge child data into parent or not\n    source: source.parseLayer(model),\n    lookup: lookup.parseLayer(model),\n    bin: bin.parseLayer(model),\n    calculate: formula.parseLayer(model),\n    timeUnit: timeUnit.parseLayer(model),\n    timeUnitDomain: timeUnitDomain.parseLayer(model),\n    summary: summary.parseLayer(model),\n    stackScale: stackScale.parseLayer(model),\n    colorRank: colorRank.parseLayer(model)\n  };\n}\n\nexport function parseRepeatData(model: RepeatModel): DataComponent {\n  const repeatData = {\n    formatParse: formatParse.parseRepeat(model),\n    nullFilter: nullFilter.parseRepeat(model),\n    filter: filter.parseRepeat(model),\n    nonPositiveFilter: nonPositiveFilter.parseRepeat(model),\n    filterWith: filterWith.parseRepeat(model),\n\n    source: source.parseRepeat(model),\n    bin: bin.parseRepeat(model),\n    calculate: formula.parseRepeat(model),\n    timeUnit: timeUnit.parseRepeat(model),\n    timeUnitDomain: timeUnitDomain.parseRepeat(model),\n    summary: summary.parseRepeat(model),\n    stackScale: stackScale.parseRepeat(model),\n    colorRank: colorRank.parseRepeat(model)\n  };\n\n  // remove as soon as you can: überhack: add same binning to all source two children deep\n  let binComponent = {} as Dict<VgTransform[]>;\n\n  function iterate(f) {\n    model.children().forEach((child: Model) => {\n      f(child);\n      child.children().forEach((child2) => {\n        f(child2);\n      });\n    });\n  }\n\n  iterate((child) => {\n    extend(binComponent, child.component.data.bin);\n  });\n  iterate((child) => {\n    child.component.data.bin = binComponent;\n  });\n\n  return repeatData;\n}\n\nexport function parseConcatData(model: ConcatModel): DataComponent {\n  return {\n    formatParse: formatParse.parseConcat(model),\n    nullFilter: nullFilter.parseConcat(model),\n    filter: filter.parseConcat(model),\n    nonPositiveFilter: nonPositiveFilter.parseConcat(model),\n    filterWith: filterWith.parseConcat(model),\n\n    source: source.parseConcat(model),\n    lookup: lookup.parseConcat(model),\n    bin: bin.parseConcat(model),\n    calculate: formula.parseConcat(model),\n    timeUnit: timeUnit.parseConcat(model),\n    timeUnitDomain: timeUnitDomain.parseConcat(model),\n    summary: summary.parseConcat(model),\n    stackScale: stackScale.parseConcat(model),\n    colorRank: colorRank.parseConcat(model)\n  };\n}\n\n\n/* tslint:enable:no-use-before-declare */\n\n/**\n * Creates Vega Data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleData(model: Model, data: VgData[]) {\n  const component = model.component.data;\n\n  const sourceData = source.assemble(model, component);\n  if (isArray(sourceData)) {\n    data.push.apply(data, sourceData);\n  } else if (isObject(sourceData)) {\n    data.push(sourceData);\n  }\n\n  summary.assemble(component, model).forEach(function(summaryData) {\n    data.push(summaryData);\n  });\n\n  if (data.length > 0) {\n    const dataTable = data[data.length - 1];\n\n    // color rank\n    const colorRankTransform = colorRank.assemble(component);\n    if (colorRankTransform.length > 0) {\n      dataTable.transform = (dataTable.transform || []).concat(colorRankTransform);\n    }\n\n    // nonPositiveFilter\n    const nonPositiveFilterTransform = nonPositiveFilter.assemble(component);\n    if (nonPositiveFilterTransform.length > 0) {\n      dataTable.transform = (dataTable.transform || []).concat(nonPositiveFilterTransform);\n    }\n  } else {\n    if (keys(component.colorRank).length > 0) {\n      throw new Error('Invalid colorRank not merged');\n    } else if (keys(component.nonPositiveFilter).length > 0) {\n      throw new Error('Invalid nonPositiveFilter not merged');\n    }\n  }\n\n  // stack\n  // TODO: revise if this actually should be an array\n  const stackData = stackScale.assemble(component);\n  if (stackData) {\n    data.push(stackData);\n  }\n\n  timeUnitDomain.assemble(component).forEach(function(timeUnitDomainData) {\n    data.push(timeUnitDomainData);\n  });\n  return data;\n}\n",
    "import {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from '../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model} from '../model';\nimport {unique} from '../../util';\n\nimport {DataComponent} from './data';\n\n\nexport namespace filter {\n  function parse(model: Model): string {\n    return model.transform().filter;\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let filterComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source but has filter, then merge\n    if (!childDataComponent.source && childDataComponent.filter) {\n      // merge by adding &&\n      filterComponent =\n        (filterComponent ? filterComponent + ' && ' : '') +\n        childDataComponent.filter;\n      delete childDataComponent.filter;\n    }\n    return filterComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // Note that this `filter.parseLayer` method is called before `source.parseLayer`\n    let filterComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && childDataComponent.filter && childDataComponent.filter === filterComponent) {\n        // same filter in child so we can just delete it\n        delete childDataComponent.filter;\n      }\n    });\n    return filterComponent;\n  }\n\n  export function parseRepeat(model: RepeatModel) {\n    // Note that this `filter.parseLayer` method is called before `source.parseLayer`\n\n    const filters = model.children().map((child) => child.component.data.filter);\n    if (unique(filters).length === 1) {\n      // all filters are the same\n      model.children().forEach((child) => {\n        const childDataComponent = child.component.data;\n        delete childDataComponent.filter;\n      });\n      return filters[0];\n    }\n\n    return null;\n  }\n\n  export function parseConcat(model: ConcatModel) {\n    const filters = model.children().map((child) => child.component.data.filter);\n    if (unique(filters).length === 1) {\n      // all filters are the same\n      model.children().forEach((child) => {\n        const childDataComponent = child.component.data;\n        delete childDataComponent.filter;\n      });\n      return filters[0];\n    }\n\n    return null;\n  }\n\n  export function assemble(component: DataComponent) {\n    const filter = component.filter;\n    return filter ? [{\n      type: 'filter',\n      test: filter\n    }] : [];\n  }\n}\n",
    "import {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from '../repeat';\nimport {ConcatModel} from './../concat';\nimport {UnitModel} from '../unit';\nimport {Model} from '../model';\nimport {unique} from '../../util';\nimport {compileSelectionPredicate} from '../common';\n\nimport {DataComponent} from './data';\n\nexport namespace filterWith {\n  function parse(model: UnitModel): string {\n    var fw = model.transform().filterWith;\n    return fw ? compileSelectionPredicate(model, model.transform().filterWith) : null;\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    // todo\n    return null;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // Note that this `filter.parseLayer` method is called before `source.parseLayer`\n    let filterComponent = '';\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && childDataComponent.filterWith && childDataComponent.filterWith === filterComponent) {\n        // same filter in child so we can just delete it\n        delete childDataComponent.filterWith;\n      }\n    });\n    return filterComponent;\n  }\n\n  export function parseRepeat(model: RepeatModel) {\n    // Note that this `filter.parseLayer` method is called before `source.parseLayer`\n\n    const filters = model.children().map((child) => child.component.data.filterWith);\n    if (unique(filters).length === 1) {\n      // all filters are the same\n      model.children().forEach((child) => {\n        const childDataComponent = child.component.data;\n        delete childDataComponent.filterWith;\n      });\n      return filters[0];\n    }\n\n    return null;\n  }\n\n  export function parseConcat(model: ConcatModel) {\n    // Note that this `filter.parseLayer` method is called before `source.parseLayer`\n\n    const filters = model.children().map((child) => child.component.data.filterWith);\n    if (unique(filters).length === 1) {\n      // all filters are the same\n      model.children().forEach((child) => {\n        const childDataComponent = child.component.data;\n        delete childDataComponent.filterWith;\n      });\n      return filters[0];\n    }\n\n    return null;\n  }\n\n  export function assemble(component: DataComponent) {\n    const filter = component.filterWith;\n    return filter ? [{\n      type: 'filter',\n      test: filter\n    }] : [];\n  }\n}\n",
    "import {FieldDef, isCount} from '../../fielddef';\nimport {Channel} from '../../channel';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {extend, differ, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {RepeatModel} from './../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model} from './../model';\n\nexport namespace formatParse {\n  // TODO: need to take calculate into account across levels when merging\n  function parse(model: Model): Dict<string> {\n    const calcFieldMap = (model.transform().calculate || []).reduce(function(fieldMap, formula) {\n      fieldMap[formula.field] = true;\n      return fieldMap;\n    }, {});\n\n    let parseComponent: Dict<string> = {};\n    // use forEach rather than reduce so that it can return undefined\n    // if there is no parse needed\n    model.forEach(function(fieldDef: FieldDef, channel: Channel) {\n      const field = model.fieldOrig(channel);\n      if (fieldDef.type === TEMPORAL) {\n        parseComponent[field] = 'date';\n      } else if (fieldDef.type === QUANTITATIVE) {\n        if (isCount(fieldDef) || calcFieldMap[field]) {\n          return;\n        }\n        parseComponent[field] = 'number';\n      }\n    });\n    return parseComponent;\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let parseComponent = parse(model);\n\n    // If child doesn't have its own data source, but has its own parse, then merge\n    const childDataComponent = model.child().component.data;\n    if (!childDataComponent.source && childDataComponent.formatParse) {\n      extend(parseComponent, childDataComponent.formatParse);\n      delete childDataComponent.formatParse;\n    }\n    return parseComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // note that we run this before source.parseLayer\n    let parseComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ(childDataComponent.formatParse, parseComponent)) {\n        // merge parse up if the child does not have an incompatible parse\n        extend(parseComponent, childDataComponent.formatParse);\n        delete childDataComponent.formatParse;\n      }\n    });\n    return parseComponent;\n  }\n\n  export function parseRepeat(model: RepeatModel): Dict<string> {\n    let parseComponent = {} as Dict<string>;\n\n    const children = model.children();\n    for (let i = 0; i < children.length; i++) {\n      const childDataComponent = children[i].component.data;\n      if (!differ(childDataComponent.formatParse, parseComponent)) {\n        extend(parseComponent, childDataComponent.formatParse);\n      } else {\n        // children are incompatible\n        return {};\n      }\n    }\n\n    // children are compatible so let's delete their null filters\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      delete childDataComponent.formatParse;\n    });\n\n    return parseComponent;\n  }\n\n  export function parseConcat(model: ConcatModel): Dict<string> {\n    let parseComponent = {} as Dict<string>;\n\n    const children = model.children();\n    for (let i = 0; i < children.length; i++) {\n      const childDataComponent = children[i].component.data;\n      if (!differ(childDataComponent.formatParse, parseComponent)) {\n        extend(parseComponent, childDataComponent.formatParse);\n      } else {\n        // children are incompatible\n        return {};\n      }\n    }\n\n    // children are compatible so let's delete their null filters\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      delete childDataComponent.formatParse;\n    });\n\n    return parseComponent;\n  }\n\n  // Assemble for formatParse is an identity function, no need to declare\n}\n",
    "import {Formula} from '../../transform';\nimport {extend, vals, hash, Dict} from '../../util';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {RepeatModel} from './../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model} from './../model';\n\nimport {DataComponent} from './data';\n\n\nexport namespace formula {\n  function parse(model: Model): Dict<Formula> {\n    return (model.transform().calculate || []).reduce(function(formulaComponent, formula) {\n      formulaComponent[hash(formula)] = formula;\n      return formulaComponent;\n    }, {} as Dict<Formula>);\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let formulaComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(formulaComponent, childDataComponent.calculate);\n      delete childDataComponent.calculate;\n    }\n    return formulaComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let formulaComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source) {\n        extend(formulaComponent, childDataComponent.calculate);\n        delete childDataComponent.calculate;\n      }\n    });\n    return formulaComponent;\n  }\n\n  export function parseRepeat(model: RepeatModel) {\n    let formulaComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source) {\n        extend(formulaComponent, childDataComponent.calculate);\n        delete childDataComponent.calculate;\n      }\n    });\n    return formulaComponent;\n  }\n\n  export function parseConcat(model: ConcatModel) {\n    let formulaComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source) {\n        extend(formulaComponent, childDataComponent.calculate);\n        delete childDataComponent.calculate;\n      }\n    });\n    return formulaComponent;\n  }\n\n  export function assemble(component: DataComponent) {\n    return vals(component.calculate).reduce(function(transform, formula) {\n      transform.push(extend({ type: 'formula' }, formula));\n      return transform;\n    }, []);\n  }\n}\n",
    "import {extend, vals, flatten, hash, Dict} from '../../util';\nimport {Lookup} from '../../transform';\n\nimport {FacetModel} from './../facet';\nimport {LayerModel} from './../layer';\nimport {ConcatModel} from './../concat';\nimport {Model} from './../model';\n\nimport {DataComponent} from './data';\n\nexport namespace lookup {\n  function parse(model: Model): Dict<Lookup> {\n    return model.transform().lookup || {};\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let lookupComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(lookupComponent, childDataComponent.lookup);\n      delete childDataComponent.lookup;\n    }\n    return lookupComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let lookupComponent = parse(model);\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(lookupComponent, childDataComponent.lookup);\n        delete childDataComponent.lookup;\n      }\n    });\n\n    return lookupComponent;\n  }\n\n  export function parseConcat(model: ConcatModel) {\n    let lookupComponent = parse(model);\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n\n      // If child doesn't have its own data source, then merge\n      if (!childDataComponent.source) {\n        extend(lookupComponent, childDataComponent.lookup);\n        delete childDataComponent.lookup;\n      }\n    });\n\n    return lookupComponent;\n  }\n\n  // export function assemble(component: DataComponent) {\n  //   return flatten(vals(component.lookup));\n  // }\n}\n",
    "import {ScaleType} from '../../scale';\nimport {extend, keys, differ, Dict} from '../../util';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from '../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model} from '../model';\n\nimport {DataComponent} from './data';\n\n/**\n * Filter non-positive value for log scale\n */\nexport namespace nonPositiveFilter {\n  export function parseUnit(model: Model): Dict<boolean> {\n    return model.channels().reduce(function(nonPositiveComponent, channel) {\n      const field = model.fieldOrig(channel);\n      const scale = model.scale(channel);\n      if (model.field(channel) && scale) {\n        nonPositiveComponent[field] = scale.type === ScaleType.LOG;\n      }\n      return nonPositiveComponent;\n    }, {} as Dict<boolean>);\n  }\n\n  export function parseFacet(model: FacetModel) {\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then consider merging\n    if (!childDataComponent.source) {\n      // For now, let's assume it always has union scale\n      const nonPositiveFilterComponent = childDataComponent.nonPositiveFilter;\n      delete childDataComponent.nonPositiveFilter;\n      return nonPositiveFilterComponent;\n    }\n    return {} as Dict<boolean>;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // note that we run this before source.parseLayer\n    let nonPositiveFilter = {} as Dict<boolean>;\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ(childDataComponent.nonPositiveFilter, nonPositiveFilter)) {\n        extend(nonPositiveFilter, childDataComponent.nonPositiveFilter);\n        delete childDataComponent.nonPositiveFilter;\n      }\n    });\n\n    return nonPositiveFilter;\n  }\n\n  export function parseRepeat(model: RepeatModel): Dict<boolean> {\n    // note that we run this before source.parseLayer\n    let nonPositiveFilter = {} as Dict<boolean>;\n\n    const children = model.children();\n    for (let i = 0; i < children.length; i++) {\n      const childDataComponent = children[i].component.data;\n      if (!differ(childDataComponent.nonPositiveFilter, nonPositiveFilter)) {\n        extend(nonPositiveFilter, childDataComponent.nonPositiveFilter);\n      } else {\n        // children are incompatible\n        return {};\n      }\n    }\n\n    // children are compatible so let's delete their null filters\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      delete childDataComponent.nonPositiveFilter;\n    });\n\n    return nonPositiveFilter;\n  }\n\n  export function parseConcat(model: ConcatModel): Dict<boolean> {\n    // note that we run this before source.parseLayer\n    let nonPositiveFilter = {} as Dict<boolean>;\n\n    const children = model.children();\n    for (let i = 0; i < children.length; i++) {\n      const childDataComponent = children[i].component.data;\n      if (!differ(childDataComponent.nonPositiveFilter, nonPositiveFilter)) {\n        extend(nonPositiveFilter, childDataComponent.nonPositiveFilter);\n      } else {\n        // children are incompatible\n        return {};\n      }\n    }\n\n    // children are compatible so let's delete their null filters\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      delete childDataComponent.nonPositiveFilter;\n    });\n\n    return nonPositiveFilter;\n  }\n\n  export function assemble(component: DataComponent) {\n    return keys(component.nonPositiveFilter).filter((field) => {\n      // Only filter fields (keys) with value = true\n      return component.nonPositiveFilter[field];\n    }).map(function(field) {\n      return {\n        type: 'filter',\n        test: 'datum.' + field + ' > 0'\n      };\n    });\n  }\n}\n",
    "import {extend, keys, differ, Dict} from '../../util';\nimport {FieldDef} from '../../fielddef';\nimport {Channel} from '../../channel';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from '../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model} from '../model';\n\nimport {DataComponent} from './data';\n\nconst DEFAULT_NULL_FILTERS = {\n  nominal: false,\n  ordinal: false,\n  quantitative: true,\n  temporal: true\n};\n\nexport namespace nullFilter {\n  /** Return Hashset of fields for null filtering (key=field, value = true). */\n  function parse(model: Model): Dict<boolean> {\n    const filterNull = model.transform().filterNull;\n    return model.reduce(function(aggregator, fieldDef: FieldDef, channel: Channel) {\n      const field = model.fieldOrig(channel);\n      if (!field) return aggregator;\n      if (filterNull ||\n        (filterNull === undefined && field !== '*' && DEFAULT_NULL_FILTERS[fieldDef.type])) {\n        aggregator[field] = true;\n      } else {\n        // define this so we know that we don't filter nulls for this field\n        // this makes it easier to merge into parents\n        aggregator[field] = false;\n      }\n      return aggregator;\n    }, {});\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let nullFilterComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(nullFilterComponent, childDataComponent.nullFilter);\n      delete childDataComponent.nullFilter;\n    }\n    return nullFilterComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // note that we run this before source.parseLayer\n\n    // FIXME: null filters are not properly propagated right now\n    let nullFilterComponent = parse(model);\n\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (model.compatibleSource(child) && !differ(childDataComponent.nullFilter, nullFilterComponent)) {\n        extend(nullFilterComponent, childDataComponent.nullFilter);\n        delete childDataComponent.nullFilter;\n      }\n    });\n\n    return nullFilterComponent;\n  }\n\n  export function parseRepeat(model: RepeatModel): Dict<boolean> {\n    // note that we run this before source.parseLayer\n\n    let nullFilterComponent = {} as Dict<boolean>;\n\n    const children = model.children();\n    for (let i = 0; i < children.length; i++) {\n      const childDataComponent = children[i].component.data;\n      if (!differ(childDataComponent.nullFilter, nullFilterComponent)) {\n        extend(nullFilterComponent, childDataComponent.nullFilter);\n      } else {\n        // children are incompatible\n        return {};\n      }\n    }\n\n    // children are compatible so let's delete their null filters\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      delete childDataComponent.nullFilter;\n    });\n\n    return nullFilterComponent;\n  }\n\n  export function parseConcat(model: ConcatModel): Dict<boolean> {\n    let nullFilterComponent = {} as Dict<boolean>;\n\n    const children = model.children();\n    for (let i = 0; i < children.length; i++) {\n      const childDataComponent = children[i].component.data;\n      if (!differ(childDataComponent.nullFilter, nullFilterComponent)) {\n        extend(nullFilterComponent, childDataComponent.nullFilter);\n      } else {\n        // children are incompatible\n        return {};\n      }\n    }\n\n    // children are compatible so let's delete their null filters\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      delete childDataComponent.nullFilter;\n    });\n\n    return nullFilterComponent;\n  }\n\n  /** Convert the hashset of fields to a filter transform.  */\n  export function assemble(component: DataComponent) {\n    const filteredFields = keys(component.nullFilter).filter((field) => {\n      // only include fields that has value = true\n      return component.nullFilter[field];\n    });\n    return filteredFields.length > 0 ?\n      [{\n        type: 'filter',\n        test: filteredFields.map(function(fieldName) {\n          return 'datum.' + fieldName + '!==null';\n        }).join(' && ')\n      }] : [];\n  }\n}",
    "import {SOURCE} from '../../data';\nimport {contains, duplicate, keys, extend} from '../../util';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from './../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model, isUnitModel} from '../model';\n\nimport {DataComponent} from './data';\nimport {nullFilter} from './nullfilter';\nimport {filter} from './filter';\nimport {filterWith} from './filterwith';\nimport {bin} from './bin';\nimport {formula} from './formula';\nimport {timeUnit} from './timeunit';\nimport {compileSelectionPredicate} from '../common';\n\nexport namespace source {\n  function parse(model: Model): VgData {\n    let data = model.data();\n\n    if (data) {\n      // If data is explicitly provided\n\n      let sourceData: VgData = { name: model.dataName(SOURCE) };\n      if (data.values && data.values.length > 0) {\n        sourceData.values = model.data().values;\n        sourceData.format = { type: 'json' };\n      } else if (data.url) {\n        sourceData.url = data.url;\n\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        let defaultExtension = /(?:\\.([^.]+))?$/.exec(sourceData.url)[1];\n        if (!contains(['json', 'csv', 'tsv'], defaultExtension)) {\n          defaultExtension = 'json';\n        }\n        sourceData.format = { type: model.data().formatType || defaultExtension };\n      }\n      return sourceData;\n    } else if (!model.parent()) {\n      // If data is not explicitly provided but the model is a root,\n      // need to produce a source as well\n      return { name: model.dataName(SOURCE) };\n    }\n    return undefined;\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let sourceData = parse(model);\n    if (!model.child().component.data.source) {\n      // If the child does not have its own source, have to rename its source.\n      model.child().renameData(model.child().dataName(SOURCE), model.dataName(SOURCE));\n    }\n\n    return sourceData;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let sourceData = parse(model);\n    model.children().forEach((child) => {\n      const childData = child.component.data;\n\n      if (model.compatibleSource(child)) {\n        // we cannot merge if the child has filters defined even after we tried to move them up\n        const canMerge = !childData.filter && !childData.formatParse && !childData.nullFilter && !childData.filterWith;\n        if (canMerge) {\n          // rename source because we can just remove it\n          child.renameData(child.dataName(SOURCE), model.dataName(SOURCE));\n          delete childData.source;\n        } else {\n          // child does not have data defined or the same source so just use the parents source\n          childData.source = {\n            name: child.dataName(SOURCE),\n            source: model.dataName(SOURCE)\n          };\n        }\n      }\n    });\n    return sourceData;\n  }\n\n  export function parseRepeat(model: RepeatModel) {\n    let sourceData = parse(model.children()[0]);\n    if (!sourceData) {\n      // cannot merge from child because the direct child does not have any data\n      // For example, when the child is a layer spec.\n      return;\n    }\n    sourceData.name = model.dataName(SOURCE);\n\n    model.children().forEach((child) => {\n      const childData = child.component.data;\n\n      // TODO: merge children into different groups that are mergable.  (Current we only merge into one.)\n\n      const canMerge = !childData.filter && !childData.formatParse && !childData.nullFilter && !childData.filterWith;\n      if (canMerge) {\n        // rename source because we can just remove it\n        child.renameData(child.dataName(SOURCE), model.dataName(SOURCE));\n        delete childData.source;\n      } else {\n        // child does not have data defined or the same source so just use the parents source\n        childData.source = {\n          name: child.dataName(SOURCE),\n          source: model.dataName(SOURCE)\n        };\n      }\n    });\n    return sourceData;\n  }\n\n  export function parseConcat(model: ConcatModel) {\n    let sourceData = parse(model.children()[0]);\n    if (!sourceData) {\n      // cannot merge from child because the direct child does not have any data\n      // For example, when the child is a layer spec.\n      return;\n    }\n    sourceData.name = model.dataName(SOURCE);\n\n    model.children().forEach((child) => {\n      const childData = child.component.data;\n\n      // TODO: merge children into different groups that are mergable.  (Current we only merge into one.)\n\n      const canMerge = !childData.filter && !childData.formatParse && !childData.nullFilter && !childData.filterWith;\n      if (canMerge) {\n        // rename source because we can just remove it\n        child.renameData(child.dataName(SOURCE), model.dataName(SOURCE));\n        delete childData.source;\n      } else {\n        // child does not have data defined or the same source so just use the parents source\n        childData.source = {\n          name: child.dataName(SOURCE),\n          source: model.dataName(SOURCE)\n        };\n      }\n    });\n    return sourceData;\n  }\n\n  var PRELOOKUP = '_preLookup', LOOKUP = '_lookup_', POSTLOOKUP = '_postLookup';\n  export function assemble(model: Model, component: DataComponent) {\n    if (component.source) {\n      let sourceData: VgData = component.source,\n          name = sourceData.name,\n          lookupDef = component.lookup,\n          lookupData = [], transforms = [];\n\n      if (component.formatParse) {\n        component.source.format = component.source.format || {};\n        component.source.format.parse = component.formatParse;\n      }\n\n      // null filter comes first so transforms are not performed on null values\n      // time and bin should come before filter so we can filter by time and bin\n      sourceData.transform = [].concat(\n        // had to move formula before null filter because we cannot null filter something that does not exist\n        formula.assemble(component),\n        nullFilter.assemble(component),\n        bin.assemble(component),\n        filter.assemble(component),\n        timeUnit.assemble(component),\n        filterWith.assemble(component)\n      );\n\n      // HACK FOR INFOVIS\n      if (component.lookup && isUnitModel(model)) {\n        sourceData.name = name + PRELOOKUP;\n        transforms = sourceData.transform.splice(0);\n        lookupData.push(sourceData);\n\n        keys(lookupDef).forEach(function(k) {\n          lookupData.push({\n            name: name + LOOKUP + k,\n            source: name + PRELOOKUP,\n            transform: [{\n              type: 'filter',\n              test: compileSelectionPredicate(model, lookupDef[k].selection)\n            }]\n          })\n        });\n\n        sourceData = duplicate(sourceData);\n        sourceData.name = name;\n        sourceData.source = name + PRELOOKUP;\n        sourceData.transform = keys(lookupDef).map(function(k) {\n          var keys = lookupDef[k].keys;\n          return {\n            type: 'lookup',\n            on: name + LOOKUP + k,\n            onKey: keys, keys: keys,\n            as: [k], default: {}\n          }\n        }).concat(transforms);\n\n        lookupData.push(sourceData);\n\n        return lookupData;\n      } else {\n        return [sourceData];\n      }\n    }\n    return null;\n  }\n}\n",
    "import {STACKED_SCALE, SUMMARY} from '../../data';\nimport {field} from '../../fielddef';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from './../repeat';\nimport {ConcatModel} from './../concat';\nimport {UnitModel} from '../unit';\n\nimport {DataComponent} from './data';\n\n\n/**\n * Stacked scale data source, for feeding the shared scale.\n */\nexport namespace stackScale {\n  export function parseUnit(model: UnitModel): VgData {\n    const stackProps = model.stack();\n\n    if (stackProps) {\n      // produce stacked scale\n      const groupbyChannel = stackProps.groupbyChannel;\n      const fieldChannel = stackProps.fieldChannel;\n      return {\n        name: model.dataName(STACKED_SCALE),\n        source: model.dataName(SUMMARY), // always summary because stacked only works with aggregation\n        transform: [{\n          type: 'aggregate',\n          // group by channel and other facets\n          groupby: [model.field(groupbyChannel)],\n          // produce sum of the field's value e.g., sum of sum, sum of distinct\n          summarize: [{ ops: ['sum'], field: model.field(fieldChannel) }]\n        }]\n      };\n    }\n    return null;\n  };\n\n  export function parseFacet(model: FacetModel) {\n    const child = model.child();\n    const childDataComponent = child.component.data;\n\n    // If child doesn't have its own data source, but has stack scale source, then merge\n    if (!childDataComponent.source && childDataComponent.stackScale) {\n      let stackComponent = childDataComponent.stackScale;\n\n      const newName = model.dataName(STACKED_SCALE);\n      child.renameData(stackComponent.name, newName);\n      stackComponent.name = newName;\n\n      // Refer to facet's summary instead (always summary because stacked only works with aggregation)\n      stackComponent.source = model.dataName(SUMMARY);\n\n      // Add more dimensions for row/column\n      stackComponent.transform[0].groupby = model.reduce(function(groupby, fieldDef) {\n        groupby.push(field(fieldDef));\n        return groupby;\n      }, stackComponent.transform[0].groupby);\n\n      delete childDataComponent.stackScale;\n      return stackComponent;\n    }\n    return null;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // TODO\n    return null;\n  }\n  \n  export function parseRepeat(model: RepeatModel) {\n    // TODO\n    return null;\n  }\n  \n  export function parseConcat(model: ConcatModel) {\n    // TODO\n    return null;\n  }\n\n  export function assemble(component: DataComponent) {\n    return component.stackScale;\n  }\n}\n",
    "import {AggregateOp} from '../../aggregate';\nimport {Channel} from '../../channel';\nimport {SOURCE, SUMMARY} from '../../data';\nimport {field, FieldDef} from '../../fielddef';\nimport {keys, vals, reduce, hash, Dict, StringSet} from '../../util';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from './../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model} from '../model';\n\nimport {DataComponent, SummaryComponent} from './data';\n\n\nexport namespace summary {\n  function addDimension(dims: { [field: string]: boolean }, fieldDef: FieldDef, channel: Channel) {\n    if (fieldDef.bin) {\n      dims[field(fieldDef, { binSuffix: '_start' })] = true;\n      dims[field(fieldDef, { binSuffix: '_mid' })] = true;\n      dims[field(fieldDef, { binSuffix: '_end' })] = true;\n\n      // TODO: don't add this if we don't use range\n      dims[field(fieldDef, { binSuffix: '_range' })] = true;\n    } else {\n      dims[field(fieldDef)] = true;\n    }\n    return dims;\n  }\n\n  export function parseUnit(model: Model): SummaryComponent[] {\n    /* string set for dimensions */\n    let dims: StringSet = {};\n\n    /* dictionary mapping field name => dict set of aggregation functions */\n    let meas: Dict<StringSet> = {};\n\n    model.forEach(function(fieldDef: FieldDef, channel: Channel) {\n      if (fieldDef.aggregate) {\n        if (fieldDef.aggregate === AggregateOp.COUNT) {\n          meas['*'] = meas['*'] || {};\n          /* tslint:disable:no-string-literal */\n          meas['*']['count'] = true;\n          /* tslint:enable:no-string-literal */\n        } else {\n          const field = model.fieldOrig(channel);\n          meas[field] = meas[field] || {};\n          meas[field][fieldDef.aggregate] = true;\n        }\n      } else {\n        addDimension(dims, fieldDef, channel);\n      }\n    });\n\n    return [{\n      name: model.dataName(SUMMARY),\n      dimensions: dims,\n      measures: meas\n    }];\n  }\n\n  export function parseFacet(model: FacetModel): SummaryComponent[] {\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source but has a summary data source, merge\n    if (!childDataComponent.source && childDataComponent.summary) {\n      let summaryComponents = childDataComponent.summary.map(function(summaryComponent) {\n        // add facet fields as dimensions\n        summaryComponent.dimensions = model.reduce(addDimension, summaryComponent.dimensions);\n\n        const summaryNameWithoutPrefix = summaryComponent.name.substr(model.child().name('').length);\n        model.child().renameData(summaryComponent.name, summaryNameWithoutPrefix);\n        summaryComponent.name = summaryNameWithoutPrefix;\n        return summaryComponent;\n      });\n\n      delete childDataComponent.summary;\n      return summaryComponents;\n    }\n    return [];\n  }\n\n  export function parseLayer(model: LayerModel): SummaryComponent[] {\n    // Index by the fields we are grouping by\n    let summaries = {} as Dict<SummaryComponent>;\n\n    // Combine summaries for children that don't have a distinct source\n    // (either having its own data source, or its own tranformation of the same data source).\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source && childDataComponent.summary) {\n        // Merge the summaries if we can\n        childDataComponent.summary.forEach((childSummary) => {\n          // The key is a hash based on the dimensions;\n          // we use it to find out whether we have a summary that uses the same group by fields.\n          const key = hash(childSummary.dimensions);\n          if (key in summaries) {\n            // yes, there is a summary hat we need to merge into\n            // we know that the dimensions are the same so we only need to merge the measures\n            mergeMeasures(summaries[key].measures, childSummary.measures);\n          } else {\n            // give the summary a new name\n            childSummary.name = model.dataName(SUMMARY) + '_' + keys(summaries).length;\n            summaries[key] = childSummary;\n          }\n\n          // remove summary from child\n          child.renameData(child.dataName(SUMMARY), summaries[key].name);\n          delete childDataComponent.summary;\n        });\n      }\n    });\n\n    return vals(summaries);\n  }\n\n  export function parseRepeat(model: RepeatModel): SummaryComponent[] {\n    // Index by the fields we are grouping by\n    let summaries = {} as Dict<SummaryComponent>;\n\n    // Combine summaries for children that don't have a distinct source\n    // (either having its own data source, or its own tranformation of the same data source).\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source && childDataComponent.summary) {\n        // Merge the summaries if we can\n        childDataComponent.summary.forEach((childSummary) => {\n          // The key is a hash based on the dimensions;\n          // we use it to find out whether we have a summary that uses the same group by fields.\n          const key = hash(childSummary.dimensions);\n          if (key in summaries) {\n            // yes, there is a summary hat we need to merge into\n            // we know that the dimensions are the same so we only need to merge the measures\n            mergeMeasures(summaries[key].measures, childSummary.measures);\n          } else {\n            // give the summary a new name\n            childSummary.name = model.dataName(SUMMARY) + '_' + keys(summaries).length;\n            summaries[key] = childSummary;\n          }\n\n          // remove summary from child\n          child.renameData(child.dataName(SUMMARY), summaries[key].name);\n          delete childDataComponent.summary;\n        });\n      }\n    });\n\n    return vals(summaries);\n  }\n\n  export function parseConcat(model: ConcatModel): SummaryComponent[] {\n    // Index by the fields we are grouping by\n    let summaries = {} as Dict<SummaryComponent>;\n\n    // Combine summaries for children that don't have a distinct source\n    // (either having its own data source, or its own tranformation of the same data source).\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source && childDataComponent.summary) {\n        // Merge the summaries if we can\n        childDataComponent.summary.forEach((childSummary) => {\n          // The key is a hash based on the dimensions;\n          // we use it to find out whether we have a summary that uses the same group by fields.\n          const key = hash(childSummary.dimensions);\n          if (key in summaries) {\n            // yes, there is a summary hat we need to merge into\n            // we know that the dimensions are the same so we only need to merge the measures\n            mergeMeasures(summaries[key].measures, childSummary.measures);\n          } else {\n            // give the summary a new name\n            childSummary.name = model.dataName(SUMMARY) + '_' + keys(summaries).length;\n            summaries[key] = childSummary;\n          }\n\n          // remove summary from child\n          child.renameData(child.dataName(SUMMARY), summaries[key].name);\n          delete childDataComponent.summary;\n        });\n      }\n    });\n\n    return vals(summaries);\n  }\n\n  function mergeMeasures(parentMeasures: Dict<Dict<boolean>>, childMeasures: Dict<Dict<boolean>>) {\n    for (const field in childMeasures) {\n      if (childMeasures.hasOwnProperty(field)) {\n        // when we merge a measure, we either have to add an aggregation operator or even a new field\n        const ops = childMeasures[field];\n        for (const op in ops) {\n          if (ops.hasOwnProperty(op)) {\n            if (!(field in parentMeasures)) {\n              parentMeasures[field] = {};\n            }\n            parentMeasures[field][op] = true;\n          }\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Assemble the summary. Needs a rename function because we cannot guarantee that the\n   * parent data before the children data.\n   */\n  export function assemble(component: DataComponent, model: Model): VgData[] {\n    if (!component.summary) {\n      return [];\n    }\n    return component.summary.reduce(function(summaryData, summaryComponent) {\n      const dims = summaryComponent.dimensions;\n      const meas = summaryComponent.measures;\n\n      const groupby = keys(dims);\n\n      // short-format summarize object for Vega's aggregate transform\n      // https://github.com/vega/vega/wiki/Data-Transforms#-aggregate\n      const summarize = reduce(meas, function(aggregator, fnDictSet, field) {\n        aggregator[field] = keys(fnDictSet);\n        return aggregator;\n      }, {});\n\n      if (keys(meas).length > 0) { // has aggregate\n        summaryData.push({\n          name: summaryComponent.name,\n          source: model.dataName(SOURCE),\n          transform: [{\n            type: 'aggregate',\n            groupby: groupby,\n            summarize: summarize\n          }]\n        });\n      }\n      return summaryData;\n    }, []);\n  }\n}\n",
    "import {Channel} from '../../channel';\nimport {field, FieldDef} from '../../fielddef';\nimport {TEMPORAL} from '../../type';\nimport {extend, vals, Dict} from '../../util';\nimport {VgTransform} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from './../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model} from '../model';\nimport {parseExpression} from '../time';\n\nimport {DataComponent} from './data';\n\n\nexport namespace timeUnit {\n  function parse(model: Model): Dict<VgTransform> {\n    return model.reduce(function(timeUnitComponent, fieldDef: FieldDef, channel: Channel) {\n      const ref = field(fieldDef, { nofn: true, datum: true });\n      if (fieldDef.type === TEMPORAL && fieldDef.timeUnit) {\n\n        const hash = field(fieldDef);\n\n        timeUnitComponent[hash] = {\n          type: 'formula',\n          field: field(fieldDef),\n          expr: parseExpression(fieldDef.timeUnit, ref)\n        };\n      }\n      return timeUnitComponent;\n    }, {});\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    let timeUnitComponent = parse(model);\n\n    const childDataComponent = model.child().component.data;\n\n    // If child doesn't have its own data source, then merge\n    if (!childDataComponent.source) {\n      extend(timeUnitComponent, childDataComponent.timeUnit);\n      delete childDataComponent.timeUnit;\n    }\n    return timeUnitComponent;\n  }\n\n  export function parseLayer(model: LayerModel) {\n    let timeUnitComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source) {\n        extend(timeUnitComponent, childDataComponent.timeUnit);\n        delete childDataComponent.timeUnit;\n      }\n    });\n    return timeUnitComponent;\n  }\n\n  export function parseRepeat(model: RepeatModel) {\n    let timeUnitComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source) {\n        extend(timeUnitComponent, childDataComponent.timeUnit);\n        delete childDataComponent.timeUnit;\n      }\n    });\n    return timeUnitComponent;\n  }\n\n  export function parseConcat(model: ConcatModel) {\n    let timeUnitComponent = parse(model);\n    model.children().forEach((child) => {\n      const childDataComponent = child.component.data;\n      if (!childDataComponent.source) {\n        extend(timeUnitComponent, childDataComponent.timeUnit);\n        delete childDataComponent.timeUnit;\n      }\n    });\n    return timeUnitComponent;\n  }\n\n  export function assemble(component: DataComponent) {\n    // just join the values, which are already transforms\n    return vals(component.timeUnit);\n  }\n}",
    "import {Channel} from '../../channel';\nimport {FieldDef} from '../../fielddef';\nimport {TimeUnit} from '../../timeunit';\nimport {extend, keys, StringSet} from '../../util';\nimport {VgData} from '../../vega.schema';\n\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {RepeatModel} from './../repeat';\nimport {ConcatModel} from './../concat';\nimport {Model} from '../model';\nimport {parseExpression, rawDomain} from '../time';\n\nimport {DataComponent} from './data';\n\n\nexport namespace timeUnitDomain {\n  function parse(model: Model): StringSet {\n    return model.reduce(function(timeUnitDomainMap, fieldDef: FieldDef, channel: Channel) {\n      const timeUnit = fieldDef.timeUnit;\n      if (timeUnit) {\n        const domain = rawDomain(timeUnit, channel);\n        if (domain) {\n          timeUnitDomainMap[timeUnit] = true;\n        }\n      }\n      return timeUnitDomainMap;\n    }, {});\n  }\n\n  export const parseUnit = parse;\n\n  export function parseFacet(model: FacetModel) {\n    // always merge with child\n    return extend(parse(model), model.child().component.data.timeUnitDomain);\n  }\n\n  export function parseLayer(model: LayerModel) {\n    // always merge with children\n    return extend(parse(model), model.children().forEach((child) => {\n      return child.component.data.timeUnitDomain;\n    }));\n  }\n\n  export function parseRepeat(model: RepeatModel) {\n    // always merge with children\n    return extend(parse(model), model.children().forEach((child) => {\n      return child.component.data.timeUnitDomain;\n    }));\n  }\n\n  export function parseConcat(model: ConcatModel) {\n    // always merge with children\n    return extend(parse(model), model.children().forEach((child) => {\n      return child.component.data.timeUnitDomain;\n    }));\n  }\n\n  export function assemble(component: DataComponent): VgData[] {\n    return keys(component.timeUnitDomain).reduce(function(timeUnitData, tu: any) {\n      const timeUnit: TimeUnit = tu; // cast string back to enum\n      const domain = rawDomain(timeUnit, null); // FIXME fix rawDomain signature\n      if (domain) {\n        timeUnitData.push({\n          name: timeUnit,\n          values: domain,\n          transform: [{\n            type: 'formula',\n            field: 'date',\n            expr: parseExpression(timeUnit, 'datum.data', true)\n          }]\n        });\n      }\n      return timeUnitData;\n    }, []);\n  }\n}",
    "import {AxisOrient, AxisProperties} from '../axis';\nimport {COLUMN, ROW, X, Y, Channel} from '../channel';\nimport {defaultConfig, Config} from '../config';\nimport {SOURCE, SUMMARY} from '../data';\nimport {Facet} from '../facet';\nimport {channelMappingForEach} from '../encoding';\nimport {FieldDef, isDimension} from '../fielddef';\nimport {Scale, ScaleType} from '../scale';\nimport {FacetSpec} from '../spec';\nimport {getFullName} from '../type';\nimport {extend, keys, vals, flatten, duplicate, mergeDeep, Dict} from '../util';\nimport {VgData, VgMarkGroup} from '../vega.schema';\n\nimport {parseAxis, parseInnerAxis, gridShow, parseAxisComponent} from './axis';\nimport {buildModel} from './common';\nimport {assembleData, parseFacetData} from './data/data';\nimport {assembleLayout, parseFacetLayout} from './layout';\nimport {Model} from './model';\nimport {parseScaleComponent} from './scale';\nimport {RepeatValues} from './repeat';\n\nexport class FacetModel extends Model {\n  private _facet: Facet;\n\n  constructor(spec: FacetSpec, parent: Model, parentGivenName: string, repeatValues: RepeatValues) {\n    super(spec, parent, parentGivenName, repeatValues);\n\n    // Config must be initialized before child as it gets cascaded to the child\n    const config = this._config = this._initConfig(spec.config, parent);\n\n    const child  = this._child = buildModel(spec.spec, this, this.name('child'), repeatValues);\n\n    const facet  = this._facet = this._initFacet(spec.facet);\n    this._scale  = this._initScale(facet, config, child);\n    this._axis   = this._initAxis(facet, config, child);\n  }\n\n  private _initConfig(specConfig: Config, parent: Model) {\n    return mergeDeep(duplicate(defaultConfig), specConfig, parent ? parent.config() : {});\n  }\n\n  private _initFacet(facet: Facet) {\n    // clone to prevent side effect to the original spec\n    facet = duplicate(facet);\n\n    const model = this;\n\n    channelMappingForEach(this.channels(), facet, function(fieldDef: FieldDef, channel: Channel) {\n      // TODO: if has no field / datum, then drop the field\n\n      if (!isDimension(fieldDef)) {\n        model.addWarning(channel + ' encoding should be ordinal.');\n      }\n\n      if (fieldDef.type) {\n        // convert short type to full type\n        fieldDef.type = getFullName(fieldDef.type);\n      }\n    });\n    return facet;\n  }\n\n  private _initScale(facet: Facet, config: Config, child: Model): Dict<Scale> {\n    return [ROW, COLUMN].reduce(function(_scale, channel) {\n      if (facet[channel]) {\n\n        const scaleSpec = facet[channel].scale || {};\n        _scale[channel] = extend({\n          type: ScaleType.ORDINAL,\n          round: config.facet.scale.round,\n\n          // TODO: revise this rule for multiple level of nesting\n          padding: (channel === ROW && child.has(Y)) || (channel === COLUMN && child.has(X)) ?\n                   config.facet.scale.padding : 0\n        }, scaleSpec);\n      }\n      return _scale;\n    }, {} as Dict<Scale>);\n  }\n\n  private _initAxis(facet: Facet, config: Config, child: Model): Dict<AxisProperties> {\n    return [ROW, COLUMN].reduce(function(_axis, channel) {\n      if (facet[channel]) {\n        const axisSpec = facet[channel].axis;\n        if (axisSpec !== false) {\n          const modelAxis = _axis[channel] = extend({},\n            config.facet.axis,\n            axisSpec === true ? {} : axisSpec || {}\n          );\n\n          if (channel === ROW) {\n            const yAxis: any = child.axis(Y);\n            if (yAxis && yAxis.orient !== AxisOrient.RIGHT && !modelAxis.orient) {\n              modelAxis.orient = AxisOrient.RIGHT;\n            }\n            if( child.has(X) && !modelAxis.labelAngle) {\n              modelAxis.labelAngle = modelAxis.orient === AxisOrient.RIGHT ? 90 : 270;\n            }\n          }\n        }\n      }\n      return _axis;\n    }, {} as Dict<AxisProperties>);\n  }\n\n  public facet() {\n    return this._facet;\n  }\n\n  public has(channel: Channel): boolean {\n    return !!this._facet[channel];\n  }\n\n  public child() {\n    return this._child;\n  }\n\n  private hasSummary() {\n    const summary = this.component.data.summary;\n    for (let i = 0 ; i < summary.length ; i++) {\n      if (keys(summary[i].measures).length > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public dataTable(): string {\n    return (this.hasSummary() ? SUMMARY : SOURCE) + '';\n  }\n\n  public isRepeatRef(channel: Channel) {\n    // todo\n    return false;\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    return this.facet()[channel];\n  }\n\n  public stack() {\n    return null; // this is only a property for UnitModel\n  }\n\n  public parseData() {\n    this.child().parseData();\n    this.component.data = parseFacetData(this);\n  }\n\n  public parseLayoutData() {\n    this.child().parseLayoutData();\n    this.component.layout = parseFacetLayout(this);\n  }\n\n  public parseScale() {\n    const child = this.child();\n    const model = this;\n\n    child.parseScale();\n\n    // TODO: support scales for field reference of parent data (e.g., for SPLOM)\n\n    // First, add scale for row and column.\n    let scaleComponent = this.component.scale = parseScaleComponent(this);\n\n    // Then, move shared/union from its child spec.\n    keys(child.component.scale).forEach(function(channel) {\n      // TODO: correctly implement independent scale\n      if (true) { // if shared/union scale\n        scaleComponent[channel] = child.component.scale[channel];\n\n        // for each scale, need to rename\n        const modelScales = scaleComponent[channel];\n        [modelScales.main, modelScales.colorLegend, modelScales.binColorLegend].forEach(function(scale) {\n          if (!scale) {\n            return;\n          }\n          const scaleNameWithoutPrefix = scale.name.substr(child.name('').length);\n          const newName = model.scaleName(scaleNameWithoutPrefix);\n          child.renameScale(scale.name, newName);\n          scale.name = newName;\n        });\n\n        // Once put in parent, just remove the child's scale.\n        delete child.component.scale[channel];\n      }\n    });\n  }\n\n  public parseMark() {\n    this.child().parseMark();\n\n    this.component.mark = extend(\n      {\n        name: this.name('cell'),\n        type: 'group',\n        from: extend(\n          this.dataTable() ? {data: this.dataTable()} : {},\n          {\n            transform: [{\n              type: 'facet',\n              groupby: [].concat(\n                this.has(ROW) ? [this.field(ROW)] : [],\n                this.has(COLUMN) ? [this.field(COLUMN)] : []\n              )\n            }]\n          }\n        ),\n        properties: {\n          update: getFacetGroupProperties(this)\n        }\n      },\n      // Call child's assembleGroup to add marks, scales, axes, and legends.\n      // Note that we can call child's assembleGroup() here because parseMark()\n      // is the last method in compile() and thus the child is completely compiled\n      // at this point.\n      this.child().assembleGroup()\n    );\n  }\n\n  public parseAxis() {\n    this.child().parseAxis();\n    this.component.axis = parseAxisComponent(this, [ROW, COLUMN]);\n  }\n\n  public parseAxisGroup() {\n    // TODO: with nesting, we might need to consider calling child\n    // this.child().parseAxisGroup();\n\n    const xAxisGroup = parseAxisGroup(this, X);\n    const yAxisGroup = parseAxisGroup(this, Y);\n\n    this.component.axisGroup = extend(\n      xAxisGroup ? {x: xAxisGroup} : {},\n      yAxisGroup ? {y: yAxisGroup} : {}\n    );\n  }\n\n  public parseGridGroup() {\n    // TODO: with nesting, we might need to consider calling child\n    // this.child().parseGridGroup();\n\n    const child = this.child();\n\n    this.component.gridGroup = extend(\n      !child.has(X) && this.has(COLUMN) ? { column: getColumnGridGroups(this) } : {},\n      !child.has(Y) && this.has(ROW) ? { row: getRowGridGroups(this) } : {}\n    );\n  }\n\n  public parseLegend() {\n    this.child().parseLegend();\n\n    // TODO: support legend for independent non-position scale across facets\n    // TODO: support legend for field reference of parent data (e.g., for SPLOM)\n\n    // For now, assuming that non-positional scales are always shared across facets\n    // Thus, just move all legends from its child\n    this.component.legend = this._child.component.legend;\n    this._child.component.legend = {};\n  }\n\n  public assembleParentGroupProperties() {\n    return null;\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    // Prefix traversal – parent data might be referred by children data\n    assembleData(this, data);\n    return this._child.assembleData(data);\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    // Postfix traversal – layout is assembled bottom-up\n    this._child.assembleLayout(layoutData);\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks(): any[] {\n    return [].concat(\n      // axisGroup is a mapping to VgMarkGroup\n      vals(this.component.axisGroup),\n      flatten(vals(this.component.gridGroup)),\n      this.component.mark\n    );\n  }\n\n  public channels() {\n    return [ROW, COLUMN];\n  }\n\n  protected mapping() {\n    return this.facet();\n  }\n\n  public isFacet() {\n    return true;\n  }\n}\n\n// TODO: move the rest of the file into FacetModel if possible\n\nfunction getFacetGroupProperties(model: FacetModel) {\n  const child = model.child();\n  const mergedCellConfig = extend({}, child.config().cell, child.config().facet.cell);\n\n  return extend({\n      x: model.has(COLUMN) ? {\n          scale: model.scaleName(COLUMN),\n          field: model.field(COLUMN),\n          // offset by the padding\n          offset: model.scale(COLUMN).padding / 2\n        } : {value: model.config().facet.scale.padding / 2},\n\n      y: model.has(ROW) ? {\n        scale: model.scaleName(ROW),\n        field: model.field(ROW),\n        // offset by the padding\n        offset: model.scale(ROW).padding / 2\n      } : {value: model.config().facet.scale.padding / 2},\n\n      width: {field: {parent: model.child().sizeName('width')}},\n      height: {field: {parent: model.child().sizeName('height')}}\n    },\n    child.assembleParentGroupProperties(mergedCellConfig)\n  );\n}\n\nfunction parseAxisGroup(model: FacetModel, channel: Channel) {\n  // TODO: add a case where inner spec is not a unit (facet/layer/concat)\n  let axisGroup = null;\n\n  const child = model.child();\n  if (child.has(channel)) {\n    if (child.axis(channel)) {\n      if (true) { // the channel has shared axes\n\n        // add a group for the shared axes\n        axisGroup = channel === X ? getXAxesGroup(model) : getYAxesGroup(model);\n\n        if (child.axis(channel) && gridShow(child, channel)) { // show inner grid\n          // add inner axis (aka axis that shows only grid to )\n          child.component.axis[channel] = parseInnerAxis(channel, child);\n        } else {\n          delete child.component.axis[channel];\n        }\n      } else {\n        // TODO: implement independent axes support\n      }\n    }\n  }\n  return axisGroup;\n}\n\n\nfunction getXAxesGroup(model: FacetModel): VgMarkGroup {\n  const hasCol = model.has(COLUMN);\n  return extend(\n    {\n      name: model.name('x-axes'),\n      type: 'group'\n    },\n    hasCol ? {\n      from: { // TODO: if we do facet transform at the parent level we can same some transform here\n        data: model.dataTable(),\n        transform: [{\n          type: 'aggregate',\n          groupby: [model.field(COLUMN)],\n          summarize: {'*': ['count']} // just a placeholder aggregation\n        }]\n      }\n    } : {},\n    {\n      properties: {\n        update: {\n          width: {field: {parent: model.child().sizeName('width')}},\n          height: {\n            field: {group: 'height'}\n          },\n          x: hasCol ? {\n            scale: model.scaleName(COLUMN),\n            field: model.field(COLUMN),\n            // offset by the padding\n            offset: model.scale(COLUMN).padding / 2\n          } : {\n            // offset by the padding\n            value: model.config().facet.scale.padding / 2\n          }\n        }\n      },\n      axes: [parseAxis(X, model.child())]\n    }\n  );\n}\n\nfunction getYAxesGroup(model: FacetModel): VgMarkGroup {\n  const hasRow = model.has(ROW);\n  return extend(\n    {\n      name: model.name('y-axes'),\n      type: 'group'\n    },\n    hasRow ? {\n      from: {\n        data: model.dataTable(),\n        transform: [{\n          type: 'aggregate',\n          groupby: [model.field(ROW)],\n          summarize: {'*': ['count']} // just a placeholder aggregation\n        }]\n      }\n    } : {},\n    {\n      properties: {\n        update: {\n          width: {\n            field: {group: 'width'}\n          },\n          height: {field: {parent: model.child().sizeName('height')}},\n          y: hasRow ? {\n            scale: model.scaleName(ROW),\n            field: model.field(ROW),\n            // offset by the padding\n            offset: model.scale(ROW).padding / 2\n          } : {\n            // offset by the padding\n            value: model.config().facet.scale.padding / 2\n          }\n        }\n      },\n      axes: [parseAxis(Y, model.child())]\n    }\n  );\n}\n\nfunction getRowGridGroups(model: Model): any[] { // TODO: VgMarks\n  const facetGridConfig = model.config().facet.grid;\n\n  const rowGrid = {\n    name: model.name('row-grid'),\n    type: 'rule',\n    from: {\n      data: model.dataTable(),\n      transform: [{type: 'facet', groupby: [model.field(ROW)]}]\n    },\n    properties: {\n      update: {\n        y: {\n          scale: model.scaleName(ROW),\n          field: model.field(ROW)\n        },\n        x: {value: 0, offset: -facetGridConfig.offset },\n        x2: {field: {group: 'width'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  };\n\n  return [rowGrid, {\n    name: model.name('row-grid-end'),\n    type: 'rule',\n    properties: {\n      update: {\n        y: { field: {group: 'height'}},\n        x: {value: 0, offset: -facetGridConfig.offset },\n        x2: {field: {group: 'width'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  }];\n}\n\nfunction getColumnGridGroups(model: Model): any { // TODO: VgMarks\n  const facetGridConfig = model.config().facet.grid;\n\n  const columnGrid = {\n    name: model.name('column-grid'),\n    type: 'rule',\n    from: {\n      data: model.dataTable(),\n      transform: [{type: 'facet', groupby: [model.field(COLUMN)]}]\n    },\n    properties: {\n      update: {\n        x: {\n          scale: model.scaleName(COLUMN),\n          field: model.field(COLUMN)\n        },\n        y: {value: 0, offset: -facetGridConfig.offset},\n        y2: {field: {group: 'height'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  };\n\n  return [columnGrid,  {\n    name: model.name('column-grid-end'),\n    type: 'rule',\n    properties: {\n      update: {\n        x: { field: {group: 'width'}},\n        y: {value: 0, offset: -facetGridConfig.offset},\n        y2: {field: {group: 'height'}, offset: facetGridConfig.offset },\n        stroke: { value: facetGridConfig.color },\n        strokeOpacity: { value: facetGridConfig.opacity },\n        strokeWidth: {value: 0.5}\n      }\n    }\n  }];\n}\n",
    "import {Channel, X, Y, COLOR} from '../channel';\nimport {keys, duplicate, mergeDeep, flatten, unique, isArray, vals, contains, forEach, hash, Dict, extend} from '../util';\nimport {defaultConfig, Config} from '../config';\nimport {LayerSpec, isUnitSpec} from '../spec';\nimport {assembleData, parseLayerData} from './data/data';\nimport {assembleLayout, parseLayerLayout} from './layout';\nimport {Model, isUnitModel} from './model';\nimport {UnitModel} from './unit';\nimport {buildModel} from './common';\nimport {FieldDef} from '../fielddef';\nimport {ScaleComponents} from './scale';\nimport {VgData, VgAxis, VgLegend, isUnionedDomain, isDataRefDomain, VgDataRef} from '../vega.schema';\nimport {RepeatValues} from './repeat';\nimport * as selections from './selections';\n\nexport class LayerModel extends Model {\n  public _select: any;  // To collate all the child selections\n  private _resolve;\n\n  constructor(spec: LayerSpec, parent: Model, parentGivenName: string, repeatValues: RepeatValues) {\n    super(spec, parent, parentGivenName, repeatValues);\n\n    this._select = {};\n\n    this._resolve = spec.resolve || {};\n    this._config = this._initConfig(spec.config, parent);\n    this._children = spec.layers.map((layer, i) => {\n      if (isUnitSpec(layer)) {\n        layer.select = extend(this._select, layer.select);\n        extend(this._select, layer.select);\n      }\n\n      // we know that the model has to be a unit model beacuse we pass in a unit spec\n      return buildModel(layer, this, this.name('layer_' + i), repeatValues) as UnitModel;\n    });\n  }\n\n  private _initConfig(specConfig: Config, parent: Model) {\n    return mergeDeep(duplicate(defaultConfig), specConfig, parent ? parent.config() : {});\n  }\n\n  public has(channel: Channel): boolean {\n    // layer does not have any channels\n    return false;\n  }\n\n  public isOrdinalScale(channel: Channel) {\n    // since we assume shared scales we can just ask the first child\n    return this._children[0].isOrdinalScale(channel);\n  }\n\n  public dataTable(): string {\n    // FIXME: don't just use the first child\n    return this._children[0].dataTable();\n  }\n\n  public isRepeatRef(channel: Channel) {\n    // todo\n    return false;\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    return null; // layer does not have field defs\n  }\n\n  public stack() {\n    return null; // this is only a property for UnitModel\n  }\n\n  public parseSelection() {\n    this._select = {};\n    this.component.selection = [];\n    this._children.forEach((child) => {\n      // Children within layers can reference selections defined prior.\n      // We first parse a child's selections, then extend them with their siblings'.\n      child.parseSelection();\n      if (isUnitModel(child)) {\n        extend(this._select, child._select);\n        this.component.selection.push.apply(this.component.selection, child.selection());\n      }\n    });\n  }\n\n  public parseData() {\n    this._children.forEach((child) => {\n      child.parseData();\n    });\n    this.component.data = parseLayerData(this);\n  }\n\n  public parseLayoutData() {\n    // TODO: correctly union ordinal scales rather than just using the layout of the first child\n    this._children.forEach((child, i) => {\n      child.parseLayoutData();\n    });\n    this.component.layout = parseLayerLayout(this);\n  }\n\n  public parseScale() {\n    // TODO:(kanitw): move logic of this function to `scale.ts` for easier readability.\n    const model = this;\n\n    let scaleComponent = this.component.scale = {} as Dict<ScaleComponents>;\n\n    this._children.forEach(function(child) {\n      child.parseScale();\n\n      // FIXME: correctly implement independent scale\n      if (true) { // if shared/union scale\n        forEach(child.component.scale, function(value, channel) {\n          let childScales: ScaleComponents = value;\n          if (!childScales) {\n            // the child does not have any scales so we have nothing to merge\n            return;\n          }\n\n          if (channel in model._resolve && model._resolve[channel].scale === 'independent') {\n            scaleComponent[child.name(channel)] = childScales;\n            return;\n          }\n\n          const modelScales: ScaleComponents = scaleComponent[channel];\n          if (modelScales && modelScales.main) {\n            // Scales are unioned by combining the domain of the main scale.\n            // Other scales that are used for ordinal legends are appended.\n            const modelDomain = modelScales.main.domain;\n            const childDomain = childScales.main.domain;\n\n            if (isArray(modelDomain)) {\n              if (isArray(childScales.main.domain)) {\n                modelScales.main.domain = modelDomain.concat(childDomain);\n              } else {\n                model.addWarning('custom domain scale cannot be unioned with default field-based domain');\n              }\n            } else {\n              const unionedFields = isUnionedDomain(modelDomain) ? modelDomain.fields : [modelDomain] as VgDataRef[];\n\n              if (isArray(childDomain)) {\n                model.addWarning('custom domain scale cannot be unioned with default field-based domain');\n              }\n\n              let fields = isDataRefDomain(childDomain) ? unionedFields.concat([childDomain]) :\n                // if the domain is itself a union domain, concat\n                isUnionedDomain(childDomain) ? unionedFields.concat(childDomain.fields) :\n                  // we have to ignore explicit data domains for now because vega does not support unioning them\n                  unionedFields;\n              fields = unique(fields, hash);\n              // TODO: if all domains use the same data, we can merge them\n              if (fields.length > 1) {\n                modelScales.main.domain = { fields: fields };\n              } else {\n                modelScales.main.domain = fields[0];\n              }\n            }\n\n            // create color legend and color legend bin scales if we don't have them yet\n            if (childScales.colorLegend) {\n              modelScales.colorLegend = modelScales.colorLegend ? modelScales.colorLegend : childScales.colorLegend;\n            }\n            if (childScales.binColorLegend) {\n              modelScales.binColorLegend = modelScales.binColorLegend ? modelScales.binColorLegend : childScales.binColorLegend;\n            }\n          } else {\n            scaleComponent[channel] = childScales;\n          }\n\n          // rename child scales to parent scales\n          [childScales.main, childScales.colorLegend, childScales.binColorLegend]\n            .filter((x) => !!x)\n            .forEach(function(scale) {\n              const scaleNameWithoutPrefix = scale.name.substr(child.name('').length);\n              const newName = model.scaleName(scaleNameWithoutPrefix);\n              child.renameScale(scale.name, newName);\n              scale.name = newName;\n            });\n\n          delete childScales[channel];\n        });\n      }\n    });\n  }\n\n  public parseMark() {\n    this._children.forEach(function(child) {\n      child.parseMark();\n    });\n  }\n\n  public parseAxis() {\n    const model = this;\n    let axisComponent = this.component.axis = {} as Dict<VgAxis[]>;\n\n    // do we already have an axis for this channel?\n    let channels = {};\n\n    this._children.forEach(function(child) {\n      child.parseAxis();\n\n      // TODO: correctly implement independent axes\n      if (true) { // if shared/union scale\n        keys(child.component.axis).forEach(function(channel) {\n          // TODO: support multiple axes for shared scale\n\n          if (channel in model._resolve && model._resolve[channel].scale === 'independent') {\n            const axis = child.component.axis[channel];\n            if (channels[channel]) {\n              axis.orient = 'right';\n            }\n            axis.properties = {\n              title: {\n                fill: {value: child.fieldDef(COLOR).value}\n              }\n            };\n            axisComponent[child.name(channel)] = axis;\n          } else {\n            // just use the first axis definition for each channel\n            if (!axisComponent[channel]) {\n              axisComponent[channel] = child.component.axis[channel];\n            }\n          }\n          channels[channel] = true;\n        });\n      }\n    });\n  }\n\n  public parseAxisGroup() {\n    return null;\n  }\n\n  public parseGridGroup() {\n    return null;\n  }\n\n  public parseLegend() {\n    let legendComponent = this.component.legend = {} as Dict<VgLegend>;\n\n    this._children.forEach(function(child) {\n      child.parseLegend();\n\n      // TODO: correctly implement independent axes\n      if (true) { // if shared/union scale\n        keys(child.component.legend).forEach(function(channel) {\n          // just use the first legend definition for each channel\n          if (!legendComponent[channel]) {\n            legendComponent[channel] = child.component.legend[channel];\n          }\n        });\n      }\n    });\n  }\n\n  public assembleParentGroupProperties() {\n    return {\n      unitName: { value: this.name() }\n    };\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    // Prefix traversal – parent data might be referred to by children data\n    assembleData(this, data);\n    this._children.forEach((child) => {\n      child.assembleData(data);\n    });\n    return data;\n  }\n\n  public assemblePreSelectionData(data: VgData[]): VgData[] {\n    this._children.forEach((child) => child.assemblePreSelectionData(data));\n    return selections.assembleCompositeData(this, data);\n  }\n\n  public assemblePostSelectionData(data: VgData[]): VgData[] {\n    this._children.forEach((child) => child.assemblePostSelectionData(data));\n    return selections.assembleCompositeData(this, data);\n  }\n\n  public assembleSignals(signals) {\n    this._children.forEach((child) => child.assembleSignals(signals));\n    return selections.assembleCompositeSignals(this, signals);\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    // Postfix traversal – layout is assembled bottom-up\n    this._children.forEach((child) => {\n      child.assembleLayout(layoutData);\n    });\n    return assembleLayout(this, layoutData);\n  }\n\n  public assembleMarks(): any[] {\n    var children = this._children;\n\n    // First get the actual marks\n    var marks = flatten(children.map((child) => {\n      return child.assembleMarks();\n    }));\n\n    children.forEach(function(child) {\n      if (isUnitModel(child)) {\n        child.assembleSelectionMarks(marks);\n      }\n    });\n\n    return marks;\n  }\n\n  public channels() {\n    return [];\n  }\n\n  public selection(name?: string) {\n    return (this._select && this._select[name]) || this.component.selection || [];\n  }\n\n  protected mapping() {\n    return null;\n  }\n\n  public isLayer() {\n    return true;\n  }\n\n  /**\n   * Returns true if the child either has no source defined or uses the same url.\n   * This is useful if you want to know whether it is possible to move a filter up.\n   *\n   * This function can only be called once th child has been parsed.\n   */\n  public compatibleSource(child: UnitModel) {\n    const sourceUrl = this.data() && this.data().url;\n    const childData = child.component.data;\n    const compatible = !childData.source || (sourceUrl && sourceUrl === childData.source.url);\n    return compatible;\n  }\n}\n",
    "\nimport {Channel, X, Y, ROW, COLUMN} from '../channel';\nimport {LAYOUT} from '../data';\nimport {ScaleType} from '../scale';\nimport {Formula} from '../transform';\nimport {extend, keys, hash, unique, StringSet} from '../util';\nimport {VgData} from '../vega.schema';\n\nimport {FacetModel} from './facet';\nimport {RepeatModel} from './repeat';\nimport {LayerModel} from './layer';\nimport {ConcatModel} from './concat';\nimport {TEXT as TEXT_MARK} from '../mark';\nimport {Model} from './model';\nimport {rawDomain} from './time';\nimport {UnitModel} from './unit';\n\n// FIXME: for nesting x and y, we need to declare x,y layout separately before joining later\n// For now, let's always assume shared scale\nexport interface LayoutComponent {\n  width: SizeComponent;\n  height: SizeComponent;\n}\n\nexport interface SizeComponent {\n  /** Field that we need to calculate distinct */\n  distinct: StringSet;\n\n  /** Array of formulas */\n  formula: Formula[];\n}\n\nexport function assembleLayout(model: Model, layoutData: VgData[]): VgData[] {\n  const layoutComponent = model.component.layout;\n  if (!layoutComponent || (!layoutComponent.width && !layoutComponent.height)) {\n    return layoutData; // Do nothing\n  }\n\n  if (true) { // if both are shared scale, we can simply merge data source for width and for height\n    const distinctFields = keys(extend(layoutComponent.width.distinct, layoutComponent.height.distinct));\n    const formula = layoutComponent.width.formula.concat(layoutComponent.height.formula)\n      .map(function(formula) {\n        return extend({type: 'formula'}, formula);\n      });\n\n    layoutData.push(\n      distinctFields.length > 0 ? {\n        name: model.dataName(LAYOUT),\n        source: model.dataTable(),\n        transform: [{\n            type: 'aggregate',\n            summarize: distinctFields.map(function(field) {\n              return { field: field, ops: ['distinct'] };\n            })\n          }].concat(formula)\n      } : {\n        name: model.dataName(LAYOUT),\n        values: [{}],\n        transform: formula\n      }\n    );\n    return layoutData;\n  }\n  // FIXME: implement\n  // otherwise, we need to join width and height (cross)\n}\n\n// FIXME: for nesting x and y, we need to declare x,y layout separately before joining later\n// For now, let's always assume shared scale\nexport function parseUnitLayout(model: UnitModel): LayoutComponent {\n  return {\n    width: parseUnitSizeLayout(model, X),\n    height: parseUnitSizeLayout(model, Y)\n  };\n}\n\nfunction parseUnitSizeLayout(model: UnitModel, channel: Channel): SizeComponent {\n  // TODO: think about whether this config has to be the cell or facet cell config\n  const cellConfig = model.config().cell;\n  const nonOrdinalSize = channel === X ? cellConfig.width : cellConfig.height;\n\n  return {\n    distinct: getDistinct(model, channel),\n    formula: [{\n      field: model.channelSizeName(channel),\n      expr: unitSizeExpr(model, channel, nonOrdinalSize)\n    }]\n  };\n}\n\nfunction unitSizeExpr(model: UnitModel, channel: Channel, nonOrdinalSize: number): string {\n  if (model.has(channel)) {\n    if (model.isOrdinalScale(channel)) {\n      const scale = model.scale(channel);\n      return '(' + cardinalityFormula(model, channel) +\n        ' + ' + scale.padding +\n        ') * ' + scale.bandSize;\n    } else {\n      return nonOrdinalSize + '';\n    }\n  } else {\n    if (model.mark() === TEXT_MARK && channel === X) {\n      // for text table without x/y scale we need wider bandSize\n      return model.config().scale.textBandWidth + '';\n    }\n    return model.config().scale.bandSize + '';\n  }\n}\n\nexport function parseFacetLayout(model: FacetModel): LayoutComponent {\n  return {\n    width: parseFacetSizeLayout(model, COLUMN),\n    height: parseFacetSizeLayout(model, ROW)\n  };\n}\n\nfunction parseFacetSizeLayout(model: FacetModel, channel: Channel): SizeComponent {\n  const childLayoutComponent = model.child().component.layout;\n  const sizeType = channel === ROW ? 'height' : 'width';\n  const childSizeComponent: SizeComponent = childLayoutComponent[sizeType];\n\n  if (true) { // assume shared scale\n    // For shared scale, we can simply merge the layout into one data source\n\n    const distinct = extend(getDistinct(model, channel), childSizeComponent.distinct);\n    const formula = childSizeComponent.formula.concat([{\n      field: model.channelSizeName(channel),\n      expr: facetSizeFormula(model, channel, model.child().channelSizeName(channel))\n    }]);\n\n    delete childLayoutComponent[sizeType];\n    return {\n      distinct: distinct,\n      formula: formula\n    };\n  }\n  // FIXME implement independent scale as well\n  // TODO: - also consider when children have different data source\n}\n\nfunction facetSizeFormula(model: Model, channel: Channel, innerSize: string) {\n  const scale = model.scale(channel);\n  if (model.has(channel)) {\n    return '(datum.' + innerSize + ' + ' + scale.padding + ')' + ' * ' + cardinalityFormula(model, channel);\n  } else {\n    return 'datum.' + innerSize + ' + ' + model.config().facet.scale.padding; // need to add outer padding for facet\n  }\n}\n\nexport function parseRepeatLayout(model: RepeatModel): LayoutComponent {\n  const childLayouts = model.children().map((child) => child.component.layout);\n  const allTheSame = unique(\n    childLayouts.map((layout: LayoutComponent) => {\n      return hash({\n        width : {\n          distinct: layout.width.distinct,\n          expr: layout.width.formula.map((f) => f.expr)\n        },\n        height : {\n          distinct: layout.height.distinct,\n          expr: layout.height.formula.map((f) => f.expr)\n        }\n      });\n    })\n  ).length === 1;\n\n  const layout = {\n    width: parseRepeatSizeLayout(model, COLUMN, allTheSame),\n    height: parseRepeatSizeLayout(model, ROW, allTheSame),\n  };\n\n  if (allTheSame) {\n    model.children().forEach((child) => {\n      model.renameData(child.dataName(LAYOUT), model.dataName(LAYOUT));\n      model.renameSize(child.sizeName('width'), model.sizeName('child_width'));\n      model.renameSize(child.sizeName('height'), model.sizeName('child_height'));\n      delete child.component.layout;\n    });\n  }\n\n  return layout;\n}\n\nfunction parseRepeatSizeLayout(model: RepeatModel, channel: Channel, allTheSame: boolean): SizeComponent {\n  // FIXME: support different sizes\n\n  const sizeType = channel === ROW ? 'height' : 'width';\n\n  if (allTheSame) {\n    const childLayoutComponent = model.children()[0].component.layout;\n    const childSizeComponent: SizeComponent = childLayoutComponent[sizeType];\n    const childFieldName = model.sizeName('child_' + sizeType);\n\n    const distinct = extend(getDistinct(model, channel), childSizeComponent.distinct);\n    const formula = [{\n      field: childFieldName,\n      expr: childSizeComponent.formula[0].expr\n    },{\n      field: model.channelSizeName(channel),\n      expr: repeatSizeFormula(model, channel, childFieldName)\n    }];\n\n    return {\n      distinct: distinct,\n      formula: formula\n    };\n  }\n\n  console.error('cannot have different layouts in repeated children');\n  return null;\n}\n\nfunction repeatSizeFormula(model: Model, channel: Channel, innerSize: string) {\n  const scale = model.scale(channel);\n  if (model.has(channel)) {\n    return '(datum.' + innerSize + ' + ' + scale.padding + ')' + ' * ' + cardinalityFormula(model, channel);\n  } else {\n    return 'datum.' + innerSize + ' + ' + model.config().facet.scale.padding; // need to add outer padding for facet\n  }\n}\n\nexport function parseLayerLayout(model: LayerModel): LayoutComponent {\n  return {\n    width: parseLayerSizeLayout(model, X),\n    height: parseLayerSizeLayout(model, Y)\n  };\n}\n\nfunction parseLayerSizeLayout(model: LayerModel, channel: Channel): SizeComponent {\n  if (true) {\n    // For shared scale, we can simply merge the layout into one data source\n    // TODO: don't just take the layout from the first child\n\n    const childLayoutComponent = model.children()[0].component.layout;\n    const sizeType = channel === Y ? 'height' : 'width';\n    const childSizeComponent: SizeComponent = childLayoutComponent[sizeType];\n\n    const distinct = childSizeComponent.distinct;\n    const formula = [{\n      field: model.channelSizeName(channel),\n      expr: childSizeComponent.formula[0].expr\n    }];\n\n    model.children().forEach((child) => {\n      delete child.component.layout[sizeType];\n    });\n\n    return {\n      distinct: distinct,\n      formula: formula\n    };\n  }\n}\n\nexport function parseConcatLayout(model: ConcatModel): LayoutComponent {\n  return {\n    width: parseConcatSizeLayout(model, X),\n    height: parseConcatSizeLayout(model, Y)\n  };\n}\n\nfunction parseConcatSizeLayout(model: ConcatModel, channel: Channel): SizeComponent {\n  const sizeType = channel === Y ? 'height' : 'width';\n  const childLayoutComponent = model.children()[0].component.layout;\n  const childSizeComponent: SizeComponent = childLayoutComponent[sizeType];\n\n  const distinct = childSizeComponent.distinct;\n  const formula = [{\n    field: model.channelSizeName(channel),\n    expr: childSizeComponent.formula[0].expr\n  }];\n\n  return {\n    distinct: distinct,\n    formula: formula\n  };\n}\n\nfunction getDistinct(model: Model, channel: Channel): StringSet {\n  if (model.has(channel) && model.isOrdinalScale(channel)) {\n    const scale = model.scale(channel);\n    if (scale.type === ScaleType.ORDINAL && !(scale.domain instanceof Array)) {\n      // if explicit domain is declared, use array length\n      const distinctField = model.field(channel);\n      let distinct: StringSet = {};\n      distinct[distinctField] = true;\n      return distinct;\n    }\n  }\n  return {};\n}\n\n// TODO: rename to cardinalityExpr\nfunction cardinalityFormula(model: Model, channel: Channel) {\n  const scale = model.scale(channel);\n  if (scale.domain instanceof Array) {\n    return scale.domain.length;\n  }\n\n  const timeUnit = model.fieldDef(channel).timeUnit;\n  const timeUnitDomain = timeUnit ? rawDomain(timeUnit, channel) : null;\n\n  return timeUnitDomain !== null ? timeUnitDomain.length :\n        model.field(channel, {datum: true, prefn: 'distinct_'});\n}\n",
    "import {COLOR, SIZE, SHAPE, Channel} from '../channel';\nimport {FieldDef} from '../fielddef';\nimport {title as fieldTitle} from '../fielddef';\nimport {LegendProperties} from '../legend';\nimport {AREA, BAR, TICK, TEXT, LINE, POINT, CIRCLE, SQUARE} from '../mark';\nimport {ORDINAL} from '../type';\nimport {extend, keys, without, Dict} from '../util';\n\nimport {applyMarkConfig, FILL_STROKE_CONFIG, formatMixins as utilFormatMixins, timeFormat} from './common';\nimport {COLOR_LEGEND, COLOR_LEGEND_LABEL} from './scale';\nimport {UnitModel} from './unit';\nimport {VgLegend} from '../vega.schema';\n\n\nexport function parseLegendComponent(model: UnitModel): Dict<VgLegend> {\n  return [COLOR, SIZE, SHAPE].reduce(function(legendComponent, channel) {\n    if (model.legend(channel)) {\n      legendComponent[channel] = parseLegend(model, channel);\n    }\n    return legendComponent;\n  }, {} as Dict<VgLegend>);\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: Channel): VgLegend {\n  switch (channel) {\n    case COLOR:\n      const fieldDef = model.fieldDef(COLOR);\n      const scale = model.scaleName(useColorLegendScale(fieldDef) ?\n        // To produce ordinal legend (list, rather than linear range) with correct labels:\n        // - For an ordinal field, provide an ordinal scale that maps rank values to field values\n        // - For a field with bin or timeUnit, provide an identity ordinal scale\n        // (mapping the field values to themselves)\n        COLOR_LEGEND :\n        COLOR\n      );\n\n      return model.config().mark.filled ? { fill: scale } : { stroke: scale };\n    case SIZE:\n      return { size: model.scaleName(SIZE) };\n    case SHAPE:\n      return { shape: model.scaleName(SHAPE) };\n  }\n  return null;\n}\n\nexport function parseLegend(model: UnitModel, channel: Channel): VgLegend {\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n\n  let def: VgLegend = getLegendDefWithScale(model, channel);\n\n  // 1.1 Add properties with special rules\n  def.title = title(legend, fieldDef);\n\n  extend(def, formatMixins(legend, model, channel));\n\n  // 1.2 Add properties without rules\n  ['orient', 'values'].forEach(function(property) {\n    const value = legend[property];\n    if (value !== undefined) {\n      def[property] = value;\n    }\n  });\n\n  // 2) Add mark property definition groups\n  const props = (typeof legend !== 'boolean' && legend.properties) || {};\n  ['title', 'symbols', 'legend', 'labels'].forEach(function(group) {\n    let value = properties[group] ?\n      properties[group](fieldDef, props[group], model, channel) : // apply rule\n      props[group]; // no rule -- just default values\n    if (value !== undefined && keys(value).length > 0) {\n      def.properties = def.properties || {};\n      def.properties[group] = value;\n    }\n  });\n\n  return def;\n}\n\nexport function title(legend: LegendProperties, fieldDef: FieldDef) {\n  if (typeof legend !== 'boolean' && legend.title) {\n    return legend.title;\n  }\n\n  return fieldTitle(fieldDef);\n}\n\nexport function formatMixins(legend: LegendProperties, model: UnitModel, channel: Channel) {\n  const fieldDef = model.fieldDef(channel);\n\n  // If the channel is binned, we should not set the format because we have a range label\n  if (fieldDef.bin) {\n    return {};\n  }\n\n  return utilFormatMixins(model, channel, typeof legend !== 'boolean' ? legend.format : undefined);\n}\n\n// we have to use special scales for ordinal or binned fields for the color channel\nexport function useColorLegendScale(fieldDef: FieldDef): boolean {\n  return fieldDef.type === ORDINAL || !!fieldDef.bin || !!fieldDef.timeUnit;\n}\n\nnamespace properties {\n  export function symbols(fieldDef: FieldDef, symbolsSpec, model: UnitModel, channel: Channel) {\n    let symbols:any = {};\n    const mark = model.mark();\n\n    switch (mark) {\n      case BAR:\n      case TICK:\n      case TEXT:\n        symbols.shape = {value: 'square'};\n        break;\n      case CIRCLE:\n      case SQUARE:\n        symbols.shape = { value: mark };\n        break;\n      case POINT:\n      case LINE:\n      case AREA:\n        // use default circle\n        break;\n    }\n\n    const filled = model.config().mark.filled;\n\n    applyMarkConfig(symbols, model,\n      channel === COLOR ?\n        /* For color's legend, do not set fill (when filled) or stroke (when unfilled) property from config because the the legend's `fill` or `stroke` scale should have precedence */\n        without(FILL_STROKE_CONFIG, [ filled ? 'fill' : 'stroke']) :\n        /* For other legend, no need to omit. */\n        FILL_STROKE_CONFIG\n    );\n\n    if (filled) {\n      symbols.strokeWidth = { value: 0 };\n    }\n\n    let value;\n    if (model.has(COLOR) && channel === COLOR) {\n      if (useColorLegendScale(fieldDef)) {\n        // for color legend scale, we need to override\n        value = { scale: model.scaleName(COLOR), field: 'data' };\n      }\n    } else if (model.fieldDef(COLOR).value) {\n      value = { value: model.fieldDef(COLOR).value };\n    }\n\n    if (value !== undefined) {\n      // apply the value\n      if (filled) {\n        symbols.fill = value;\n      } else {\n        symbols.stroke = value;\n      }\n    } else if (channel !== COLOR) {\n      // For non-color legend, apply color config if there is no fill / stroke config.\n      // (For color, do not override scale specified!)\n      symbols[filled ? 'fill' : 'stroke'] = symbols[filled ? 'fill' : 'stroke'] ||\n        {value: model.config().mark.color};\n    }\n\n    symbols = extend(symbols, symbolsSpec || {});\n\n    return keys(symbols).length > 0 ? symbols : undefined;\n  }\n\n  export function labels(fieldDef: FieldDef, symbolsSpec, model: UnitModel, channel: Channel): any {\n    if (channel === COLOR) {\n      if (fieldDef.type === ORDINAL) {\n        return {\n          text: {\n            scale: model.scaleName(COLOR_LEGEND),\n            field: 'data'\n          }\n        };\n      } else if (fieldDef.bin) {\n        return {\n          text: {\n            scale: model.scaleName(COLOR_LEGEND_LABEL),\n            field: 'data'\n          }\n        };\n      } else if (fieldDef.timeUnit) {\n        return {\n          text: {\n            template: '{{ datum.data | time:\\'' + timeFormat(model, channel) + '\\'}}'\n          }\n        };\n      }\n    }\n    return undefined;\n  }\n}\n",
    "import {UnitModel} from '../unit';\nimport {X, Y} from '../../channel';\nimport {isDimension, isMeasure} from '../../fielddef';\nimport {applyColorAndOpacity, applyMarkConfig} from '../common';\n\nexport namespace area {\n  export function markType() {\n    return 'area';\n  }\n\n  export function properties(model: UnitModel) {\n    // TODO Use Vega's marks properties interface\n    let p: any = {};\n\n    const orient = model.config().mark.orient;\n    if (orient !== undefined) {\n      p.orient = { value: orient };\n    }\n\n    const stack = model.stack();\n    const xFieldDef = model.encoding().x;\n    // x\n    if (stack && X === stack.fieldChannel) { // Stacked Measure\n      p.x = {\n        scale: model.scaleName(X),\n        field: model.field(X, { suffix: '_start' })\n      };\n    } else if (isMeasure(xFieldDef)) { // Measure\n      p.x = { scale: model.scaleName(X), field: model.field(X) };\n    } else if (isDimension(xFieldDef)) {\n      p.x = {\n        scale: model.scaleName(X),\n        field: model.field(X, { binSuffix: '_mid' })\n      };\n    }\n\n    // x2\n    if (orient === 'horizontal') {\n      if (stack && X === stack.fieldChannel) {\n        p.x2 = {\n          scale: model.scaleName(X),\n          field: model.field(X, { suffix: '_end' })\n        };\n      } else {\n        p.x2 = {\n          scale: model.scaleName(X),\n          value: 0\n        };\n      }\n    }\n\n    // y\n    const yFieldDef = model.encoding().y;\n    if (stack && Y === stack.fieldChannel) { // Stacked Measure\n      p.y = {\n        scale: model.scaleName(Y),\n        field: model.field(Y, { suffix: '_start' })\n      };\n    } else if (isMeasure(yFieldDef)) {\n      p.y = {\n        scale: model.scaleName(Y),\n        field: model.field(Y)\n      };\n    } else if (isDimension(yFieldDef)) {\n      p.y = {\n        scale: model.scaleName(Y),\n        field: model.field(Y, { binSuffix: '_mid' })\n      };\n    }\n\n    if (orient !== 'horizontal') { // 'vertical' or undefined are vertical\n      if (stack && Y === stack.fieldChannel) {\n        p.y2 = {\n          scale: model.scaleName(Y),\n          field: model.field(Y, { suffix: '_end' })\n        };\n      } else {\n        p.y2 = {\n          scale: model.scaleName(Y),\n          value: 0\n        };\n      }\n    }\n\n    applyColorAndOpacity(p, model);\n    applyMarkConfig(p, model, ['interpolate', 'tension']);\n    return p;\n  }\n\n  export function labels(model: UnitModel) {\n    // TODO(#240): fill this method\n    return undefined;\n  }\n}\n",
    "import {X, Y, SIZE, Channel} from '../../channel';\nimport {isMeasure} from '../../fielddef';\n\nimport {UnitModel} from '../unit';\nimport {applyColorAndOpacity} from '../common';\n\nexport namespace bar {\n  export function markType() {\n    return 'rect';\n  }\n\n  export function properties(model: UnitModel) {\n    // TODO Use Vega's marks properties interface\n    let p: any = {};\n\n    const orient = model.config().mark.orient;\n\n    const stack = model.stack();\n    const xFieldDef = model.encoding().x;\n    // x, x2, and width -- we must specify two of these in all conditions\n    if (stack && X === stack.fieldChannel) {\n      // 'x' is a stacked measure, thus use <field>_start and <field>_end for x, x2.\n      p.x = {\n        scale: model.scaleName(X),\n        field: model.field(X, { suffix: '_start' })\n      };\n      p.x2 = {\n        scale: model.scaleName(X),\n        field: model.field(X, { suffix: '_end' })\n      };\n    } else if (isMeasure(xFieldDef)) {\n      if (orient === 'horizontal') {\n        p.x = {\n          scale: model.scaleName(X),\n          field: model.field(X)\n        };\n        p.x2 = {\n          scale: model.scaleName(X),\n          value: 0\n        };\n      } else { // vertical\n        p.xc = {\n          scale: model.scaleName(X),\n          field: model.field(X)\n        };\n        p.width = {value: sizeValue(model, X)};\n      }\n    } else if (model.fieldDef(X).bin) {\n      if (model.has(SIZE) && orient !== 'horizontal') {\n        // For vertical chart that has binned X and size,\n        // center bar and apply size to width.\n        p.xc = {\n          scale: model.scaleName(X),\n          field: model.field(X, { binSuffix: '_mid' })\n        };\n        p.width = {\n          scale: model.scaleName(SIZE),\n          field: model.field(SIZE)\n        };\n      } else {\n        p.x = {\n          scale: model.scaleName(X),\n          field: model.field(X, { binSuffix: '_start' }),\n          offset: 1\n        };\n        p.x2 = {\n          scale: model.scaleName(X),\n          field: model.field(X, { binSuffix: '_end' })\n        };\n      }\n    } else { // x is dimension or unspecified\n      if (model.has(X)) { // is ordinal\n       p.xc = {\n         scale: model.scaleName(X),\n         field: model.field(X)\n       };\n     } else { // no x\n        p.x = { value: 0, offset: 2 };\n      }\n\n      p.width = model.has(SIZE) && orient !== 'horizontal' ? {\n          // apply size scale if has size and is vertical (explicit \"vertical\" or undefined)\n          scale: model.scaleName(SIZE),\n          field: model.field(SIZE)\n        } : {\n          // otherwise, use fixed size\n          value: sizeValue(model, (X))\n        };\n    }\n\n    const yFieldDef = model.encoding().y;\n    // y, y2 & height -- we must specify two of these in all conditions\n    if (stack && Y === stack.fieldChannel) { // y is stacked measure\n      p.y = {\n        scale: model.scaleName(Y),\n        field: model.field(Y, { suffix: '_start' })\n      };\n      p.y2 = {\n        scale: model.scaleName(Y),\n        field: model.field(Y, { suffix: '_end' })\n      };\n    } else if (isMeasure(yFieldDef)) {\n      if (orient !== 'horizontal') { // vertical (explicit 'vertical' or undefined)\n        p.y = {\n          scale: model.scaleName(Y),\n          field: model.field(Y)\n        };\n        p.y2 = {\n          scale: model.scaleName(Y),\n          value: 0\n        };\n      } else {\n        p.yc = {\n          scale: model.scaleName(Y),\n          field: model.field(Y)\n        };\n        p.height = { value: sizeValue(model, Y) };\n      }\n    } else if (model.fieldDef(Y).bin) {\n      if (model.has(SIZE) && orient === 'horizontal') {\n        // For horizontal chart that has binned Y and size,\n        // center bar and apply size to height.\n        p.yc = {\n          scale: model.scaleName(Y),\n          field: model.field(Y, { binSuffix: '_mid' })\n        };\n        p.height = {\n          scale: model.scaleName(SIZE),\n          field: model.field(SIZE)\n        };\n      } else {\n        // Otherwise, simply use <field>_start, <field>_end\n        p.y = {\n          scale: model.scaleName(Y),\n          field: model.field(Y, { binSuffix: '_start' })\n        };\n        p.y2 = {\n          scale: model.scaleName(Y),\n          field: model.field(Y, { binSuffix: '_end' }),\n          offset: 1\n        };\n      }\n    } else { // y is ordinal or unspecified\n\n      if (model.has(Y)) { // is ordinal\n        p.yc = {\n          scale: model.scaleName(Y),\n          field: model.field(Y)\n        };\n      } else { // No Y\n        p.y2 = {\n          field: { group: 'height' },\n          offset: -1\n        };\n      }\n\n      p.height = model.has(SIZE)  && orient === 'horizontal' ? {\n          // apply size scale if has size and is horizontal\n          scale: model.scaleName(SIZE),\n          field: model.field(SIZE)\n        } : {\n          value: sizeValue(model, Y)\n        };\n    }\n\n    applyColorAndOpacity(p, model);\n    return p;\n  }\n\n  function sizeValue(model: UnitModel, channel: Channel) {\n    const fieldDef = model.fieldDef(SIZE);\n    if (fieldDef && fieldDef.value !== undefined) {\n       return fieldDef.value;\n    }\n\n    const markConfig = model.config().mark;\n    if (markConfig.barSize) {\n      return markConfig.barSize;\n    }\n    // BAR's size is applied on either X or Y\n    return model.isOrdinalScale(channel) ?\n        // For ordinal scale or single bar, we can use bandSize - 1\n        // (-1 so that the border of the bar falls on exact pixel)\n        model.scale(channel).bandSize - 1 :\n      !model.has(channel) ?\n        model.config().scale.bandSize - 1 :\n        // otherwise, set to thinBarWidth by default\n        markConfig.barThinSize;\n  }\n\n  export function labels(model: UnitModel) {\n    // TODO(#64): fill this method\n    return undefined;\n  }\n}\n",
    "import {UnitModel} from '../unit';\nimport {X, Y, SIZE} from '../../channel';\nimport {applyColorAndOpacity, applyMarkConfig} from '../common';\n\n\nexport namespace line {\n  export function markType() {\n    return 'line';\n  }\n\n  export function properties(model: UnitModel) {\n    // TODO Use Vega's marks properties interface\n    let p: any = {};\n\n    // x\n    if (model.has(X)) {\n      p.x = {\n        scale: model.scaleName(X),\n        field: model.field(X, { binSuffix: '_mid' })\n      };\n    } else {\n      p.x = { value: 0 };\n    }\n\n    // y\n    if (model.has(Y)) {\n      p.y = {\n        scale: model.scaleName(Y),\n        field: model.field(Y, { binSuffix: '_mid' })\n      };\n    } else {\n      p.y = { field: { group: 'height' } };\n    }\n\n    applyColorAndOpacity(p, model);\n    applyMarkConfig(p, model, ['interpolate', 'tension']);\n\n    // size as a channel is not supported in Vega yet.\n    const size = sizeValue(model);\n    if (size) {\n      p.strokeWidth = { value: size };\n    }\n    return p;\n  }\n\n  function sizeValue(model: UnitModel) {\n    const fieldDef = model.fieldDef(SIZE);\n    if (fieldDef && fieldDef.value !== undefined) {\n       return fieldDef.value;\n    }\n    return model.config().mark.lineSize;\n  }\n\n  export function labels(model: UnitModel) {\n    // TODO(#240): fill this method\n    return undefined;\n  }\n}\n",
    "import {UnitModel} from '../unit';\nimport {OrderChannelDef} from '../../fielddef';\n\nimport {X, Y, COLOR, TEXT, SHAPE, PATH, ORDER, DETAIL, LABEL} from '../../channel';\nimport {AREA, LINE, TEXT as TEXTMARK} from '../../mark';\nimport {imputeTransform, stackTransform} from '../stack';\nimport {contains, extend} from '../../util';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {line} from './line';\nimport {point, circle, square} from './point';\nimport {text} from './text';\nimport {tick} from './tick';\nimport {rule} from './rule';\nimport {sortField} from '../common';\n\nconst markCompiler = {\n  area: area,\n  bar: bar,\n  line: line,\n  point: point,\n  text: text,\n  tick: tick,\n  rule: rule,\n  circle: circle,\n  square: square\n};\n\nexport function parseMark(model: UnitModel): any[] {\n  if (contains([LINE, AREA], model.mark())) {\n    return parsePathMark(model);\n  } else {\n    return parseNonPathMark(model);\n  }\n}\n\nfunction parsePathMark(model: UnitModel) { // TODO: extract this into compilePathMark\n  const mark = model.mark();\n  // TODO: replace this with more general case for composition\n  const isFaceted = model.parent() && model.parent().isFacet();\n  const dataFrom = {data: model.dataTable()};\n  const details = detailFields(model);\n\n  let pathMarks: any = [\n    {\n      name: model.name('marks'),\n      type: markCompiler[mark].markType(),\n      from: extend(\n        // If has facet, `from.data` will be added in the cell group.\n        // If has subfacet for line/area group, `from.data` will be added in the outer subfacet group below.\n        // If has no subfacet, add from.data.\n        isFaceted || details.length > 0 ? {} : dataFrom,\n\n        // sort transform\n        {transform: [{ type: 'sort', by: sortPathBy(model)}]}\n      ),\n      properties: { update: markCompiler[mark].properties(model) }\n    }\n  ];\n\n  if (details.length > 0) { // have level of details - need to facet line into subgroups\n    const facetTransform = { type: 'facet', groupby: details };\n    const transform: any[] = mark === AREA && model.stack() ?\n      // For stacked area, we need to impute missing tuples and stack values\n      // (Mark layer order does not matter for stacked charts)\n      [imputeTransform(model), stackTransform(model), facetTransform] :\n      // For non-stacked path (line/area), we need to facet and possibly sort\n      [].concat(\n        facetTransform,\n        // if model has `order`, then sort mark's layer order by `order` field(s)\n        model.has(ORDER) ? [{type:'sort', by: sortBy(model)}] : []\n      );\n\n    return [{\n      name: model.name('pathgroup'),\n      type: 'group',\n      from: extend(\n        // If has facet, `from.data` will be added in the cell group.\n        // Otherwise, add it here.\n        isFaceted ? {} : dataFrom,\n        {transform: transform}\n      ),\n      properties: {\n        update: {\n          width: { field: { group: 'width' } },\n          height: { field: { group: 'height' } },\n          unitName: { value: model.name() }\n        }\n      },\n      marks: pathMarks\n    }];\n  } else {\n    return pathMarks;\n  }\n}\n\nfunction parseNonPathMark(model: UnitModel) {\n  const mark = model.mark();\n  const isFaceted = model.parent() && model.parent().isFacet();\n  const dataFrom = {data: model.dataTable()};\n\n  let marks = []; // TODO: vgMarks\n  if (mark === TEXTMARK &&\n    model.has(COLOR) &&\n    model.config().mark.applyColorToBackground && !model.has(X) && !model.has(Y)\n  ) {\n    // add background to 'text' marks if has color\n    marks.push(extend(\n      {\n        name: model.name('background'),\n        type: 'rect'\n      },\n      // If has facet, `from.data` will be added in the cell group.\n      // Otherwise, add it here.\n      isFaceted ? {} : {from: dataFrom},\n      // Properties\n      { properties: { update: text.background(model) } }\n    ));\n  }\n\n  marks.push(extend(\n    {\n      name: model.name('marks'),\n      type: markCompiler[mark].markType()\n    },\n    // Add `from` if needed\n    (!isFaceted || model.stack() || model.has(ORDER)) ? {\n      from: extend(\n        // If faceted, `from.data` will be added in the cell group.\n        // Otherwise, add it here\n        isFaceted ? {} : dataFrom,\n        // `from.transform`\n        model.stack() ? // Stacked Chart need stack transform\n          { transform: [stackTransform(model)] } :\n        model.has(ORDER) ?\n          // if non-stacked, detail field determines the layer order of each mark\n          { transform: [{type:'sort', by: sortBy(model)}] } :\n          {}\n      )\n    } : {},\n    // properties groups\n    { properties: { update: markCompiler[mark].properties(model) } }\n  ));\n\n  if (model.has(LABEL) && markCompiler[mark].labels) {\n    const labelProperties = markCompiler[mark].labels(model);\n\n    // check if we have label method for current mark type.\n    if (labelProperties !== undefined) { // If label is supported\n      // add label group\n      marks.push(extend(\n        {\n          name: model.name('label'),\n          type: 'text'\n        },\n        // If has facet, `from.data` will be added in the cell group.\n        // Otherwise, add it here.\n        isFaceted ? {} : {from: dataFrom},\n        // Properties\n        { properties: { update: labelProperties } }\n      ));\n    }\n  }\n\n  return marks;\n}\n\nfunction sortBy(model: UnitModel): string | string[] {\n  if (model.has(ORDER)) {\n    let channelDef = model.encoding().order;\n    if (channelDef instanceof Array) {\n      // sort by multiple fields\n      return channelDef.map(sortField);\n    } else {\n      // sort by one field\n      return sortField(channelDef as OrderChannelDef); // have to add OrderChannelDef to make tsify not complaining\n    }\n  }\n  return null; // use default order\n}\n\n/**\n * Return path order for sort transform's by property\n */\nfunction sortPathBy(model: UnitModel): string | string[] {\n  if (model.mark() === LINE && model.has(PATH)) {\n    // For only line, sort by the path field if it is specified.\n    const channelDef = model.encoding().path;\n    if (channelDef instanceof Array) {\n      // sort by multiple fields\n      return channelDef.map(sortField);\n    } else {\n      // sort by one field\n      return sortField(channelDef as OrderChannelDef); // have to add OrderChannelDef to make tsify not complaining\n    }\n  } else {\n    // For both line and area, we sort values based on dimension by default\n    return '-' + model.field(model.config().mark.orient === 'horizontal' ? Y : X);\n  }\n}\n\n/**\n * Returns list of detail fields (for 'color', 'shape', or 'detail' channels)\n * that the model's spec contains.\n */\nfunction detailFields(model: UnitModel): string[] {\n  return [COLOR, DETAIL, SHAPE].reduce(function(details, channel) {\n    if (model.has(channel) && !model.fieldDef(channel).aggregate) {\n      details.push(model.field(channel));\n    }\n    return details;\n  }, []);\n}\n",
    "import {UnitModel} from '../unit';\nimport {X, Y, SHAPE, SIZE} from '../../channel';\nimport {applyColorAndOpacity} from '../common';\n\nexport namespace point {\n  export function markType() {\n    return 'symbol';\n  }\n\n  export function properties(model: UnitModel, fixedShape?: string) {\n    // TODO Use Vega's marks properties interface\n    let p: any = {};\n\n    // x\n    if (model.has(X)) {\n      p.x = {\n        scale: model.scaleName(X),\n        field: model.field(X, { binSuffix: '_mid' })\n      };\n    } else {\n      p.x = { value: model.config().scale.bandSize / 2 };\n    }\n\n    // y\n    if (model.has(Y)) {\n      p.y = {\n        scale: model.scaleName(Y),\n        field: model.field(Y, { binSuffix: '_mid' })\n      };\n    } else {\n      p.y = { value: model.config().scale.bandSize / 2 };\n    }\n\n    // size\n    if (model.has(SIZE)) {\n      p.size = {\n        scale: model.scaleName(SIZE),\n        field: model.field(SIZE)\n      };\n    } else {\n      p.size = { value: sizeValue(model) };\n    }\n\n    // shape\n    if (fixedShape) { // square and circle marks\n      p.shape = { value: fixedShape };\n    } else if (model.has(SHAPE)) {\n      p.shape = {\n        scale: model.scaleName(SHAPE),\n        field: model.field(SHAPE)\n      };\n    } else if (model.fieldDef(SHAPE).value) {\n      p.shape = { value: model.fieldDef(SHAPE).value };\n    } else if (model.config().mark.shape) {\n      p.shape = { value: model.config().mark.shape };\n    }\n\n    applyColorAndOpacity(p, model);\n    return p;\n  }\n\n  function sizeValue(model: UnitModel) {\n    const fieldDef = model.fieldDef(SIZE);\n    if (fieldDef && fieldDef.value !== undefined) {\n       return fieldDef.value;\n    }\n\n    return model.config().mark.size;\n  }\n\n  export function labels(model: UnitModel) {\n    // TODO(#240): fill this method\n  }\n}\n\nexport namespace circle {\n  export function markType() {\n    return 'symbol';\n  }\n\n  export function properties(model: UnitModel) {\n    return point.properties(model, 'circle');\n  }\n\n  export function labels(model: UnitModel) {\n    // TODO(#240): fill this method\n    return undefined;\n  }\n}\n\nexport namespace square {\n  export function markType() {\n    return 'symbol';\n  }\n\n  export function properties(model: UnitModel) {\n    return point.properties(model, 'square');\n  }\n\n  export function labels(model: UnitModel) {\n    // TODO(#240): fill this method\n    return undefined;\n  }\n}\n",
    "import {X, Y, SIZE, Channel} from '../../channel';\nimport {UnitModel} from '../unit';\nimport {applyColorAndOpacity} from '../common';\nimport * as u from '../../util';\n\nexport namespace rule {\n  export function markType() {\n    return 'rule';\n  }\n\n  export function properties(model: UnitModel) {\n    let p: any = {};\n\n    // TODO: support explicit value\n\n    // vertical\n    if (model.has(X)) {\n      p.x = position(model, X);\n\n      p.y = { value: 0 };\n      p.y2 = {\n          field: {group: 'height'}\n        };\n    }\n\n    // horizontal\n    if (model.has(Y)) {\n      p.y = position(model, Y);\n\n      p.x = { value: 0 };\n      p.x2 = {\n          field: {group: 'width'}\n        };\n    }\n\n    // FIXME: this function would overwrite strokeWidth but shouldn't\n    applyColorAndOpacity(p, model);\n\n    // size\n    if (model.has(SIZE)) {\n      p.strokeWidth = {\n        scale: model.scaleName(SIZE),\n        field: model.field(SIZE)\n      };\n    } else {\n      p.strokeWidth = { value: sizeValue(model) };\n    }\n\n    return p;\n  }\n\n  function position(model: UnitModel, channel: Channel) {\n    var def = { scale: model.scaleName(channel) },\n      fieldDef = model.fieldDef(channel);\n\n    if (fieldDef.field) {\n      return u.extend(def, {\n        field: model.field(channel, { binSuffix: '_mid' })\n      });\n    } else if (fieldDef.selection) {\n      return u.extend(def, {\n        signal: fieldDef.selection\n      });\n    }\n  }\n\n  function sizeValue(model: UnitModel) {\n    const fieldDef = model.fieldDef(SIZE);\n    if (fieldDef && fieldDef.value !== undefined) {\n       return fieldDef.value;\n    }\n\n    return model.config().mark.ruleSize;\n  }\n\n  export function labels(model: UnitModel) {\n    // TODO(#240): fill this method\n    return undefined;\n  }\n}\n",
    "import {UnitModel} from '../unit';\nimport {X, Y, COLOR, TEXT, SIZE} from '../../channel';\nimport {applyMarkConfig, applyColorAndOpacity, formatMixins} from '../common';\nimport {extend, contains} from '../../util';\nimport {QUANTITATIVE, ORDINAL, TEMPORAL} from '../../type';\n\nexport namespace text {\n  export function markType() {\n    return 'text';\n  }\n\n  export function background(model: UnitModel) {\n    return {\n      x: { value: 0 },\n      y: { value: 0 },\n      width: { field: { group: 'width' } },\n      height: { field: { group: 'height' } },\n      fill: {\n        scale: model.scaleName(COLOR),\n        field: model.field(COLOR, model.fieldDef(COLOR).type === ORDINAL ? {prefn: 'rank_'} : {})\n      }\n    };\n  }\n\n  export function properties(model: UnitModel) {\n    // TODO Use Vega's marks properties interface\n    let p: any = {};\n\n    applyMarkConfig(p, model,\n      ['angle', 'align', 'baseline', 'dx', 'dy', 'font', 'fontWeight',\n        'fontStyle', 'radius', 'theta', 'text']);\n\n    const fieldDef = model.fieldDef(TEXT);\n\n    // x\n    if (model.has(X)) {\n      p.x = {\n        scale: model.scaleName(X),\n        field: model.field(X, { binSuffix: '_mid' })\n      };\n    } else { // TODO: support x.value, x.datum\n      if (model.has(TEXT) && model.fieldDef(TEXT).type === QUANTITATIVE) {\n        p.x = { field: { group: 'width' }, offset: -5 };\n      } else {\n        p.x = { value: model.config().scale.textBandWidth / 2 };\n      }\n    }\n\n    // y\n    if (model.has(Y)) {\n      p.y = {\n        scale: model.scaleName(Y),\n        field: model.field(Y, { binSuffix: '_mid' })\n      };\n    } else {\n      p.y = { value: model.config().scale.bandSize / 2 };\n    }\n\n    // size\n    if (model.has(SIZE)) {\n      p.fontSize = {\n        scale: model.scaleName(SIZE),\n        field: model.field(SIZE)\n      };\n    } else {\n      p.fontSize = { value: sizeValue(model) };\n    }\n\n    if (model.config().mark.applyColorToBackground && !model.has(X) && !model.has(Y)) {\n      p.fill = {value: 'black'}; // TODO: add rules for swapping between black and white\n\n      // opacity\n      const opacity = model.config().mark.opacity;\n      if (opacity) { p.opacity = { value: opacity }; };\n    } else {\n      applyColorAndOpacity(p, model);\n    }\n\n\n    // text\n    if (model.has(TEXT)) {\n      if (contains([QUANTITATIVE, TEMPORAL], model.fieldDef(TEXT).type)) {\n        const format = model.config().mark.format;\n        extend(p, formatMixins(model, TEXT, format));\n      } else {\n        p.text = { field: model.field(TEXT) };\n      }\n    } else if (fieldDef.value) {\n      p.text = { value: fieldDef.value };\n    }\n\n    return p;\n  }\n\n  function sizeValue(model: UnitModel) {\n    const fieldDef = model.fieldDef(SIZE);\n    if (fieldDef && fieldDef.value !== undefined) {\n       return fieldDef.value;\n    }\n\n    return model.config().mark.fontSize;\n  }\n}\n",
    "import {X, Y, SIZE, Channel} from '../../channel';\n\nimport {UnitModel} from '../unit';\nimport {applyColorAndOpacity} from '../common';\n\nexport namespace tick {\n  export function markType() {\n    return 'rect';\n  }\n\n  export function properties(model: UnitModel) {\n    let p: any = {};\n\n    // TODO: support explicit value\n\n    // x\n    if (model.has(X)) {\n      p.xc = {\n        scale: model.scaleName(X),\n        field: model.field(X, { binSuffix: '_mid' })\n      };\n    } else {\n      p.xc = { value: model.config().scale.bandSize / 2 };\n    }\n\n    // y\n    if (model.has(Y)) {\n      p.yc = {\n        scale: model.scaleName(Y),\n        field: model.field(Y, { binSuffix: '_mid' })\n      };\n    } else {\n      p.yc = { value: model.config().scale.bandSize / 2 };\n    }\n\n    if (model.config().mark.orient === 'horizontal') {\n      p.width = { value: model.config().mark.tickThickness };\n      p.height = model.has(SIZE)? {\n            scale: model.scaleName(SIZE),\n            field: model.field(SIZE)\n        } : {\n            value: sizeValue(model, Y)\n        };\n    } else {\n      p.width = model.has(SIZE)? {\n          scale: model.scaleName(SIZE),\n          field: model.field(SIZE)\n        } : {\n          value: sizeValue(model, X)\n        };\n      p.height = { value: model.config().mark.tickThickness };\n    }\n\n    applyColorAndOpacity(p, model);\n    return p;\n  }\n\n  function sizeValue(model: UnitModel, channel: Channel) {\n    const fieldDef = model.fieldDef(SIZE);\n    if (fieldDef && fieldDef.value !== undefined) {\n       return fieldDef.value;\n    }\n\n    const scaleConfig = model.config().scale;\n    const markConfig = model.config().mark;\n\n    if (markConfig.tickSize) {\n      return markConfig.tickSize;\n    }\n    const bandSize = model.has(channel) ?\n      model.scale(channel).bandSize :\n      scaleConfig.bandSize;\n    return bandSize / 1.5;\n  }\n\n  export function labels(model: UnitModel) {\n    // TODO(#240): fill this method\n    return undefined;\n  }\n}\n",
    "import {AxisProperties} from '../axis';\nimport {Channel, X, Y, COLUMN} from '../channel';\nimport {Config, CellConfig} from '../config';\nimport {Data, DataTable} from '../data';\nimport {channelMappingReduce, channelMappingForEach} from '../encoding';\nimport {FieldDef, FieldRefOption, isRepeatRef, field, isCount, COUNT_DISPLAYNAME} from '../fielddef';\nimport {LegendProperties} from '../legend';\nimport {Scale, ScaleType} from '../scale';\nimport {BaseSpec} from '../spec';\nimport {Transform} from '../transform';\nimport {extend, flatten, vals, warning, contains, Dict, array} from '../util';\nimport {VgData, VgMarkGroup, VgScale, VgAxis, VgLegend, VgFieldRef, VgField} from '../vega.schema';\n\nimport {DataComponent} from './data/data';\nimport {LayoutComponent} from './layout';\nimport {ScaleComponents} from './scale';\nimport {RepeatModel, RepeatValues} from './repeat';\nimport {UnitModel} from './unit';\nimport {LayerModel} from './layer';\n\nimport * as selections from './selections';\n\n/**\n * Composable Components that are intermediate results of the parsing phase of the\n * compilations.  These composable components will be assembled in the last\n * compilation step.\n */\nexport interface Component {\n  data: DataComponent;\n  layout: LayoutComponent;\n  selection: selections.Selection[];\n  scale: Dict<ScaleComponents>;\n\n  /** Dictionary mapping channel to VgAxis definition */\n  // TODO: if we allow multiple axes (e.g., dual axis), this will become VgAxis[]\n  axis: Dict<VgAxis>;\n\n  /** Dictionary mapping channel to VgLegend definition */\n  legend: Dict<VgLegend>;\n\n  /** Dictionary mapping channel to axis mark group for facet and concat */\n  axisGroup: Dict<VgMarkGroup>;\n\n  /** Dictionary mapping channel to grid mark group for facet (and concat?) */\n  gridGroup: Dict<VgMarkGroup[]>;\n\n  mark: VgMarkGroup[];\n}\n\nclass NameMap {\n  private _nameMap: Dict<string>;\n\n  constructor() {\n    this._nameMap = {} as Dict<string>;\n  }\n\n  public rename(oldName: string, newName: string) {\n    if (oldName === newName) {\n      return console.error('cannot rename ' + oldName + ' to itself');\n    }\n    this._nameMap[oldName] = newName;\n  }\n\n  public get(name: string): string {\n    // If the name appears in the _nameMap, we need to read its new name.\n    // We have to loop over the dict just in case, the new name also gets renamed.\n    while (this._nameMap[name]) {\n      name = this._nameMap[name];\n    }\n\n    return name;\n  }\n}\n\nexport abstract class Model {\n  protected _parent: Model;\n  protected _name: string;\n  protected _description: string;\n\n  protected _data: Data;\n\n  /** Name map for data sources, which can be renamed by a model's parent. */\n  protected _dataNameMap: NameMap;\n\n  /** Name map for scales, which can be renamed by a model's parent. */\n  protected _scaleNameMap: NameMap;\n\n  /** Name map for size, which can be renamed by a model's parent. */\n  protected _sizeNameMap: NameMap;\n\n  protected _transform: Transform;\n  protected _scale: Dict<Scale>;\n\n  protected _axis: Dict<AxisProperties>;\n\n  protected _legend: Dict<LegendProperties>;\n\n  protected _config: Config;\n\n  protected _warnings: string[] = [];\n\n  protected _children: Model[];  // LayerModel | RepeatModel\n  protected _child: Model;       // FacetModel\n\n  /**\n   * Current iterator value over the repeat value. Indexed by the channel we are repeating over (row, column).\n   */\n  private _repeatValues: RepeatValues = null;\n\n  public component: Component;\n\n  constructor(spec: BaseSpec, parent: Model, parentGivenName: string, repeatValues: RepeatValues) {\n    this._parent = parent;\n\n    // If name is not provided, always use parent's givenName to avoid name conflicts.\n    this._name = spec.name || parentGivenName;\n\n    this._repeatValues = repeatValues;\n\n    // Shared name maps\n    this._dataNameMap = parent ? parent._dataNameMap : new NameMap();\n    this._scaleNameMap = parent ? parent._scaleNameMap : new NameMap();\n    this._sizeNameMap = parent ? parent._sizeNameMap : new NameMap();\n\n    this._data = spec.data;\n\n    this._description = spec.description;\n    this._transform = spec.transform;\n\n    this.component = {data: null, layout: null, selection: null, mark: null, scale: null, axis: null, axisGroup: null, gridGroup: null, legend: null};\n    this._children = [];\n  }\n\n  public parse() {\n    this.parseSelection();\n    this.parseData();\n    this.parseLayoutData();\n    this.parseScale(); // depends on data name\n    this.parseAxis(); // depends on scale name\n    this.parseLegend(); // depends on scale name\n    this.parseAxisGroup(); // depends on child axis\n    this.parseGridGroup();\n    this.parseMark(); // depends on data name and scale name, axisGroup, gridGroup and children's scale, axis, legend and mark.\n  }\n\n  public parseSelection() {}\n\n  public abstract parseData();\n\n  public abstract parseLayoutData();\n\n  public abstract parseScale();\n\n  public abstract parseMark();\n\n  public abstract parseAxis();\n\n  public abstract parseLegend();\n\n  // TODO: revise if these two methods make sense for shared scale concat\n  public abstract parseAxisGroup();\n  public abstract parseGridGroup();\n\n\n  public abstract assembleData(data: VgData[]): VgData[];\n\n  public abstract assembleLayout(layoutData: VgData[]): VgData[];\n\n  public assemblePreSelectionData(data): VgData[] { return []; }\n  public assemblePostSelectionData(data): VgData[] { return []; }\n  public assembleSignals(signals) { return []; }\n\n  public assembleScales(): VgScale[] {\n    // FIXME: write assembleScales() in scale.ts that\n    // help assemble scale domains with scale signature as well\n    return flatten(vals(this.component.scale).map((scales: ScaleComponents) => {\n      let arr = [scales.main];\n      if (scales.colorLegend) {\n        arr.push(scales.colorLegend);\n      }\n      if (scales.binColorLegend) {\n        arr.push(scales.binColorLegend);\n      }\n      return arr;\n    }));\n  }\n\n  public abstract assembleMarks(): any[]; // TODO: VgMarkGroup[]\n\n  public assembleAxes(): VgAxis[] {\n    return vals(this.component.axis);\n  }\n\n  public assembleLegends(): any[] { // TODO: VgLegend[]\n    return vals(this.component.legend);\n  }\n\n  public assembleGroup() {\n    let group: VgMarkGroup = {};\n\n    // TODO: consider if we want scales to come before marks in the output spec.\n\n    group.marks = this.assembleMarks();\n    const scales = this.assembleScales();\n    if (scales.length > 0) {\n      group.scales = scales;\n    }\n\n    const axes = this.assembleAxes();\n    if (axes.length > 0) {\n      group.axes = axes;\n    }\n\n    const legends = this.assembleLegends();\n    if (legends.length > 0) {\n      group.legends = legends;\n    }\n\n    return group;\n  }\n\n  public abstract assembleParentGroupProperties(cellConfig: CellConfig);\n\n  public abstract channels(): Channel[];\n\n  protected abstract mapping();\n\n  public reduce(f: (acc: any, fd: FieldDef, c: Channel) => any, init, t?: any) {\n    const model = this;\n    // wrap function to replace with correct fieldDef\n    function func(acc: any, fd: FieldDef, c: Channel) {\n      if (isRepeatRef(fd.field)) {\n        return f(acc, model.fieldDef(c), c);\n      } else {\n        return f(acc, fd, c);\n      }\n    }\n    return channelMappingReduce(this.channels(), this.mapping(), func, init, t);\n  }\n\n  public forEach(f: (fd: FieldDef, c: Channel, i:number) => void, t?: any) {\n    const model = this;\n    // wrap function to replace with correct fieldDef\n    function func(fd: FieldDef, c: Channel, i:number) {\n      if (isRepeatRef(fd.field)) {\n        f(model.fieldDef(c), c, i);\n      } else {\n        f(fd, c, i);\n      }\n    }\n    channelMappingForEach(this.channels(), this.mapping(), func, t);\n  }\n\n  public abstract has(channel: Channel): boolean;\n\n  public parent(): Model {\n    return this._parent;\n  }\n\n  public name(text?: string, delimiter: string = '_') {\n    return (this._name ? this._name + delimiter : '') + (text || '');\n  }\n\n  public description() {\n    return this._description;\n  }\n\n  public data() {\n    return this._data;\n  }\n\n  public renameData(oldName: string, newName: string) {\n     this._dataNameMap.rename(oldName, newName);\n  }\n\n  /**\n   * Return the data source name for the given data source type.\n   *\n   * For unit spec, this is always simply the spec.name + '-' + dataSourceType.\n   * We already use the name map so that marks and scales use the correct data.\n   */\n  public dataName(dataSourceType: DataTable): string {\n    return this._dataNameMap.get(this.name(String(dataSourceType)));\n  }\n\n  public renameSize(oldName: string, newName: string) {\n    this._sizeNameMap.rename(oldName, newName);\n  }\n\n  public channelSizeName(channel: Channel): string {\n    return this.sizeName(channel === X || channel === COLUMN ? 'width' : 'height');\n  }\n\n  public sizeName(size: string): string {\n     return this._sizeNameMap.get(this.name(size, '_'));\n  }\n\n  public abstract dataTable(): string;\n\n  public transform(): Transform {\n    return this._transform || {};\n  }\n\n  /**\n   * Just the raw field. Get's the value from the iterator if the parent is iterating.\n   * TODO: this is the same as model.field(channel, {nofn: true}). We should maybe remove that option and use optional args.\n   */\n  public fieldOrig(channel: Channel): string {\n    const fieldDef = this.fieldDef(channel);\n    return fieldDef.field as string;\n  }\n\n  public abstract isRepeatRef(channel: Channel): boolean;\n\n  /**\n   * Get the field reference for vega\n   */\n  public field(channel: Channel, opt: FieldRefOption = {}, fieldDef = this.fieldDef(channel)): string {\n    if (fieldDef.bin) { // bin has default suffix that depends on scaleType\n      opt = extend({\n        binSuffix: this.scale(channel).type === ScaleType.ORDINAL ? '_range' : '_start'\n      }, opt);\n    }\n\n    return field(fieldDef, opt);\n  }\n\n  /**\n   * Get the value of the repeater or undefined if the model des not have repeat values set.\n   */\n  public repeatValue(channel: Channel) {\n    return this._repeatValues && this._repeatValues[channel];\n  }\n\n  public abstract fieldDef(channel: Channel): FieldDef;\n\n  public scale(channel: Channel): Scale {\n    return this._scale[channel];\n  }\n\n  // TODO: rename to hasOrdinalScale\n  public isOrdinalScale(channel: Channel) {\n    const scale = this.scale(channel);\n    return scale && scale.type === ScaleType.ORDINAL;\n  }\n\n  public renameScale(oldName: string, newName: string) {\n    this._scaleNameMap.rename(oldName, newName);\n  }\n\n  /**\n   * returns scale name for a given channel\n   */\n  public scaleName(channel: Channel | string): string {\n    return this._scaleNameMap.get(this.name(String(channel)));\n  }\n\n  public sort(channel: Channel) {\n    return (this.fieldDef(channel) as any).sort;\n  }\n\n  public abstract stack();\n\n  public axis(channel: Channel): AxisProperties {\n    return this._axis[channel];\n  }\n\n  public legend(channel: Channel): LegendProperties {\n    return this._legend[channel];\n  }\n\n  /**\n   * Get the spec configuration.\n   */\n  public config(): Config {\n    return this._config;\n  }\n\n  public addWarning(message: string) {\n    warning(message);\n    this._warnings.push(message);\n  }\n\n  public warnings(): string[] {\n    return this._warnings;\n  }\n\n  public children() {\n    return this._children.length ? this._children : array(this._child);\n  }\n\n  /**\n   * Type checks\n   */\n  public isUnit() {\n    return false;\n  }\n  public isFacet() {\n    return false;\n  }\n  public isLayer() {\n    return false;\n  }\n  public isRepeat() {\n    return false;\n  }\n  public isConcat() {\n    return false;\n  }\n}\n\nexport function isUnitModel(model: Model): model is UnitModel {\n  return model.isUnit();\n}\n\nexport function isLayerModel(model: Model): model is LayerModel {\n  return model.isLayer();\n}\n\nexport function isRepeatModel(model: Model): model is RepeatModel {\n  return model.isRepeat();\n}\n",
    "import {COLUMN, ROW, X, Y, Channel} from '../channel';\nimport {defaultConfig, Config} from '../config';\nimport {Repeat} from '../repeat';\nimport {FieldDef} from '../fielddef';\nimport {Scale, ScaleType} from '../scale';\nimport {RepeatSpec, isUnitSpec} from '../spec';\nimport {extend, keys, vals, flatten, duplicate, mergeDeep, contains, forEach, Dict} from '../util';\nimport {VgData, VgLegend} from '../vega.schema';\nimport {ORDINAL} from '../type';\nimport {LAYOUT} from '../data';\nimport {SOURCE} from '../data';\n\nimport {parseAxisComponent} from './axis';\nimport {buildModel} from './common';\nimport {assembleData, parseRepeatData} from './data/data';\nimport {assembleLayout, parseRepeatLayout} from './layout';\nimport {Model} from './model';\nimport {parseScaleComponent, ScaleComponents} from './scale';\nimport * as selections from './selections';\n\nexport type RepeatValues = {\n  row: string,\n  column: string\n}\n\nexport class RepeatModel extends Model {\n  private _repeat: Repeat;\n\n  constructor(spec: RepeatSpec, parent: Model, parentGivenName: string, repeatValues: RepeatValues) {\n    super(spec, parent, parentGivenName, repeatValues);\n\n    // Config must be initialized before child as it gets cascaded to the child\n    const config = this._config = this._initConfig(spec.config, parent);\n\n    const repeat  = this._repeat = spec.repeat;\n    this._children = this._initChildren(spec, repeat, repeatValues);\n    this._scale  = this._initScale(repeat, config);\n    this._axis = {};\n  }\n\n  private _initConfig(specConfig: Config, parent: Model) {\n    return mergeDeep(duplicate(defaultConfig), specConfig, parent ? parent.config() : {});\n  }\n\n  private _initScale(repeat: Repeat, config: Config): Dict<Scale> {\n    return [ROW, COLUMN].reduce(function(_scale, channel) {\n      if (channel in repeat) {\n        _scale[channel] = extend({\n          type: ScaleType.ORDINAL,\n          round: config.facet.scale.round,  // TODO(kanitw): separate `config.repeat` from  `config.facet`\n          domain: repeat[channel],\n\n          padding: 60  // TODO(kanitw): put in `config.repeat` from  `config.facet`\n        }, {});\n      }\n      return _scale;\n    }, {} as Dict<Scale>);\n  }\n\n  private _initChildren(spec: RepeatSpec, repeat: Repeat, repeatValues: RepeatValues): Model[] {\n    let children = [];\n    const row = repeat.row || [repeatValues ? repeatValues.row : null];\n    const column = repeat.column || [repeatValues ? repeatValues.column : null];\n\n    // cross product\n    for (let r = 0; r < row.length; r++) {\n      const rowField = row[r];\n      for (let c = 0; c < column.length; c++) {\n        const columnField = column[c];\n\n        const name = (rowField ? '_' + rowField : '') + (columnField ? '_' + columnField : '');\n\n        const childRepRepeatValues = {\n          row: rowField,\n          column: columnField\n        };\n\n        children.push(buildModel(duplicate(spec.spec), this, this.name('child' + name), childRepRepeatValues));\n      }\n    }\n\n    return children;\n  }\n\n  public repeat() {\n    return this._repeat;\n  }\n\n  public hasMultipleDimensions() {\n    return this.has(ROW) && this.has(COLUMN);\n  }\n\n  public has(channel: Channel): boolean {\n    return !!this._repeat[channel];\n  }\n\n  public dataTable(): string {\n    // FIXME: remove this hack\n    return this.dataName(SOURCE);\n  }\n\n  public isRepeatRef(channel: Channel) {\n    // todo\n    return false;\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    return {\n      type: ORDINAL\n    };\n  }\n\n  public stack() {\n    return null; // this is only a property for UnitModel\n  }\n\n  public parseSelection() {\n    this._children.forEach((child) => child.parseSelection());\n  }\n\n  public parseData() {\n    this._children.forEach((child) => {\n      child.parseData();\n    });\n    this.component.data = parseRepeatData(this);\n  }\n\n  public parseLayoutData() {\n    this._children.forEach((child, i) => {\n      child.parseLayoutData();\n    });\n    this.component.layout = parseRepeatLayout(this);\n  }\n\n  public parseScale() {\n    // TODO(kanitw): move this logic to scale.ts for readability & comparability?\n\n    const model = this;\n\n    // First, add scale for row and column.\n    let scaleComponent = this.component.scale = parseScaleComponent(this);\n\n    this._children.forEach(function(child) {\n      child.parseScale();\n      // move all scales up, merge all but x and y scales\n\n      forEach(child.component.scale, function(childScales: ScaleComponents, key: string) {\n        const channel = childScales.channel;\n\n        if (contains([X, Y], channel)) {\n          // positional scales are just appended because they should be independent\n          scaleComponent[child.name(key)] = childScales;\n        } else {\n          const scaleNameWithoutPrefix = childScales.main.name.substr(child.name('').length);\n          const newName = model.scaleName(scaleNameWithoutPrefix);\n          const oldName = childScales.main.name;\n\n          if (channel in scaleComponent) {\n            // scale already exists, so merge\n\n            // const modelScales = scaleComponent[channel];\n            // TODO: merge scales, I'm too lazy right now and we don't need it for the examples\n          } else {\n            childScales.main.name = newName;\n            scaleComponent[channel] = childScales;\n          }\n          child.renameScale(oldName, newName);\n        }\n\n        // Once put in parent, just remove the child's scale.\n        delete child.component.scale[key];\n      });\n    });\n  }\n\n  public parseMark() {\n    this._children.forEach(function(child) {\n      child.parseMark();\n    });\n  }\n\n  public parseAxis() {\n    this._children.forEach(function(child) {\n      child.parseAxis();\n    });\n    this.component.axis = parseAxisComponent(this, [ROW, COLUMN]);\n  }\n\n  public parseAxisGroup() {\n    return null;\n  }\n\n  public parseGridGroup() {\n    return null;\n  }\n\n  public parseLegend() {\n    let legendComponent = this.component.legend = {} as Dict<VgLegend>;\n\n    this._children.forEach(function(child) {\n      child.parseLegend();\n\n      // TODO: merge one legend per channel + field\n      keys(child.component.legend).forEach(function(channel) {\n        // just use the first legend definition for each channel\n        if (!legendComponent[channel]) {\n          legendComponent[channel] = child.component.legend[channel];\n        }\n        delete child.component.legend[channel];\n      });\n    });\n  }\n\n  public assembleParentGroupProperties() {\n    return null;\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    assembleData(this, data);\n    this._children.forEach((child) => {\n      child.assembleData(data);\n    });\n    return data;\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    // Postfix traversal – layout is assembled bottom-up\n    this._children.forEach((child) => {\n      child.assembleLayout(layoutData);\n    });\n    return assembleLayout(this, layoutData);\n  }\n\n  public assemblePreSelectionData(data: VgData[]): VgData[] {\n    this._children.forEach((child) => child.assemblePreSelectionData(data));\n    return selections.assembleCompositeData(this, data);\n  }\n\n  public assemblePostSelectionData(data: VgData[]): VgData[] {\n    this._children.forEach((child) => child.assemblePostSelectionData(data));\n    return selections.assembleCompositeData(this, data);\n  }\n\n  public assembleSignals(signals) {\n    this._children.forEach((child) => child.assembleSignals(signals));\n    return selections.assembleCompositeSignals(this, signals);\n  }\n\n  public assembleMarks(): any[] {\n    // only children have marks\n    return flatten(this._children.map((child) => {\n      return extend(\n        {\n          name: child.name('cell'),\n          type: 'group',\n          from: {data: child.dataName(LAYOUT)},\n          properties: {\n            update: getRepeatGroupProperties(this, child)\n          }\n        },\n        // Call child's assembleGroup to add marks and axes (legends and scales should have been moved up).\n        // Note that we can call child's assembleGroup() here because parseMark()\n        // is the last method in compile() and thus the child is completely compiled\n        // at this point.\n        child.assembleGroup()\n      );\n    }));\n  }\n\n  public channels() {\n    return [ROW, COLUMN];\n  }\n\n  protected mapping() {\n    return this.repeat();\n  }\n\n  public isRepeat() {\n    return true;\n  }\n}\n\n// TODO: move into RepeatModel if possible\n\nfunction getRepeatGroupProperties(model: RepeatModel, child: Model) {\n  const mergedCellConfig = extend({}, child.config().cell, child.config().facet.cell);\n\n  return extend({\n      x: model.has(COLUMN) ? {\n          scale: model.scaleName(COLUMN),\n          value: child.repeatValue(COLUMN),\n          // offset by the padding\n          offset: model.scale(COLUMN).padding / 2\n        } : {value: model.config().facet.scale.padding / 2},\n\n      y: model.has(ROW) ? {\n        scale: model.scaleName(ROW),\n        value: child.repeatValue(ROW),\n        // offset by the padding\n        offset: model.scale(ROW).padding / 2\n      } : {value: model.config().facet.scale.padding / 2},\n\n      width: {field: child.sizeName('width')},\n      height: {field: child.sizeName('height')}\n    },\n    child.assembleParentGroupProperties(mergedCellConfig)\n  );\n}\n",
    "// https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#11-ambient-declarations\ndeclare var exports;\n\nimport {SHARED_DOMAIN_OPS} from '../aggregate';\nimport {COLUMN, ROW, X, Y, SHAPE, SIZE, COLOR, TEXT, hasScale, Channel} from '../channel';\nimport {StackOffset} from '../config';\nimport {SOURCE, STACKED_SCALE} from '../data';\nimport {FieldDef, field, isMeasure, isRepeatRef} from '../fielddef';\nimport {Mark, BAR, TEXT as TEXT_MARK, RULE} from '../mark';\nimport {Scale, ScaleType, NiceTime} from '../scale';\nimport {TimeUnit} from '../timeunit';\nimport {NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL} from '../type';\nimport {contains, extend, Dict, flatten} from '../util';\nimport {VgScale} from '../vega.schema';\n\nimport {Model, isUnitModel} from './model';\nimport {rawDomain, smallestUnit} from './time';\nimport {UnitModel} from './unit';\nimport {storeName} from './selections';\n\n/**\n * Color Ramp's scale for legends.  This scale has to be ordinal so that its\n * legends show a list of numbers.\n */\nexport const COLOR_LEGEND = 'color_legend';\n\n// scale used to get labels for binned color scales\nexport const COLOR_LEGEND_LABEL = 'color_legend_label';\n\n\n// FIXME: With layer and concat, scaleComponent should decompose between\n// ScaleSignature and ScaleDomain[].\n// Basically, if two unit specs has the same scale, signature for a particular channel,\n// the scale can be unioned by combining the domain.\nexport type ScaleComponent = VgScale;\n\nexport type ScaleComponents = {\n  // chat channel are these scales for\n  channel: Channel,\n\n  // the scales\n  main: ScaleComponent;\n  colorLegend?: ScaleComponent,\n  binColorLegend?: ScaleComponent\n}\n\nexport function parseScaleComponent(model: Model): Dict<ScaleComponents> {\n  return model.channels().reduce(function(scale: Dict<ScaleComponents>, channel: Channel) {\n    if (model.scale(channel)) {\n      const fieldDef = model.fieldDef(channel);\n      const scales: ScaleComponents = {\n        channel: channel,\n        main: parseMainScale(model, fieldDef, channel)\n      };\n\n      // Add additional scales needed to support ordinal legends (list of values)\n      // for color ramp.\n      if (channel === COLOR && model.legend(COLOR) && (fieldDef.type === ORDINAL || fieldDef.bin || fieldDef.timeUnit)) {\n        scales.colorLegend = parseColorLegendScale(model, fieldDef);\n        if (fieldDef.bin) {\n          scales.binColorLegend = parseBinColorLegendLabel(model, fieldDef);\n        }\n      }\n\n      scale[channel] = scales;\n    }\n    return scale;\n  }, {} as Dict<ScaleComponents>);\n}\n\n\n/**\n * Return the main scale for each channel.  (Only color can have multiple scales.)\n */\nfunction parseMainScale(model: Model, fieldDef: FieldDef, channel: Channel) {\n  const scale = model.scale(channel);\n  const sort = model.sort(channel);\n\n  let scaleDef: any = {\n    name: model.scaleName(channel),\n    type: scale.type,\n  };\n\n  scaleDef.domain = domain(scale, model, channel);\n  extend(scaleDef, rangeMixins(scale, model, channel));\n\n  if (sort && (typeof sort === 'string' ? sort : sort.order) === 'descending') {\n    scaleDef.reverse = true;\n  }\n\n  // Add optional properties\n  [\n    // general properties\n    'round',\n    // quantitative / time\n    'clamp', 'nice',\n    // quantitative\n    'exponent', 'zero',\n    // ordinal\n    'padding', 'points'\n  ].forEach(function(property) {\n    const value = exports[property](scale, channel, fieldDef, model);\n    if (value !== undefined) {\n      scaleDef[property] = value;\n    }\n  });\n\n  return scaleDef;\n}\n\n/**\n *  Return a scale  for producing ordinal scale for legends.\n *  - For an ordinal field, provide an ordinal scale that maps rank values to field value\n *  - For a field with bin or timeUnit, provide an identity ordinal scale\n *    (mapping the field values to themselves)\n */\nfunction parseColorLegendScale(model: Model, fieldDef: FieldDef): ScaleComponent {\n  return {\n    name: model.scaleName(COLOR_LEGEND),\n    type: ScaleType.ORDINAL,\n    domain: {\n      data: model.dataTable(),\n      // use rank_<field> for ordinal type, for bin and timeUnit use default field\n      field: model.field(COLOR, (fieldDef.bin || fieldDef.timeUnit) ? {} : {prefn: 'rank_'}),\n      sort: true\n    },\n    range: {data: model.dataTable(), field: model.field(COLOR), sort: true}\n  };\n}\n\n/**\n *  Return an additional scale for bin labels because we need to map bin_start to bin_range in legends\n */\nfunction parseBinColorLegendLabel(model: Model, fieldDef: FieldDef): ScaleComponent {\n  return {\n    name: model.scaleName(COLOR_LEGEND_LABEL),\n    type: ScaleType.ORDINAL,\n    domain: {\n      data: model.dataTable(),\n      field: model.field(COLOR),\n      sort: true\n    },\n    range: {\n      data: model.dataTable(),\n      field: model.field(COLOR, {binSuffix: '_range'}),\n      sort: {\n        field: model.field(COLOR, { binSuffix: '_start' }),\n        op: 'min' // min or max doesn't matter since same _range would have the same _start\n      }\n    }\n  };\n}\n\nexport function scaleType(scale: Scale, fieldDef: FieldDef, channel: Channel, mark: Mark): ScaleType {\n  if (!hasScale(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n\n  // We can't use linear/time for row, column or shape\n  if (contains([ROW, COLUMN, SHAPE], channel)) {\n    return ScaleType.ORDINAL;\n  }\n\n  if (scale.type !== undefined) {\n    return scale.type;\n  }\n\n  switch (fieldDef.type) {\n    case NOMINAL:\n      return ScaleType.ORDINAL;\n    case ORDINAL:\n      if (channel === COLOR) {\n        return ScaleType.LINEAR; // time has order, so use interpolated ordinal color scale.\n      }\n      return ScaleType.ORDINAL;\n    case TEMPORAL:\n      if (channel === COLOR) {\n        return ScaleType.TIME; // time has order, so use interpolated ordinal color scale.\n      }\n\n      if (fieldDef.timeUnit) {\n        switch (fieldDef.timeUnit) {\n          case TimeUnit.HOURS:\n          case TimeUnit.DAY:\n          case TimeUnit.MONTH:\n            return ScaleType.ORDINAL;\n          default:\n            // date, year, minute, second, yearmonth, monthday, ...\n            return ScaleType.TIME;\n        }\n      }\n      return ScaleType.TIME;\n\n    case QUANTITATIVE:\n      if (fieldDef.bin) {\n        return contains([X, Y, COLOR], channel) ? ScaleType.LINEAR : ScaleType.ORDINAL;\n      }\n      return ScaleType.LINEAR;\n  }\n\n  // should never reach this\n  return null;\n}\n\nexport function domain(scale: Scale, model: Model, channel:Channel): any {\n  const fieldDef = model.fieldDef(channel);\n  if (scale.domain) { // explicit value\n    if (scale.domain.selection && isUnitModel(model)) {\n      const sel = model.selection(scale.domain.selection);\n      sel._marks = model;\n      return {\n        data: storeName(sel),\n        field: flatten(sel.project.filter((p) => p.channel === channel)\n          .map((p) => ['min_' + p.field, 'max_' + p.field]))\n      }\n    } else {\n      return scale.domain;\n    }\n  }\n\n  // special case for temporal scale\n  if (fieldDef.type === TEMPORAL) {\n    if (rawDomain(fieldDef.timeUnit, channel)) {\n      return {\n        data: fieldDef.timeUnit,\n        field: 'date'\n      };\n    }\n\n    return {\n      data: model.dataTable(),\n      field: model.field(channel),\n      sort: {\n        field: model.field(channel),\n        op: 'min'\n      }\n    };\n  }\n\n  // For stack, use STACKED data.\n  const stack = model.stack();\n  if (stack && channel === stack.fieldChannel) {\n    if(stack.offset === StackOffset.NORMALIZE) {\n      return [0, 1];\n    }\n    return {\n      data: model.dataName(STACKED_SCALE),\n      // STACKED_SCALE produces sum of the field's value e.g., sum of sum, sum of distinct\n      field: model.field(channel, {prefn: 'sum_'})\n    };\n  }\n\n  const includeRawDomain = _includeRawDomain(scale, model, channel),\n  sort = domainSort(model, channel, scale.type);\n\n  if (includeRawDomain) { // includeRawDomain - only Q/T\n    return {\n      data: SOURCE,\n      field: model.field(channel, {noAggregate: true})\n    };\n  } else if (fieldDef.bin) { // bin\n    return scale.type === ScaleType.ORDINAL ? {\n      // ordinal bin scale takes domain from bin_range, ordered by bin_start\n      data: model.dataTable(),\n      field: model.field(channel, { binSuffix: '_range' }),\n      sort: {\n        field: model.field(channel, { binSuffix: '_start' }),\n        op: 'min' // min or max doesn't matter since same _range would have the same _start\n      }\n    } : channel === COLOR ? {\n      // Currently, binned on color uses linear scale and thus use _start point\n      data: model.dataTable(),\n      field: model.field(channel, { binSuffix: '_start' })\n    } : {\n      // other linear bin scale merges both bin_start and bin_end for non-ordinal scale\n      data: model.dataTable(),\n      field: [\n        model.field(channel, { binSuffix: '_start' }),\n        model.field(channel, { binSuffix: '_end' })\n      ]\n    };\n  } else if (sort) { // have sort -- only for ordinal\n    return {\n      // If sort by aggregation of a specified sort field, we need to use SOURCE table,\n      // so we can aggregate values for the scale independently from the main aggregation.\n      data: sort.op ? SOURCE : model.dataTable(),\n      field: (fieldDef.type === ORDINAL && channel === COLOR) ? model.field(channel, {prefn: 'rank_'}) : model.field(channel),\n      sort: sort\n    };\n  } else {\n    return {\n      data: model.dataTable(),\n      field: (fieldDef.type === ORDINAL && channel === COLOR) ? model.field(channel, {prefn: 'rank_'}) : model.field(channel),\n    };\n  }\n}\n\nexport function domainSort(model: Model, channel: Channel, scaleType: ScaleType): any {\n  if (scaleType !== ScaleType.ORDINAL) {\n    return undefined;\n  }\n\n  const sort = model.sort(channel);\n  if (contains(['ascending', 'descending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (typeof sort !== 'string') {\n    return {\n      op: sort.op,\n      field: sort.field\n    };\n  }\n\n  // sort === 'none'\n  return undefined;\n}\n\n\n/**\n * Determine if includeRawDomain should be activated for this scale.\n * @return {Boolean} Returns true if all of the following conditons applies:\n * 1. `includeRawDomain` is enabled either through scale or config\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nfunction _includeRawDomain (scale: Scale, model: Model, channel: Channel) {\n  const fieldDef = model.fieldDef(channel);\n\n  return scale.includeRawDomain && //  if includeRawDomain is enabled\n    // only applied to aggregate table\n    fieldDef.aggregate &&\n    // only activated if used with aggregate functions that produces values ranging in the domain of the source data\n    SHARED_DOMAIN_OPS.indexOf(fieldDef.aggregate) >= 0 &&\n    (\n      // Q always uses quantitative scale except when it's binned.\n      // Binned field has similar values in both the source table and the summary table\n      // but the summary table has fewer values, therefore binned fields draw\n      // domain values from the summary table.\n      (fieldDef.type === QUANTITATIVE && !fieldDef.bin) ||\n      // T uses non-ordinal scale when there's no unit or when the unit is not ordinal.\n      (fieldDef.type === TEMPORAL && contains([ScaleType.TIME, ScaleType.UTC], scale.type))\n    );\n}\n\n\nexport function rangeMixins(scale: Scale, model: Model, channel: Channel): any {\n  // TODO: need to add rule for quantile, quantize, threshold scale\n\n  const fieldDef = model.fieldDef(channel),\n  scaleConfig = model.config().scale;\n\n  if (scale.type === ScaleType.ORDINAL && scale.bandSize && contains([X, Y], channel)) {\n    return {bandSize: scale.bandSize};\n  }\n\n  if (scale.range && !contains([X, Y, ROW, COLUMN], channel)) {\n    // explicit value (Do not allow explicit values for X, Y, ROW, COLUMN)\n    return {range: scale.range};\n  }\n  switch (channel) {\n    case ROW:\n      return {range: 'height'};\n    case COLUMN:\n      return {range: 'width'};\n  }\n\n  // If not ROW / COLUMN, we can assume that this is a unit spec.\n  const unitModel = model as UnitModel;\n  switch (channel) {\n    case X:\n      // we can't use {range: \"width\"} here since we put scale in the root group\n      // not inside the cell, so scale is reusable for axes group\n\n      return {\n        rangeMin: 0,\n        rangeMax: unitModel.config().cell.width // Fixed cell width for non-ordinal\n      };\n    case Y:\n      return {\n        rangeMin: unitModel.config().cell.height, // Fixed cell height for non-ordinal\n        rangeMax: 0\n      };\n    case SIZE:\n\n      if (unitModel.mark() === BAR) {\n        if (scaleConfig.barSizeRange !== undefined) {\n          return {range: scaleConfig.barSizeRange};\n        }\n        const dimension = model.config().mark.orient === 'horizontal' ? Y : X;\n        return {range: [model.config().mark.barThinSize, model.scale(dimension).bandSize]};\n      } else if (unitModel.mark() === TEXT_MARK) {\n        return {range: scaleConfig.fontSizeRange };\n      } else if (unitModel.mark() === RULE) {\n        return {range: scaleConfig.ruleSizeRange };\n      }\n      // else -- point, square, circle\n      if (scaleConfig.pointSizeRange !== undefined) {\n        return {range: scaleConfig.pointSizeRange};\n      }\n\n      const xIsMeasure = isMeasure(unitModel.encoding().x);\n      const yIsMeasure = isMeasure(unitModel.encoding().y);\n\n      const bandSize = xIsMeasure !== yIsMeasure ?\n        model.scale(xIsMeasure ? Y : X).bandSize :\n        Math.min(\n          model.scale(X).bandSize || scaleConfig.bandSize,\n          model.scale(Y).bandSize || scaleConfig.bandSize\n        );\n\n      return {range: [9, (bandSize - 2) * (bandSize - 2)]};\n    case SHAPE:\n      return {range: scaleConfig.shapeRange};\n    case COLOR:\n      if (fieldDef.type === NOMINAL) {\n        return {range: scaleConfig.nominalColorRange};\n      }\n      // else -- ordinal, time, or quantitative\n      return {range: scaleConfig.sequentialColorRange};\n  }\n  return {};\n}\n\nexport function clamp(scale: Scale) {\n  // Only works for scale with both continuous domain continuous range\n  // (Doesn't work for quantize, quantile, threshold, ordinal)\n  if (contains([ScaleType.LINEAR, ScaleType.POW, ScaleType.SQRT,\n        ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scale.type)) {\n    return scale.clamp;\n  }\n  return undefined;\n}\n\nexport function exponent(scale: Scale) {\n  if (scale.type === ScaleType.POW) {\n    return scale.exponent;\n  }\n  return undefined;\n}\n\nexport function nice(scale: Scale, channel: Channel, fieldDef: FieldDef): boolean | NiceTime {\n  if (contains([ScaleType.LINEAR, ScaleType.POW, ScaleType.SQRT, ScaleType.LOG,\n        ScaleType.TIME, ScaleType.UTC, ScaleType.QUANTIZE], scale.type)) {\n    if (scale.nice !== undefined) {\n      return scale.nice;\n    }\n    if (contains([ScaleType.TIME, ScaleType.UTC], scale.type)) {\n      return smallestUnit(fieldDef.timeUnit) as any;\n    }\n    return contains([X, Y], channel); // return true for quantitative X/Y\n  }\n  return undefined;\n}\n\n\nexport function padding(scale: Scale, channel: Channel) {\n  /* Padding is only allowed for X and Y.\n   *\n   * Basically it doesn't make sense to add padding for color and size.\n   *\n   * We do not use d3 scale's padding for row/column because padding there\n   * is a ratio ([0, 1]) and it causes the padding to be decimals.\n   * Therefore, we manually calculate padding in the layout by ourselves.\n   */\n  if (scale.type === ScaleType.ORDINAL && contains([X, Y], channel)) {\n    return scale.padding;\n  }\n  return undefined;\n}\n\nexport function points(scale: Scale, channel: Channel, __, model: Model) {\n  if (scale.type === ScaleType.ORDINAL && contains([X, Y], channel)) {\n    // We always use ordinal point scale for x and y.\n    // Thus `points` isn't included in the scale's schema.\n    return true;\n  }\n  return undefined;\n}\n\nexport function round(scale: Scale, channel: Channel) {\n  if (contains([X, Y, ROW, COLUMN, SIZE], channel) && scale.round !== undefined) {\n    return scale.round;\n  }\n\n  return undefined;\n}\n\nexport function zero(scale: Scale, channel: Channel, fieldDef: FieldDef) {\n  // only applicable for non-ordinal scale\n  if (!contains([ScaleType.TIME, ScaleType.UTC, ScaleType.ORDINAL], scale.type)) {\n    if (scale.zero !== undefined) {\n      return scale.zero;\n    }\n    // By default, return true only for non-binned, quantitative x-scale or y-scale.\n    return !fieldDef.bin && contains([X, Y], channel);\n  }\n  return undefined;\n}\n",
    "import {UnitModel} from '../unit';\nimport * as u from '../../util';\nimport * as tx from './transforms';\nimport {parse as parseEvtSelector} from 'vega-event-selector';\nimport {Model, isLayerModel} from '../model';\nimport {AREA, LINE} from '../../mark';\nexport {tx as transforms};\nconst transforms = u.keys(tx);\n\nexport enum Types {\n  POINT = 'point' as any,\n  SET = 'set' as any\n}\n\nexport enum Levels {\n  DATA   = 'data'   as any,\n  VISUAL = 'visual' as any\n}\n\nexport enum Resolutions {\n  SINGLE = 'single' as any,\n  INDEPENDENT = 'independent' as any,\n  UNION  = 'union'  as any,\n  INTERSECT = 'intersect' as any,\n  UNION_OTHERS = 'union_others' as any,\n  INTERSECT_OTHERS = 'intersect_others' as any\n}\n\nexport interface Selection {\n  name:  string;\n  _name: string;\n  _model: Model;\n  _marks: Model;  // HACK to assembleMark for O+D detail unit.\n  type:  Types;\n  level: Levels;\n  on: string;\n  predicate: string;\n  resolve?: Resolutions;\n\n  // Transforms\n  project?: any;\n  toggle?: any;\n  scales?: any;\n  interval?: any;\n  translate?: any;\n  zoom?: any;\n  nearest?: any;\n}\n\nexport function modelName(model: UnitModel) {\n  var parent = model.parent(),\n      mark = model.mark();\n  return parent && isLayerModel(parent) && /*mark !== AREA && */mark !== LINE ?\n    parent.name.bind(parent) : model.name.bind(model);\n}\n\nexport function storeName(sel: Selection) {\n  return sel.name + (sel.type === Types.SET ? '_db' : '');\n}\n\n// Namespace triggering events to occur in a specific unit\nexport function eventName(model: UnitModel, event?) {\n  event = event || '';\n  var mark = model.mark(),\n    cell = model.parent() ?\n      /*mark === AREA || */mark === LINE ? 'pathgroup' : 'cell' :\n      'root';\n\n  return event.indexOf(':') < 0 ?\n    '@' + modelName(model)(cell) + ':' + event : event;\n}\n\n// \"Namespace\" expressions such that they're only evaluated in a specific unit\nexport function expr(model, datum, name, expr) {\n  return 'if(' + datum + '.unitName === ' + u.str(modelName(model)()) + ', ' +\n    expr + ', ' + name + ')';\n}\n\nexport function parse(model: UnitModel, spec) {\n  return u.keys(spec).map(function(k) {\n    var sel:Selection = spec[k];\n    if (sel.name) return sel;\n\n    // Set default properties and instantiate default transforms.\n    // We don't namespace the selection to facilitate merging during assembly.\n    sel.resolve = sel.resolve || Resolutions.SINGLE;\n    sel.level = sel.level || Levels.DATA;\n    sel.name  = sel.resolve === Resolutions.SINGLE ? k : model.name(k);\n    sel._name = k;\n    sel._model = model;\n    parseSelectionType(model, sel);\n\n    // Parse transformations.\n    transforms.forEach(function(k) {\n      if (!tx[k].parse || !sel[k]) return;\n      tx[k].parse(model, sel);\n    });\n\n    return sel;\n  });\n}\n\n// HACK FOR INFOVIS: Maps new syntax to old syntax.\n// TODO: Migrate selections codebase to new syntax entirely.\nfunction parseSelectionType(model: Model, sel) {\n  if (sel.type === 'list') {\n    sel.type = Types.SET;\n    sel.toggle = sel.toggle || true;\n  } else if (sel.type === 'interval') {\n    sel.type = Types.SET;\n    if (sel.init && sel.init.scales) {\n      sel.scales = true;\n    } else {\n      sel.interval = true;\n    }\n  }\n\n  if (!sel.project) {\n    sel.project = (sel.scales || sel.interval) ?\n      { channels: ['x', 'y'] } : { fields: ['_id'] };\n  }\n}\n\nexport function assembleEvent(model: UnitModel, sel: Selection) {\n  if (sel.on) {\n    var on = parseEvtSelector(sel.on);\n    return on.map(function(s) {\n      if (s.event) {\n        return eventName(model, s.event);\n      } else if (s.start && s.start.event) {\n        return '[' + eventName(model, s.start.str) + ', ' + s.end.str + '] > ' + s.middle.str;\n      }\n    }).join(', ');\n  } else {\n    return eventName(model, 'click');\n  }\n}\n\nexport function assembleUnitSignals(model: UnitModel, signals) {\n  var unit = !signals.length;\n\n  model.selection().forEach(function(sel: Selection) {\n    if (sel._model !== model) return;\n    var on = assembleEvent(model, sel);\n\n    var trigger = {\n      name: sel.name,\n      verbose: true,  // TODO: how do we do better than this?\n      init: {},\n      streams: [{type: on, expr: ''}]\n    };\n\n    var clear = {\n      name: sel.name + '_clear',\n      verbose: true,\n      init: true,\n      streams: [\n        {type: on, expr: 'true'}\n      ]\n    };\n\n    transforms.forEach(function(k) {\n      if (!tx[k].assembleSignals || !sel[k]) return;\n      tx[k].assembleSignals(model, sel, trigger, clear, signals);\n    });\n\n    if (trigger.name) signals.push(trigger);\n\n    // We only need the clear signal if we're using a points store.\n    // Transforms can clear out signal names to not have them added.\n    if (sel.type === Types.SET && clear.name) {\n      signals.push(clear);\n    }\n  });\n\n  // TODO: Get correct name for unit's enclosing group (where scales are defined).\n  if (unit) {\n    signals.unshift({\n      name: 'unit',\n      init: { _id: -1, width: 1, height: 1 },\n      streams: [{\n        type: 'mousemove',\n        expr: 'eventGroup()'\n      }]\n    });\n  }\n\n  return signals;\n}\n\nexport function assembleCompositeSignals(model, units) {\n  var signals = {}, registry = {}, h;\n\n  units.forEach(function(unit) {\n    var s = signals[unit.name],\n        r = registry[unit.name] || (registry[unit.name] = {});\n    if (s && s.name !== 'unit') {\n      unit.streams.forEach(function(stream) {\n        if (!r[h=u.hash(stream)]) {\n          s.streams.push(stream);\n          r[h] = true;\n        }\n      });\n    } else {\n      signals[unit.name] = unit;\n      unit.streams.forEach((stream) => r[u.hash(stream)] = true);\n    }\n  });\n\n  return u.vals(signals);\n}\n\nexport function assembleUnitData(model: UnitModel, data, pre) {\n  model.selection().forEach(function(sel: Selection) {\n    if (sel.type !== Types.SET) return;\n    if (sel._model !== model) return;\n\n    // Compile scales selections after source data\n    if ((pre && sel.scales) || (!pre && !sel.scales)) return;\n    var db = {\n      name: storeName(sel),\n      transform: [],\n      modify: [\n        {type: 'clear', test: sel.name + '_clear'}\n      ]\n    };\n\n    transforms.forEach(function(k) {\n      if (!tx[k].assembleData || !sel[k]) return;\n      tx[k].assembleData(model, sel, db, data);\n    });\n\n    data.unshift(db);\n  });\n  return data;\n}\n\nexport function assembleCompositeData(model, units) {\n  var data = {}, registry = {};\n\n  units.forEach(function(unit) {\n    var d = data[unit.name],\n        r = registry[unit.name] || (registry[unit.name] = {}),\n        h;\n\n\n    function mergeTransforms(t) {\n      if (t.type === 'aggregate') {\n        if (!r.aggregate) {\n          d.transform.push(r.aggregate = t);\n        }\n\n        u.extend(r.aggregate.summarize, t.summarize);\n      } else if (!r[h=u.hash(t)]) {\n        d.transform.push(t);\n        r[h] = true;\n      }\n    };\n\n    function populateRegistry(t) {\n      if (t.type === 'aggregate') r.aggregate = t;\n      else r[u.hash(t)] = true;\n    }\n\n    if (!d) {\n      unit.transform.forEach(populateRegistry);\n      unit.modify.forEach(populateRegistry);\n      return (data[unit.name] = unit);\n    } else {\n      unit.transform.forEach(mergeTransforms);\n      unit.modify.forEach(mergeTransforms);\n    }\n  });\n\n  return u.vals(data);\n}\n\nexport function assembleMarks(model: UnitModel, marks: any[]) {\n  var children = marks;\n  model.selection().forEach(function(sel: Selection) {\n    if (sel._model !== model && sel._marks !== model) return;\n    transforms.forEach(function(k) {\n      if (!tx[k].assembleMarks || !sel[k]) return;\n      children = tx[k].assembleMarks(model, sel, marks, children);\n    });\n  });\n  return marks;\n}",
    "import {UnitModel} from '../unit';\nimport {X, Y} from '../../channel';\nimport * as s from './';\nimport * as u from '../../util';\nimport {parse as parseEvtSelector} from 'vega-event-selector';\n\nvar START = 'min_', END = 'max_', SIZE = 'size_';\n\nexport function brushName(sel: s.Selection) {\n  return sel.name + '_brush';\n}\n\nexport function brushFilter() {\n  return '[!eventItem().isBrush]';\n}\n\nfunction startName(sel: s.Selection) {\n  return sel.name + '_start';\n}\n\nfunction endName(sel: s.Selection) {\n  return sel.name + '_end';\n}\n\n// TODO: resolve arg.\nexport function parse(model: UnitModel, sel: s.Selection) {\n  sel.predicate = 'inrangeselection(' + u.str(s.storeName(sel)) +\n    ', datum, ' + u.str(sel.resolve) + ')';\n\n  if (sel.translate === undefined) sel.translate = true;\n}\n\nexport function assembleSignals(model: UnitModel, sel: s.Selection, trigger, clear, signals) {\n  var eventName = s.eventName.bind(null, model), on;\n\n  if (sel.on) {\n    on = parseEvtSelector(s.assembleEvent(model, sel))[0];\n  }\n\n  if (!on || !on.start) {\n    on = '[' + eventName('mousedown') + brushFilter() + ', window:mouseup] > window:mousemove';\n    on = parseEvtSelector(on)[0];\n  } else if (on.start.str) {\n    on.start.str = eventName(on.start.str);\n    if (on.start.str.indexOf(brushFilter()) < 0) on.start.str += brushFilter();\n    on = '[' + on.start.str + ', ' + on.end.str + '] > ' + on.middle.str;\n    on = parseEvtSelector(on)[0];\n  }\n\n  var start = startName(sel), end = endName(sel),\n    expr = '{x: clamp(eventX(unit), 0, unit.width), ' +\n      'y: clamp(eventY(unit), 0, unit.height), unit: unit}',\n    x = null, y = null;\n\n  sel.project.forEach(function(p) {\n    if (p.channel === X) {\n      x = { scale: u.str(model.scaleName(X)), field: p.field };\n    }\n\n    if (p.channel === Y) {\n      y = { scale: u.str(model.scaleName(Y)), field: p.field };\n    }\n  });\n\n  signals.push({\n    name: start,\n    init: { expr: '{unit: unit}' },\n    streams: [{ type: on.start.str, expr: s.expr(model, 'unit', start, expr) }]\n  });\n\n  signals.push({\n    name: end,\n    init: {},\n    streams: [\n      { type: start, expr: start },\n      { type: on.str, expr: s.expr(model, 'unit', end, expr) }\n    ]\n  });\n\n  // Trigger will now contain the data extents of the brush\n  trigger.streams[0] = {\n    type: start + ', ' + end,\n    expr: s.expr(model, 'unit', trigger.name, '{' +\n    (x ? START + x.field + ': iscale(' + x.scale + ', ' + start + '.x, unit), ' : '') +\n    (y ? START + y.field + ': iscale(' + y.scale + ', ' + start + '.y, unit), ' : '') +\n    (x ? END + x.field + ': iscale(' + x.scale + ', ' + end + '.x, unit), ' : '') +\n    (y ? END + y.field + ': iscale(' + y.scale + ', ' + end + '.y, unit), ' : '') +\n    (x ? SIZE + x.field + ': abs(' + start + '.x - ' + end + '.x), ' : '') +\n    (y ? SIZE + y.field + ': abs(' + start + '.y - ' + end + '.y), ' : '') +\n    (x ? 'x: ' + u.str(x.field) + ', ' : '') +\n    (y ? 'y: ' + u.str(y.field) + ', ' : '') +\n    'unitName: unit.unitName}')\n  };\n\n  if (sel.resolve === s.Resolutions.SINGLE) {\n    clear.streams[0].type = start;\n    clear.streams.push({ type: '@' + brushName(sel) + ':' + on.start.event, expr: 'false' });\n    clear.streams.push({ type: '@' + brushName(sel) + ':wheel', expr: 'false' });\n  } else {\n    clear.name = null;  // Brushes are upserted.\n  }\n}\n\nexport function assembleData(model: UnitModel, sel: s.Selection, db) {\n  var upsert = { type: 'upsert', signal: sel.name, field: 'unitName' };\n  if (sel.resolve === s.Resolutions.SINGLE) {\n    db.modify.push(upsert);\n  } else {\n    db.modify = [upsert];\n  }\n}\n\n// TODO: Move to config?\nexport function assembleMarks(model: UnitModel, sel: s.Selection, marks, children) {\n  var x = null, y = null, name = u.str(s.modelName(model)());\n  sel.project.forEach(function(p) {\n    if (p.channel === X) x = p.field;\n    if (p.channel === Y) y = p.field;\n  });\n\n  children.push({\n    name: brushName(sel),\n    type: 'rect',\n    from: { data: s.storeName(sel) },\n    properties: {\n      enter: {\n        isBrush: {value: true},  // To easily identify brushes w/diff names.\n        fill: { value: 'grey' },\n        fillOpacity: { value: 0.2 }\n      },\n      update: {\n        x: [\n          u.extend({test: 'datum.unitName === ' + name},\n            (x ? { scale: model.scaleName(X), field: START+x } : {value:0})),\n          { value: 0 }\n        ],\n        x2: [\n          u.extend({test: 'datum.unitName === ' + name},\n            (x ? { scale: model.scaleName(X), field: END+x } : {field: {group: 'width'}})),\n          { value: 0 }\n        ],\n        y: [\n          u.extend({ test: 'datum.unitName === ' + name },\n            (y ? { scale: model.scaleName(Y), field: START + y } : { value: 0 })),\n          { value: 0 }\n        ],\n        y2: [\n          u.extend({ test: 'datum.unitName === ' + name },\n            (y ? { scale: model.scaleName(Y), field: END + y } : { field: {group: 'height'} })),\n          { value: 0 }\n        ]\n      }\n    }\n  });\n\n  return children;\n}\n",
    "import {UnitModel} from '../unit';\nimport * as s from './';\nimport * as u from '../../util';\n\nexport function parse(_, sel: s.Selection) {\n  if (sel.scales || sel.interval) sel.nearest = false;\n}\n\nexport function assembleMarks(model: UnitModel, sel: s.Selection, _, children) {\n  var modelName = s.modelName(model),\n      name = modelName('marks'),\n      mark = model.mark(),\n      voronoi, marks, pathgroup;\n\n  if (children[0].name === model.name('pathgroup')) {\n    pathgroup = children;\n    children = children[0].marks;\n  }\n\n  for (var i = 0, len = children.length, c; i < len; ++i) {\n    c = children[i];\n    if (c.from.mark) voronoi = c;\n    if (c.name === name) marks = i;\n    if (voronoi && marks) break;\n  }\n\n\n  // Don't add multiple voronois to the same unit\n  if (voronoi) return children;\n\n  // Add the voronoi right after the marks so that we do not interfere with any\n  // additional layers or selections (e.g., brush).\n  children.splice(i, 0, {\n    name: modelName('voronoi'),\n    type: 'path',\n    from: {\n      mark: modelName('marks'),\n      transform: [\n        // {type: 'formula', field: 'mid_x', expr: 'datum.bounds.x1 + (datum.bounds.x2 - datum.bounds.x1)/2'},\n        // {type: 'formula', field: 'mid_y', expr: 'datum.bounds.y1 + (datum.bounds.y2 - datum.bounds.y1)/2'},\n        {type: 'voronoi', x: 'x', y: 'y'}\n      ]\n    },\n    properties: {\n      enter: {\n        isVoronoi: {value: true},\n        fill: {value: 'transparent'}\n      },\n      update: {\n        path: {field: 'layout_path'},\n        stroke: {value: 'transparent'},\n        strokeWidth: {value: 2}\n      }\n    }\n  });\n\n  return children;\n}",
    "import {UnitModel} from '../unit';\nimport * as s from './';\nimport * as u from '../../util';\n\n// _id should be exported as __id to prevent conflicts with Vega tuples.\nexport function fieldName(p) {\n  return p.field === '_id' ? '__id' : p.field;\n}\n\n// TODO: Support s.Levels.VISUAL\nexport function parse(model:UnitModel, sel: s.Selection) {\n  // Fold project definition:\n  // {fields: [], channels: []} --> [{channel: }, {field: }]\n  sel.project = (sel.project.fields || []).map(function(f) { return { field: f }; })\n    .concat((sel.project.channels || []).map(function(c) {\n      return { channel: c, field: model.field(c) };\n    }));\n\n  if (sel.type === s.Types.POINT) {\n    sel.predicate = sel.project.map(function(p) {\n      return 'datum.' + p.field + ' === ' + sel.name + '.' + fieldName(p)\n    }).join(' && ');\n  } else if (sel.type === s.Types.SET) {\n    sel.predicate = sel.project.map(function(p) {\n      return 'indata(' + u.str(s.storeName(sel)) + ', datum.' + p.field +\n        ', ' + u.str(fieldName(p)) + ')';\n    }).join(' && ');\n  }\n}\n\nexport function assembleSignals(model: UnitModel, sel: s.Selection, trigger) {\n  var datum = '(eventItem().isVoronoi ? datum.datum : datum)';\n\n  var expr = sel.project.map(function(p) {\n    return fieldName(p) + ': ' + datum + '.' + p.field;\n  }).join(', ');\n\n  trigger.streams[0].expr = s.expr(model, 'unit', trigger.name,\n    '{unitName: unit.unitName, ' + expr + '}');\n}",
    "import {UnitModel} from '../unit';\nimport * as s from './';\nimport * as u from '../../util';\nimport {domain as scaleDomain, scaleType} from '../scale';\nimport {ScaleType} from '../../scale';\nimport {SOURCE} from '../../data';\n\n// TODO: Support ordinal scales.\nexport function parse(model: UnitModel, sel: s.Selection) {\n  sel.project.forEach(function(p, i) {\n    var channel  = p.channel,\n        fieldDef = model.fieldDef(channel),\n        scale  = model.scale(channel),\n        type   = scaleType(scale, fieldDef, channel, model.mark()),\n        domain = scaleDomain(scale, model, channel),\n        fieldName = domain.field;\n\n    if (type === ScaleType.ORDINAL) return;\n    u.extend(scale, {\n      domain: {\n        data: s.storeName(sel),\n        field: ['min_'+fieldName, 'max_'+fieldName]\n      }\n    });\n\n    sel.project[i].scale = scale;\n  });\n\n  if (sel.translate === undefined) sel.translate = true;\n}\n\nexport function assembleSignals(_, sel: s.Selection, trigger, clear) {\n  // Domain initialized selections don't need any signals.\n  trigger.name = clear.name = null;\n}\n\nexport function assembleData(model: UnitModel, sel: s.Selection, db) {\n  var summarize = sel.project.reduce(function(obj, d) {\n    return (obj[d.field] = ['min', 'max'], obj);\n  }, {});\n\n  db.source = model.dataName(SOURCE);\n  db.transform.push({ type: 'aggregate', summarize: summarize });\n  db.modify.splice(0);   // Domain initialized selections don't need any modifiers.\n}\n\n",
    "import {UnitModel} from '../unit';\nimport * as s from './';\nimport * as u from '../../util';\nimport {fieldName} from './project';\n\nexport function parse(_, sel: s.Selection) {\n  if (sel.type !== s.Types.SET || sel.scales || sel.interval) {\n    return (sel.toggle = null);\n  }\n}\n\nexport function assembleSignals(model: UnitModel, sel: s.Selection, trigger, clear, signals) {\n  // Trigger contains the initial \"on\", which restarts the selections.\n  // Toggle should append an additional stream for toggling.\n  var streams = trigger.streams, expr = streams[0].expr;\n  var on = u.isString(sel.toggle) ?\n    s.eventName(sel.toggle) : s.assembleEvent(model, sel) + '[event.shiftKey]';\n\n  streams.push({ type: on, expr: expr });\n  clear.streams.push({ type: on, expr: 'false' });\n}\n\nexport function assembleData(_, sel: s.Selection, db) {\n  var toggle = { type: 'toggle', signal: sel.name, field: undefined };\n  if (sel.resolve === s.Resolutions.SINGLE) {\n    toggle.field = sel.project.map(function(p) {\n      return fieldName(p);\n    });\n  }\n  db.modify.push(toggle);\n}",
    "import * as project from './project';\nexport {project};\n\nimport * as toggle from './toggle';\nexport {toggle};\n\nimport * as scales from './scales';\nexport {scales};\n\nimport * as interval from './interval';\nexport {interval};\n\nimport * as translate from './translate';\nexport {translate};\n\nimport * as zoom from './zoom';\nexport {zoom};\n\nimport * as nearest from './nearest';\nexport {nearest};",
    "/// <reference path=\"../../../typings/vega.d.ts\"/>\nimport {UnitModel} from '../unit';\nimport * as s from './';\nimport * as u from '../../util';\nimport {parse as parseEvtSelector} from 'vega-event-selector';\nimport {isLayerModel} from '../model';\nimport {brushName, brushFilter} from './interval';\n\nfunction anchorName(sel: s.Selection) {\n  return sel.name + '_translate_anchor';\n}\n\nfunction deltaName(sel: s.Selection) {\n  return sel.name + '_translate_delta';\n}\n\nfunction zeroName(sel: s.Selection) {\n  return sel.name + '_translate_zero';\n}\n\nexport function parse(model: UnitModel, sel: s.Selection) {\n  var md = sel.interval ? '@' + brushName(sel) + ':mousedown' :\n    s.eventName(model, 'mousedown') + brushFilter();\n\n  var trans = sel.translate,\n      on = parseEvtSelector(u.isString(trans) ? trans :\n        '[' + md + ', window:mouseup] > window:mousemove')[0];\n\n  if (!sel.interval && on.start.str.indexOf(brushFilter()) < 0) {\n    on.start.str += brushFilter();\n  }\n\n  on.start.str = s.eventName(model, on.start.str);\n  on.str = '[' + on.start.str + ', ' + on.end.str + '] > ' + on.middle.str;\n  sel.translate = {on: on};\n\n  // Unset scale properties to allow smooth panning.\n  if (sel.scales) {\n    sel.project.forEach(function(p) {\n      u.extend(p.scale, {\n        round: false,  // Rounded scales round inversions too.\n        nice: false,   // Causes \"snapped\" panning.\n        zero: false    // Otherwise only the max extent will vary.\n      });\n    });\n  }\n}\n\nexport function assembleSignals(model: UnitModel, sel: s.Selection, _, __, signals) {\n  var on = sel.translate.on,\n      anchor = anchorName(sel),\n      delta = deltaName(sel),\n      unit = 'unit';\n\n  signals.push({\n    name: delta,\n    init: {x: 0, y: 0},\n    streams: [\n      {\n        type: on.start.str,\n        expr: s.expr(model, unit, delta, '{x: 0, y: 0}')\n      },\n      {\n        type: '[' + on.start.str + ', ' + on.end.str + '] > ' + on.middle.str,\n        expr: s.expr(model, unit, delta, '{x: '+anchor+'.x - eventX(), y: eventY() - '+anchor+'.y}')\n      }\n    ]\n  });\n\n  signals.push({\n    name: anchor,\n    init: {expr: '{unit: unit}'},\n    verbose: true,\n    streams: [\n      {\n        type: on.start.str,\n        expr: s.expr(model, unit, anchor, '{x: eventX(), y: eventY(), unit: unit}')\n      },\n      {\n        type: '[' + on.start.str + ', ' + on.end.str + '] > ' + on.middle.str,\n        expr: s.expr(model, unit, anchor, '{x: eventX(), y: eventY(), unit: '+anchor+'.unit}')\n      }\n    ]\n  });\n}\n\nexport function assembleData(model: UnitModel, sel: s.Selection, db) {\n  var tx = db.transform,\n      name = sel.name,\n      anchor = anchorName(sel),\n      delta = deltaName(sel),\n      unit = anchor + '.unit';\n\n  // The delta is relative to what dimension?\n  var DIMS = {\n    x: unit + '.width',\n    y: unit + '.height'\n  };\n\n  // Translating scales/viewport and brush work in opposite directions.\n  var DIR = {\n    min: sel.scales ? 'min' : 'max',\n    max: sel.scales ? 'max' : 'min'\n  };\n\n  sel.project.forEach(function(p) {\n    var field = p.field,\n      channel = p.channel,\n      n = 'min_' + field,\n      x = 'max_' + field,\n      dmin = 'datum.' + n,\n      dmax = 'datum.' + x,\n      _dmin = 'datum._' + n,\n      _dmax = 'datum._' + x;\n\n    // We need to shim in the delta or brush signals to trigger a reeval\n    var reeval = '((' + delta + '.ts/' + delta + '.ts) || ' +\n      (sel.interval ? '(' + sel.name + '.ts/' + sel.name + '.ts) || ' : '') +\n      '1)';\n\n    var init = '(datum.min_' + field + ', datum.max_' + field + ') * ' + reeval;\n\n    // For intervals, the delta should be interpretted based on the brush size.\n    if (sel.interval) {\n      DIMS[channel] = name + '.size_' + field\n    }\n\n    // To prevent aspect ratio drift, capture the current extents (dmin, dmax)\n    // and use them in the offset calculation (_dmin, _dmax).\n    tx.push.apply(tx, [\n      {\n        type: 'formula',\n        field: '_' + n,\n        expr: s.expr(model, unit, 'datum._' + n, (sel.scales) ? // Start scale at zero if there's no anchor.\n          anchor + '.x ? ' + DIR.min + init + ' : 0' :\n          DIR.min + init)\n      },\n      {\n        type: 'formula',\n        field: '_' + x,\n        expr: s.expr(model, unit, 'datum._' + x,\n          DIR.max + '(datum.max_' + field + ', datum.min_' + field + ') * ' + reeval)\n      },\n      {\n        type: 'formula',\n        field: n,\n        expr: s.expr(model, unit, 'datum.' + n,\n          _dmin + ' + (' + _dmax+'-'+_dmin + ')*'+delta+'.'+channel+'/'+DIMS[channel])\n      },\n      {\n        type: 'formula',\n        field: x,\n        expr: s.expr(model, unit, 'datum.' + x,\n          _dmax + ' + (' + _dmax+'-'+_dmin + ')*'+delta+'.'+channel+'/'+DIMS[channel])\n      }\n    ]);\n  });\n}\n\n// Wrap our marks in a clipped group\nexport function assembleMarks(model: UnitModel, sel: s.Selection, marks: any[], _) {\n  var mark = marks[0],\n    props = mark && mark.properties,\n    up = props && props.update,\n    clip = up && up.clip;\n\n  if (clip) return _;\n\n  var name = s.modelName(model);\n  var children = marks.splice(0);\n  marks.push({\n    name: name('cell'),\n    type: 'group',\n    properties: {\n      enter: {\n        unitName: {value: name()}\n      },\n      update: {\n        width: {field: {group: 'width'}},\n        height: {field: {group: 'height'}},\n        fill: {value: 'transparent'},\n        clip: {value: true}\n      }\n    },\n    marks: children\n  });\n  return children;\n}",
    "import {UnitModel} from '../unit';\nimport {X, Y} from '../../channel';\nimport * as s from './';\nimport * as u from '../../util';\nimport {brushName, brushFilter} from './interval';\n\nfunction anchorName(sel: s.Selection) {\n  return sel.name + '_zoom_anchor';\n}\n\nfunction deltaName(sel: s.Selection) {\n  return sel.name + '_zoom_delta';\n}\n\nexport function assembleSignals(model: UnitModel, sel: s.Selection, trigger, _, signals) {\n  var anchor = anchorName(sel),\n      delta  = deltaName(sel),\n      x = null, y = null;\n  sel.project.forEach(function(p) {\n    if (p.channel === X) {\n      x = { scale: u.str(model.scaleName(X)), field: p.field };\n    }\n\n    if (p.channel === Y) {\n      y = { scale: u.str(model.scaleName(Y)), field: p.field };\n    }\n  });\n\n  var on = (sel.interval ? '@' + brushName(sel) + ':' : s.eventName(model)) + 'wheel' +\n    (!sel.interval ? brushFilter() : '');\n\n  signals.push({\n    name: anchor,\n    init: {expr: '{x: 0, y: 0, unit: unit}'},\n    streams: [{\n      type: on,\n      expr: s.expr(model, 'unit', anchor, '{' +\n       (x ? 'x: iscale(' + x.scale + ', eventX(unit), unit), ' : '') +\n       (y ? 'y: iscale(' + y.scale + ', eventY(unit), unit)' : '') + ', unit: unit}')\n    }]\n  });\n\n  signals.push({\n    name: delta,\n    init: 1.0,\n    streams: [{\n      type: on,\n      expr: s.expr(model, 'unit', delta, 'pow(1.001, event.deltaY*pow(16, event.deltaMode))')\n    }]\n  });\n}\n\nexport function assembleData(model: UnitModel, sel: s.Selection, db) {\n  var tx = db.transform,\n      anchor = anchorName(sel),\n      delta  = deltaName(sel),\n      unit = anchor + '.unit';\n\n  sel.project.forEach(function(p) {\n    var field = p.field,\n      channel = p.channel,\n      anch = anchor + '.' + channel;\n\n    tx.push.apply(tx, [\n      {\n        type:  'formula',\n        field: 'min_' + field,\n        expr: s.expr(model, unit, 'datum.min_' + field,\n          '(datum.min_' + field + ' - ' + anch + ') * ' + delta + ' + ' + anch)\n      },\n      {\n        type:  'formula',\n        field: 'max_' + field,\n        expr: s.expr(model, unit, 'datum.max_' + field,\n          '(datum.max_' + field + ' - ' + anch + ') * ' + delta + ' + ' + anch)\n      },\n    ]);\n  });\n}",
    "import {Encoding} from '../encoding';\nimport {Config} from '../config';\nimport {FieldDef} from '../fielddef';\nimport {Channel, X, Y, COLOR, DETAIL, ORDER} from '../channel';\nimport {Scale, ScaleType} from '../scale';\nimport {StackOffset} from '../config';\nimport {BAR, AREA, Mark} from '../mark';\nimport {field, isMeasure} from '../fielddef';\nimport {has, isAggregate} from '../encoding';\nimport {isArray, contains, Dict} from '../util';\n\nimport {sortField} from './common';\nimport {Model} from './model';\nimport {UnitModel} from './unit';\n\n\nexport interface StackProperties {\n  /** Dimension axis of the stack ('x' or 'y'). */\n  groupbyChannel: Channel;\n  /** Measure axis of the stack ('x' or 'y'). */\n  fieldChannel: Channel;\n\n  /** Stack-by field names (from 'color' and 'detail') */\n  stackFields: string[];\n\n  /** Stack offset property. */\n  offset: StackOffset;\n}\n\n// TODO: put all vega interface in one place\nexport interface StackTransform {\n  type: string;\n  offset?: any;\n  groupby: any;\n  field: any;\n  sortby: any;\n  output: any;\n}\n\n/** Compile stack properties from a given spec */\nexport function compileStackProperties(mark: Mark, encoding: Encoding, scale: Dict<Scale>, config: Config) {\n  const stackFields = getStackFields(mark, encoding, scale);\n\n  if (stackFields.length > 0 &&\n      contains([BAR, AREA], mark) &&\n      config.mark.stacked !== StackOffset.NONE &&\n      isAggregate(encoding)) {\n\n    const isXMeasure = has(encoding, X) && isMeasure(encoding.x),\n    isYMeasure = has(encoding, Y) && isMeasure(encoding.y);\n\n    if (isXMeasure && !isYMeasure) {\n      return {\n        groupbyChannel: Y,\n        fieldChannel: X,\n        stackFields: stackFields,\n        offset: config.mark.stacked\n      };\n    } else if (isYMeasure && !isXMeasure) {\n      return {\n        groupbyChannel: X,\n        fieldChannel: Y,\n        stackFields: stackFields,\n        offset: config.mark.stacked\n      };\n    }\n  }\n  return null;\n}\n\n/** Compile stack-by field names from (from 'color' and 'detail') */\nfunction getStackFields(mark: Mark, encoding: Encoding, scaleMap: Dict<Scale>) {\n  return [COLOR, DETAIL].reduce(function(fields, channel) {\n    const channelEncoding = encoding[channel];\n    if (has(encoding, channel)) {\n      if (isArray(channelEncoding)) {\n        channelEncoding.forEach(function(fieldDef) {\n          fields.push(field(fieldDef));\n        });\n      } else {\n        const fieldDef: FieldDef = channelEncoding;\n        const scale = scaleMap[channel];\n        fields.push(field(fieldDef, {\n          binSuffix: scale && scale.type === ScaleType.ORDINAL ? '_range' : '_start'\n        }));\n      }\n    }\n    return fields;\n  }, []);\n}\n\n// impute data for stacked area\nexport function imputeTransform(model: Model) {\n  const stack = model.stack();\n  return {\n    type: 'impute',\n    field: model.field(stack.fieldChannel),\n    groupby: stack.stackFields,\n    orderby: [model.field(stack.groupbyChannel)],\n    method: 'value',\n    value: 0\n  };\n}\n\nexport function stackTransform(model: UnitModel) {\n  const stack = model.stack();\n  const encoding = model.encoding();\n  const sortby = model.has(ORDER) ?\n    (isArray(encoding[ORDER]) ? encoding[ORDER] : [encoding[ORDER]]).map(sortField) :\n    // default = descending by stackFields\n    stack.stackFields.map(function(field) {\n     return '-' + field;\n    });\n\n  const valName = model.field(stack.fieldChannel);\n\n  // add stack transform to mark\n  let transform: StackTransform = {\n    type: 'stack',\n    groupby: [model.field(stack.groupbyChannel)],\n    field: model.field(stack.fieldChannel),\n    sortby: sortby,\n    output: {\n      start: valName + '_start',\n      end: valName + '_end'\n    }\n  };\n\n  if (stack.offset) {\n    transform.offset = stack.offset;\n  }\n  return transform;\n}\n",
    "import {contains, range} from '../util';\nimport {COLUMN, ROW, SHAPE, COLOR, Channel} from '../channel';\nimport {TimeUnit} from '../timeunit';\n\n/** returns the template name used for axis labels for a time unit */\nexport function format(timeUnit: TimeUnit, abbreviated = false): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  let timeString = timeUnit.toString();\n\n  let dateComponents = [];\n\n  if (timeString.indexOf('year') > -1) {\n    dateComponents.push(abbreviated ? '%y' : '%Y');\n  }\n\n  if (timeString.indexOf('month') > -1) {\n    dateComponents.push(abbreviated ? '%b' : '%B');\n  }\n\n  if (timeString.indexOf('day') > -1) {\n    dateComponents.push(abbreviated ? '%a' : '%A');\n  } else if (timeString.indexOf('date') > -1) {\n    dateComponents.push('%d');\n  }\n\n  let timeComponents = [];\n\n  if (timeString.indexOf('hours') > -1) {\n    timeComponents.push('%H');\n  }\n  if (timeString.indexOf('minutes') > -1) {\n    timeComponents.push('%M');\n  }\n  if (timeString.indexOf('seconds') > -1) {\n    timeComponents.push('%S');\n  }\n  if (timeString.indexOf('milliseconds') > -1) {\n    timeComponents.push('%L');\n  }\n\n  let out = [];\n  if (dateComponents.length > 0) {\n    out.push(dateComponents.join('-'));\n  }\n  if (timeComponents.length > 0) {\n    out.push(timeComponents.join(':'));\n  }\n\n  return out.length > 0 ? out.join(' ') : undefined;\n}\n\n/** returns the smallest nice unit for scale.nice */\nexport function smallestUnit(timeUnit): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  if (timeUnit.indexOf('second') > -1) {\n    return 'second';\n  }\n\n  if (timeUnit.indexOf('minute') > -1) {\n    return 'minute';\n  }\n\n  if (timeUnit.indexOf('hour') > -1) {\n    return 'hour';\n  }\n\n  if (timeUnit.indexOf('day') > -1 || timeUnit.indexOf('date') > -1) {\n    return 'day';\n  }\n\n  if (timeUnit.indexOf('month') > -1) {\n    return 'month';\n  }\n\n  if (timeUnit.indexOf('year') > -1) {\n    return 'year';\n  }\n  return undefined;\n}\n\nexport function parseExpression(timeUnit: TimeUnit, fieldRef: string, onlyRef = false): string {\n  let out = 'datetime(';\n  let timeString = timeUnit.toString();\n\n  function get(fun: string, addComma = true) {\n    if (onlyRef) {\n      return fieldRef + (addComma ? ', ' : '');\n    } else {\n      return fun + '(' + fieldRef + ')' + (addComma ? ', ' : '');\n    }\n  }\n\n  if (timeString.indexOf('year') > -1) {\n    out += get('year');\n  } else {\n    out += '2006, '; // January 1 2006 is a Sunday\n  }\n\n  if (timeString.indexOf('month') > -1) {\n    out += get('month');\n  } else {\n    // month starts at 0 in javascript\n    out += '0, ';\n  }\n\n  // need to add 1 because days start at 1\n  if (timeString.indexOf('day') > -1) {\n    out += get('day', false) + '+1, ';\n  } else if (timeString.indexOf('date') > -1) {\n    out += get('date');\n  } else {\n    out += '1, ';\n  }\n\n  if (timeString.indexOf('hours') > -1) {\n    out += get('hours');\n  } else {\n    out += '0, ';\n  }\n\n  if (timeString.indexOf('minutes') > -1) {\n    out += get('minutes');\n  } else {\n    out += '0, ';\n  }\n\n  if (timeString.indexOf('seconds') > -1) {\n    out += get('seconds');\n  } else {\n    out += '0, ';\n  }\n\n  if (timeString.indexOf('milliseconds') > -1) {\n    out += get('milliseconds', false);\n  } else {\n    out += '0';\n  }\n\n  return out + ')';\n}\n\n/** Generate the complete raw domain. */\nexport function rawDomain(timeUnit: TimeUnit, channel: Channel) {\n  if (contains([ROW, COLUMN, SHAPE, COLOR], channel)) {\n    return null;\n  }\n\n  switch (timeUnit) {\n    case TimeUnit.SECONDS:\n      return range(0, 60);\n    case TimeUnit.MINUTES:\n      return range(0, 60);\n    case TimeUnit.HOURS:\n      return range(0, 24);\n    case TimeUnit.DAY:\n      return range(0, 7);\n    case TimeUnit.DATE:\n      return range(1, 32);\n    case TimeUnit.MONTH:\n      return range(0, 12);\n  }\n\n  return null;\n}\n",
    "import {AggregateOp} from '../aggregate';\nimport {AxisProperties} from '../axis';\nimport {X, Y, TEXT, PATH, ORDER, Channel, UNIT_CHANNELS,  UNIT_SCALE_CHANNELS, NONSPATIAL_SCALE_CHANNELS, supportMark} from '../channel';\nimport {defaultConfig, Config, CellConfig} from '../config';\nimport {SOURCE, SUMMARY} from '../data';\nimport {Encoding} from '../encoding';\nimport * as vlEncoding from '../encoding'; // TODO: remove\nimport {FieldDef} from '../fielddef';\nimport {LegendProperties} from '../legend';\nimport {Mark, TEXT as TEXTMARK} from '../mark';\nimport {Scale, ScaleType} from '../scale';\nimport {ExtendedUnitSpec} from '../spec';\nimport {getFullName, QUANTITATIVE} from '../type';\nimport {duplicate, extend, mergeDeep, Dict, isArray, array} from '../util';\nimport {VgData} from '../vega.schema';\nimport {isRepeatRef} from '../fielddef';\n\nimport {parseAxisComponent} from './axis';\nimport {applyConfig, FILL_STROKE_CONFIG} from './common';\nimport {initMarkConfig} from './config';\nimport {assembleData, parseUnitData} from './data/data';\nimport {parseLegendComponent} from './legend';\nimport {assembleLayout, parseUnitLayout} from './layout';\nimport {Model, isLayerModel} from './model';\nimport {parseMark} from './mark/mark';\nimport {parseScaleComponent, scaleType} from './scale';\nimport {compileStackProperties, StackProperties} from './stack';\nimport {RepeatValues} from './repeat';\n\nimport * as selections from './selections';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends Model {\n\n  private _mark: Mark;\n  private _encoding: Encoding;\n  private _stack: StackProperties;\n  public _select: any;\n\n  constructor(spec: ExtendedUnitSpec, parent: Model, parentGivenName: string, repeatValues: RepeatValues) {\n    super(spec, parent, parentGivenName, repeatValues);\n\n    const mark = this._mark = spec.mark;\n    const encoding = this._encoding = this._initEncoding(mark, spec.encoding || {});\n    const config = this._config = this._initConfig(spec.config, parent, mark, encoding);\n\n    const scale = this._scale =  this._initScale(mark, encoding, config);\n    this._axis = this._initAxis(encoding, config);\n    this._legend = this._initLegend(encoding, config);\n\n    // calculate stack\n    this._stack = compileStackProperties(mark, encoding, scale, config);\n\n    this._select = spec.select || {};\n  }\n\n  private _initEncoding(mark: Mark, encoding: Encoding) {\n    // clone to prevent side effect to the original spec\n    encoding = duplicate(encoding);\n\n    vlEncoding.forEach(encoding, function(fieldDef: FieldDef, channel: Channel) {\n      if (!supportMark(channel, mark)) {\n        // Drop unsupported channel\n\n        // FIXME consolidate warning method\n        console.warn(channel, 'dropped as it is incompatible with', mark);\n        delete fieldDef.field;\n        return;\n      }\n\n      if (fieldDef.type) {\n        // convert short type to full type\n        fieldDef.type = getFullName(fieldDef.type);\n      }\n\n      if ((channel === PATH || channel === ORDER) && !fieldDef.aggregate && fieldDef.type === QUANTITATIVE) {\n        fieldDef.aggregate = AggregateOp.MIN;\n      }\n    });\n    return encoding;\n  }\n\n  private _initConfig(specConfig: Config, parent: Model, mark: Mark, encoding: Encoding) {\n    let config = mergeDeep(duplicate(defaultConfig), parent ? parent.config() : {}, specConfig);\n    config.mark = initMarkConfig(mark, encoding, config);\n    return config;\n  }\n\n  private _initScale(mark: Mark, encoding: Encoding, config: Config): Dict<Scale> {\n    var model = this;\n    return UNIT_SCALE_CHANNELS.reduce(function(_scale, channel) {\n      if (vlEncoding.has(encoding, channel)) {\n        const fieldDef = model.fieldDef(channel),\n              scaleSpec = (fieldDef as any).scale || {};\n\n        const _scaleType = scaleType(scaleSpec, fieldDef, channel, mark);\n\n        _scale[channel] = extend({\n          type: _scaleType,\n          round: config.scale.round,\n          padding: config.scale.padding,\n          includeRawDomain: config.scale.includeRawDomain,\n          bandSize: channel === X && _scaleType === ScaleType.ORDINAL && mark === TEXTMARK ?\n                     config.scale.textBandWidth : config.scale.bandSize\n        }, scaleSpec);\n      }\n      return _scale;\n    }, {} as Dict<Scale>);\n  }\n\n  private _initAxis(encoding: Encoding, config: Config): Dict<AxisProperties> {\n    return [X, Y].reduce(function(_axis, channel) {\n      // Position Axis\n      if (vlEncoding.has(encoding, channel)) {\n        const axisSpec = encoding[channel].axis;\n        if (axisSpec !== false) {\n          _axis[channel] = extend({},\n            config.axis,\n            axisSpec === true ? {} : axisSpec ||  {}\n          );\n        }\n      }\n      return _axis;\n    }, {} as Dict<AxisProperties>);\n  }\n\n  private _initLegend(encoding: Encoding, config: Config): Dict<LegendProperties> {\n    return NONSPATIAL_SCALE_CHANNELS.reduce(function(_legend, channel) {\n      if (vlEncoding.has(encoding, channel)) {\n        const legendSpec = encoding[channel].legend;\n        if (legendSpec !== false) {\n          _legend[channel] = extend({}, config.legend,\n            legendSpec === true ? {} : legendSpec ||  {}\n          );\n        }\n      }\n      return _legend;\n    }, {} as Dict<LegendProperties>);\n  }\n\n  public parseSelection() {\n    this.component.selection = selections.parse(this, this._select);\n  }\n\n  public parseData() {\n    this.component.data = parseUnitData(this);\n  }\n\n  public parseLayoutData() {\n    this.component.layout = parseUnitLayout(this);\n  }\n\n  public parseScale() {\n    this.component.scale = parseScaleComponent(this);\n  }\n\n  public parseMark() {\n    this.component.mark = parseMark(this);\n  }\n\n  public parseAxis() {\n    this.component.axis = parseAxisComponent(this, [X, Y]);\n  }\n\n  public parseAxisGroup() {\n    return null;\n  }\n\n  public parseGridGroup() {\n    return null;\n  }\n\n  public parseLegend() {\n    this.component.legend = parseLegendComponent(this);\n  }\n\n  public assembleData(data: VgData[]): VgData[] {\n    return assembleData(this, data);\n  }\n\n  public assembleLayout(layoutData: VgData[]): VgData[] {\n    return assembleLayout(this, layoutData);\n  }\n\n  public assemblePreSelectionData(data: VgData[]): VgData[] {\n    return selections.assembleUnitData(this, data, true);\n  }\n\n  public assemblePostSelectionData(data: VgData[]): VgData[] {\n    return selections.assembleUnitData(this, data, false);\n  }\n\n  public assembleSignals(signals) {\n    return selections.assembleUnitSignals(this, signals);\n  }\n\n  public assembleMarks() {\n    var parent = this.parent();\n    return parent && isLayerModel(parent) ? this.component.mark :\n      this.assembleSelectionMarks(this.component.mark);\n  }\n\n  public assembleSelectionMarks(marks) {\n    return selections.assembleMarks(this, marks);\n  }\n\n  public assembleParentGroupProperties(cellConfig: CellConfig) {\n    var props = applyConfig({}, cellConfig, FILL_STROKE_CONFIG.concat(['clip']));\n    return extend(props, {\n      unitName: { value: this.name() }\n    });\n  }\n\n  public channels() {\n    return UNIT_CHANNELS;\n  }\n\n  protected mapping() {\n    return this.encoding();\n  }\n\n  public stack(): StackProperties {\n    return this._stack;\n  }\n\n  public toSpec(excludeConfig?, excludeData?) {\n    const encoding = duplicate(this._encoding);\n    let spec: any;\n\n    spec = {\n      mark: this._mark,\n      encoding: encoding\n    };\n\n    if (!excludeConfig) {\n      spec.config = duplicate(this._config);\n    }\n\n    if (!excludeData) {\n      spec.data = duplicate(this._data);\n    }\n\n    // remove defaults\n    return spec;\n  }\n\n  public mark(): Mark {\n    return this._mark;\n  }\n\n  public has(channel: Channel) {\n    return vlEncoding.has(this._encoding, channel);\n  }\n\n  public encoding() {\n    return this._encoding;\n  }\n\n  public isRepeatRef(channel: Channel) {\n    if (channel in this._encoding) {\n      const field = this._encoding[channel].field;\n      return isRepeatRef(field);\n    }\n    return false;\n  }\n\n  public fieldDef(channel: Channel): FieldDef {\n    // TODO: remove this || {}\n    // Currently we have it to prevent null pointer exception.\n    let fieldDef = this._encoding[channel] || {};\n    if (isArray(fieldDef)) fieldDef = fieldDef[0];  // HACK for InfoVis!\n\n    // replace references to repeated value\n    if (fieldDef) {\n      const field = fieldDef.field;\n      if (isRepeatRef(field)) {\n        fieldDef = duplicate(fieldDef);\n        fieldDef.field = this.repeatValue(field.repeat);\n      }\n    }\n    return fieldDef;\n  }\n\n  public fieldDefs(channel: Channel): FieldDef[] {\n    var fieldDefs = this._encoding[channel] || {};\n    return array(fieldDefs).map((fieldDef) => {\n      const field = fieldDef.field;\n      if (isRepeatRef(field)) {\n        fieldDef = duplicate(fieldDef);\n        fieldDef.field = this.repeatValue(field.repeat);\n      }\n\n      return fieldDef;\n    });\n  }\n\n  public selection(name?: string) {\n    return (this._select && this._select[name]) || this.component.selection || [];\n  }\n\n  public dataTable() {\n    return this.dataName(vlEncoding.isAggregate(this._encoding) ? SUMMARY : SOURCE);\n  }\n\n  public isUnit() {\n    return true;\n  }\n}\n",
    "import {ScaleConfig, FacetScaleConfig, defaultScaleConfig, defaultFacetScaleConfig} from './scale';\nimport {AxisConfig, defaultAxisConfig, defaultFacetAxisConfig} from './axis';\nimport {LegendConfig, defaultLegendConfig} from './legend';\n\nexport interface CellConfig {\n  width?: number;\n  height?: number;\n\n  clip?: boolean;\n\n  // FILL_STROKE_CONFIG\n  /**\n   * @format color\n   */\n  fill?: string;\n  fillOpacity?: number;\n  stroke?: string;\n  strokeWidth?: number;\n  strokeOpacity?: number;\n  strokeDash?: number;\n  /** The offset (in pixels) into which to begin drawing with the stroke dash array. */\n  strokeDashOffset?: number;\n}\n\nexport const defaultCellConfig: CellConfig = {\n  width: 200,\n  height: 200,\n  fill: 'transparent'\n};\n\nexport const defaultFacetCellConfig: CellConfig = {\n  stroke: '#ccc',\n  strokeWidth: 1\n};\n\nexport interface FacetConfig {\n  scale?: FacetScaleConfig;\n  axis?: AxisConfig;\n  grid?: FacetGridConfig;\n  cell?: CellConfig;\n}\n\nexport interface FacetGridConfig {\n  /** @format color */\n  color?: string;\n  opacity?: number;\n  offset?: number;\n}\n\nconst defaultFacetGridConfig: FacetGridConfig = {\n  color: '#000000',\n  opacity: 0.4,\n  offset: 0\n};\n\nexport const defaultFacetConfig: FacetConfig = {\n  scale: defaultFacetScaleConfig,\n  axis: defaultFacetAxisConfig,\n  grid: defaultFacetGridConfig,\n  cell: defaultFacetCellConfig\n};\n\nexport enum FontWeight {\n    NORMAL = 'normal' as any,\n    BOLD = 'bold' as any\n}\n\nexport enum Shape {\n    CIRCLE = 'circle' as any,\n    SQUARE = 'square' as any,\n    CROSS = 'cross' as any,\n    DIAMOND = 'diamond' as any,\n    TRIANGLEUP = 'triangle-up' as any,\n    TRIANGLEDOWN = 'triangle-down' as any,\n}\n\nexport enum HorizontalAlign {\n    LEFT = 'left' as any,\n    RIGHT = 'right' as any,\n    CENTER = 'center' as any,\n}\n\nexport enum VerticalAlign {\n    TOP = 'top' as any,\n    MIDDLE = 'middle' as any,\n    BOTTOM = 'bottom' as any,\n}\n\nexport enum FontStyle {\n    NORMAL = 'normal' as any,\n    ITALIC = 'italic' as any,\n}\n\nexport enum StackOffset {\n    ZERO = 'zero' as any,\n    CENTER = 'center' as any,\n    NORMALIZE = 'normalize' as any,\n    NONE = 'none' as any,\n}\n\nexport interface MarkConfig {\n\n  // ---------- Color ----------\n  /**\n   * Whether the shape\\'s color should be used as fill color instead of stroke color.\n   * This is only applicable for \"bar\", \"point\", and \"area\".\n   * All marks except \"point\" marks are filled by default.\n   * See Mark Documentation (http://vega.github.io/vega-lite/docs/marks.html)\n   * for usage example.\n   */\n  filled?: boolean;\n  /**\n   * Default color.\n   * @format color\n   */\n  color?: string;\n  /**\n   * Default Fill Color.  This has higher precedence than config.color\n   * @format color\n   */\n  fill?: string;\n  /**\n   * Default Stroke Color.  This has higher precedence than config.color\n   * @format color\n   */\n  stroke?: string;\n\n\n  // ---------- Opacity ----------\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  opacity?: number;\n\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  fillOpacity?: number;\n\n  /**\n   * @minimum 0\n   * @maximum 1\n   */\n  strokeOpacity?: number;\n\n  // ---------- Stroke Style ----------\n  /**\n   * @minimum 0\n   */\n  strokeWidth?: number;\n  /**\n   * An array of alternating stroke, space lengths for creating dashed or dotted lines.\n   */\n  strokeDash?: number[];\n  /**\n   * The offset (in pixels) into which to begin drawing with the stroke dash array.\n   */\n  strokeDashOffset?: number;\n\n  // ---------- Stacking: Bar & Area ----------\n  stacked?: StackOffset;\n\n  // ---------- Orientation: Bar, Tick, Line, Area ----------\n  /**\n   * The orientation of a non-stacked bar, tick, area, and line charts.\n   * The value is either horizontal (default) or vertical.\n   * - For bar, rule and tick, this determines whether the size of the bar and tick\n   * should be applied to x or y dimension.\n   * - For area, this property determines the orient property of the Vega output.\n   * - For line, this property determines the sort order of the points in the line\n   * if `config.sortLineBy` is not specified.\n   * For stacked charts, this is always determined by the orientation of the stack;\n   * therefore explicitly specified value will be ignored.\n   */\n  orient?: string;\n\n  // ---------- Interpolation: Line / area ----------\n  /**\n   * The line interpolation method to use. One of linear, step-before, step-after, basis, basis-open, basis-closed, bundle, cardinal, cardinal-open, cardinal-closed, monotone.\n   */\n  interpolate?: string;\n  /**\n   * Depending on the interpolation type, sets the tension parameter.\n   */\n  tension?: number;\n\n  // ---------- Line ---------\n  /**\n   * Size of line mark.\n   */\n  lineSize?: number;\n\n  // ---------- Rule ---------\n  /**\n   * Size of rule mark.\n   */\n  ruleSize?: number;\n\n  // ---------- Bar ----------\n  /**\n   * The size of the bars.  If unspecified, the default size is  `bandSize-1`,\n   * which provides 1 pixel offset between bars.\n   */\n  barSize?: number;\n  /**\n   * The size of the bars on continuous scales.\n   */\n  barThinSize?: number;\n\n  // ---------- Point ----------\n  /**\n   * The symbol shape to use. One of circle (default), square, cross, diamond, triangle-up, or triangle-down.\n   */\n  shape?: Shape;\n\n  // ---------- Point Size (Point / Square / Circle) ----------\n  /**\n   * The pixel area each the point. For example: in the case of circles, the radius is determined in part by the square root of the size value.\n   */\n  size?: number;\n\n  // ---------- Tick ----------\n  /** The width of the ticks. */\n  tickSize?: number;\n\n  /** Thickness of the tick mark. */\n  tickThickness?: number;\n\n  // ---------- Text ----------\n  /**\n   * The horizontal alignment of the text. One of left, right, center.\n   */\n  align?: HorizontalAlign;\n  /**\n   * The rotation angle of the text, in degrees.\n   */\n  angle?: number;\n  /**\n   * The vertical alignment of the text. One of top, middle, bottom.\n   */\n  baseline?: VerticalAlign;\n  /**\n   * The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.\n   */\n  dx?: number;\n  /**\n   * The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the angle property.\n   */\n  dy?: number;\n  /**\n   * Polar coordinate radial offset, in pixels, of the text label from the origin determined by the x and y properties.\n   */\n  radius?: number;\n  /**\n   * Polar coordinate angle, in radians, of the text label from the origin determined by the x and y properties. Values for theta follow the same convention of arc mark startAngle and endAngle properties: angles are measured in radians, with 0 indicating \"north\".\n   */\n  theta?: number;\n  /**\n   * The typeface to set the text in (e.g., Helvetica Neue).\n   */\n  font?: string;\n  /**\n   * The font size, in pixels.\n   */\n  fontSize?: number;\n  /**\n   * The font style (e.g., italic).\n   */\n  fontStyle?: FontStyle;\n  /**\n   * The font weight (e.g., bold).\n   */\n  fontWeight?: FontWeight;\n  // Vega-Lite only for text only\n  /**\n   * The formatting pattern for text value. If not defined, this will be determined automatically.\n   */\n  format?: string;\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n  /**\n   * Placeholder Text\n   */\n  text?: string;\n\n  /**\n   * Apply color field to background color instead of the text.\n   */\n  applyColorToBackground?: boolean;\n}\n\nexport const defaultMarkConfig: MarkConfig = {\n  color: '#4682b4',\n  strokeWidth: 2,\n  size: 30,\n  barThinSize: 2,\n  // lineSize is undefined by default, and refer to value from strokeWidth\n  ruleSize: 1,\n  tickThickness: 1,\n\n  fontSize: 10,\n  baseline: VerticalAlign.MIDDLE,\n  text: 'Abc',\n\n  shortTimeLabels: false,\n  applyColorToBackground: false\n};\n\n\nexport interface Config {\n  // TODO: add this back once we have top-down layout approach\n  // width?: number;\n  // height?: number;\n  // padding?: number|string;\n  /**\n   * The width and height of the on-screen viewport, in pixels. If necessary, clipping and scrolling will be applied.\n   */\n  viewport?: number;\n  /**\n   * CSS color property to use as background of visualization. Default is `\"transparent\"`.\n   */\n  background?: string;\n\n  /**\n   * D3 Number format for axis labels and text tables. For example \"s\" for SI units.\n   */\n  numberFormat?: string;\n  /**\n   * Default datetime format for axis and legend labels. The format can be set directly on each axis and legend.\n   */\n  timeFormat?: string;\n\n  cell?: CellConfig;\n  mark?: MarkConfig;\n  scale?: ScaleConfig;\n  axis?: AxisConfig;\n  legend?: LegendConfig;\n\n  facet?: FacetConfig;\n}\n\nexport const defaultConfig: Config = {\n  numberFormat: 's',\n  timeFormat: '%Y-%m-%d',\n\n  cell: defaultCellConfig,\n  mark: defaultMarkConfig,\n  scale: defaultScaleConfig,\n  axis: defaultAxisConfig,\n  legend: defaultLegendConfig,\n\n  facet: defaultFacetConfig,\n};\n",
    "/*\n * Constants and utilities for data.\n */\nimport {Type} from './type';\n\nexport enum DataFormat {\n    JSON = 'json' as any,\n    CSV = 'csv' as any,\n    TSV = 'tsv' as any,\n}\n\nexport interface Data {\n  formatType?: DataFormat;\n  url?: string;\n  /**\n   * Pass array of objects instead of a url to a file.\n   */\n  values?: any[];\n}\n\nexport enum DataTable {\n  SOURCE = 'source' as any,\n  SUMMARY = 'summary' as any,\n  STACKED_SCALE = 'stacked_scale' as any,\n  LAYOUT = 'layout' as any\n}\n\nexport const SUMMARY = DataTable.SUMMARY;\nexport const SOURCE = DataTable.SOURCE;\nexport const STACKED_SCALE = DataTable.STACKED_SCALE;\nexport const LAYOUT = DataTable.LAYOUT;\n\n/** Mapping from datalib's inferred type to Vega-lite's type */\n// TODO: consider if we can remove\nexport const types = {\n  'boolean': Type.NOMINAL,\n  'number': Type.QUANTITATIVE,\n  'integer': Type.QUANTITATIVE,\n  'date': Type.TEMPORAL,\n  'string': Type.NOMINAL\n};\n",
    "// utility for encoding mapping\nimport {FieldDef, PositionChannelDef, FacetChannelDef, ChannelDefWithLegend, OrderChannelDef} from './fielddef';\nimport {Channel, CHANNELS} from './channel';\nimport {isArray, any as anyIn} from './util';\n\n// TODO: once we decompose facet, rename this to Encoding\nexport interface UnitEncoding {\n  x?: PositionChannelDef;\n  y?: PositionChannelDef;\n  color?: ChannelDefWithLegend;\n  size?: ChannelDefWithLegend;\n  shape?: ChannelDefWithLegend; // TODO: maybe distinguish ordinal-only\n  detail?: FieldDef | FieldDef[];\n  text?: FieldDef;\n  label?: FieldDef;\n\n  path?: OrderChannelDef | OrderChannelDef[];\n  order?: OrderChannelDef | OrderChannelDef[];\n}\n\n// TODO: once we decompose facet, rename this to ExtendedEncoding\nexport interface Encoding extends UnitEncoding {\n  row?: FacetChannelDef;\n  column?: FacetChannelDef;\n}\n\nexport function countRetinal(encoding: Encoding) {\n  let count = 0;\n  if (encoding.color) { count++; }\n  if (encoding.size) { count++; }\n  if (encoding.shape) { count++; }\n  return count;\n}\n\nexport function channels(encoding: Encoding) {\n  return CHANNELS.filter(function(channel) {\n    return has(encoding, channel);\n  });\n}\n\nexport function has(encoding: Encoding, channel: Channel): boolean {\n  const channelEncoding = encoding && encoding[channel];\n  return channelEncoding && (\n    channelEncoding.field !== undefined ||\n    channelEncoding.selection !== undefined ||\n    (isArray(channelEncoding) && channelEncoding.length > 0)\n  );\n}\n\nexport function isAggregate(encoding: Encoding) {\n  return anyIn(CHANNELS, (channel) => {\n    if (has(encoding, channel) && encoding[channel].aggregate) {\n      return true;\n    }\n    return false;\n  });\n}\n\nexport function fieldDefs(encoding: Encoding): FieldDef[] {\n  let arr = [];\n  CHANNELS.forEach(function(channel) {\n    if (has(encoding, channel)) {\n      if (isArray(encoding[channel])) {\n        encoding[channel].forEach(function(fieldDef) {\n          arr.push(fieldDef);\n        });\n      } else {\n        arr.push(encoding[channel]);\n      }\n    }\n  });\n  return arr;\n};\n\nexport function forEach(encoding: Encoding,\n    f: (fd: FieldDef, c: Channel, i: number) => void,\n    thisArg?: any) {\n  channelMappingForEach(CHANNELS, encoding, f, thisArg);\n}\n\nexport function channelMappingForEach(channels: Channel[], mapping: any,\n    f: (fd: FieldDef, c: Channel, i: number) => void,\n    thisArg?: any) {\n  let i = 0;\n  channels.forEach(function(channel) {\n    if (has(mapping, channel)) {\n      if (isArray(mapping[channel])) {\n        mapping[channel].forEach(function(fieldDef) {\n            f.call(thisArg, fieldDef, channel, i++);\n        });\n      } else {\n        f.call(thisArg, mapping[channel], channel, i++);\n      }\n    }\n  });\n}\n\n// TODO: delete once shorhand has been extracted\nexport function map(encoding: Encoding,\n    f: (fd: FieldDef, c: Channel, i: number) => any,\n    thisArg?: any) {\n  return channelMappingMap(CHANNELS, encoding, f , thisArg);\n}\n\nexport function channelMappingMap(channels: Channel[], mapping: any,\n    f: (fd: FieldDef, c: Channel, i: number) => any,\n    thisArg?: any) {\n  let arr = [];\n  channels.forEach(function(channel) {\n    if (has(mapping, channel)) {\n      if (isArray(mapping[channel])) {\n        mapping[channel].forEach(function(fieldDef) {\n          arr.push(f.call(thisArg, fieldDef, channel));\n        });\n      } else {\n        arr.push(f.call(thisArg, mapping[channel], channel));\n      }\n    }\n  });\n  return arr;\n}\nexport function reduce(encoding: Encoding,\n    f: (acc: any, fd: FieldDef, c: Channel) => any,\n    init,\n    thisArg?: any) {\n  return channelMappingReduce(CHANNELS, encoding, f, init, thisArg);\n}\n\nexport function channelMappingReduce(channels: Channel[], mapping: any,\n    f: (acc: any, fd: FieldDef, c: Channel) => any,\n    init,\n    thisArg?: any) {\n  let r = init;\n  CHANNELS.forEach(function(channel) {\n    if (has(mapping, channel)) {\n      if (isArray(mapping[channel])) {\n        mapping[channel].forEach(function(fieldDef) {\n            r = f.call(thisArg, r, fieldDef, channel);\n        });\n      } else {\n        r = f.call(thisArg, r, mapping[channel], channel);\n      }\n    }\n  });\n  return r;\n}\n",
    "// utility for a field definition object\n\nimport {Channel} from './channel';\nimport {AggregateOp, AGGREGATE_OPS} from './aggregate';\nimport {AxisProperties} from './axis';\nimport {BinProperties} from './bin';\nimport {LegendProperties} from './legend';\nimport {Scale} from './scale';\nimport {SortField, SortOrder} from './sort';\nimport {TimeUnit} from './timeunit';\nimport {Type, NOMINAL, ORDINAL, QUANTITATIVE, TEMPORAL} from './type';\nimport {contains, toMap, isObject} from './util';\n\nexport type RepeatRef = {\n  repeat: Channel\n}\nexport type Field = string | RepeatRef;\n\nexport function isRepeatRef(field: Field): field is RepeatRef {\n  if (isObject(field)) {\n    return 'repeat' in (field as any);\n  }\n  return false;\n}\n\n/**\n *  Interface for any kind of FieldDef;\n *  For simplicity, we do not declare multiple interfaces of FieldDef like\n *  we do for JSON schema.\n */\nexport interface FieldDef {\n  field?: Field;\n  type?: Type;\n  value?: number | string | boolean;\n  selection?: string;\n\n  // function\n  timeUnit?: TimeUnit;\n  bin?: boolean | BinProperties;\n  aggregate?: AggregateOp;\n\n  // TODO: maybe extend this in other app?\n  // unused metadata -- for other application\n  displayName?: string;\n}\n\nexport const aggregate = {\n  type: 'string',\n  enum: AGGREGATE_OPS,\n  supportedEnums: {\n    quantitative: AGGREGATE_OPS,\n    ordinal: ['median','min','max'],\n    nominal: [],\n    temporal: ['mean', 'median', 'min', 'max'], // TODO: revise what should time support\n    '': ['count']\n  },\n  supportedTypes: toMap([QUANTITATIVE, NOMINAL, ORDINAL, TEMPORAL, ''])\n};\nexport interface ChannelDefWithScale extends FieldDef {\n  scale?: Scale;\n  sort?: SortField | SortOrder;\n}\n\nexport interface PositionChannelDef extends ChannelDefWithScale {\n  axis?: boolean | AxisProperties;\n}\nexport interface ChannelDefWithLegend extends ChannelDefWithScale {\n  legend?: LegendProperties;\n}\n\n// Detail\n\n// Order Path have no scale\n\nexport interface OrderChannelDef extends FieldDef {\n  sort?: SortOrder;\n}\n\n// TODO: consider if we want to distinguish ordinalOnlyScale from scale\nexport type FacetChannelDef = PositionChannelDef;\n\n\n\nexport interface FieldRefOption {\n  /** exclude bin, aggregate, timeUnit */\n  nofn?: boolean;\n  /** exclude aggregation function */\n  noAggregate?: boolean;\n  /** include 'datum.' */\n  datum?: boolean;\n  /** replace fn with custom function prefix */\n  fn?: string;\n  /** prepend fn with custom function prefix */\n  prefn?: string;\n  /** append suffix to the field ref for bin (default='_start') */\n  binSuffix?: string;\n  /** append suffix to the field ref (general) */\n  suffix?: string;\n}\n\n/**\n * If you call this function, make sure you know that the field is not a reference to a repeated field.\n */\nexport function field(fieldDef: FieldDef, opt: FieldRefOption = {}) {\n  const prefix = (opt.datum ? 'datum.' : '') + (opt.prefn || '');\n  const suffix = opt.suffix || '';\n  const field = fieldDef.field;\n\n  if (isCount(fieldDef)) {\n    return prefix + 'count' + suffix;\n  } else if (opt.fn) {\n    return prefix + opt.fn + '_' + field + suffix;\n  } else if (!opt.nofn && fieldDef.bin) {\n    return prefix + 'bin_' + field + (opt.binSuffix || suffix || '_start');\n  } else if (!opt.nofn && !opt.noAggregate && fieldDef.aggregate) {\n    return prefix + fieldDef.aggregate + '_' + field + suffix;\n  } else if (!opt.nofn && fieldDef.timeUnit) {\n    return prefix + fieldDef.timeUnit + '_' + field + suffix;\n  } else {\n    return prefix + field;\n  }\n}\n\nfunction _isFieldDimension(fieldDef: FieldDef) {\n  return contains([NOMINAL, ORDINAL], fieldDef.type) || !!fieldDef.bin ||\n    (fieldDef.type === TEMPORAL && !!fieldDef.timeUnit);\n}\n\nexport function isDimension(fieldDef: FieldDef) {\n  return fieldDef && fieldDef.field && _isFieldDimension(fieldDef);\n}\n\nexport function isMeasure(fieldDef: FieldDef) {\n  return fieldDef && fieldDef.field && !_isFieldDimension(fieldDef);\n}\n\nexport const COUNT_DISPLAYNAME = 'Number of Records';\n\nexport function count(): FieldDef {\n  return { field: '*', aggregate: AggregateOp.COUNT, type: QUANTITATIVE, displayName: COUNT_DISPLAYNAME };\n}\n\nexport function isCount(fieldDef: FieldDef) {\n  return fieldDef.aggregate === AggregateOp.COUNT;\n}\n\n/**\n * Generate a title from a fieldDef. Make sure that the field is not repeated.\n */\nexport function title(fieldDef: FieldDef): string {\n  if (isCount(fieldDef)) {\n    return COUNT_DISPLAYNAME;\n  }\n  const fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');\n  if (fn) {\n    return fn.toString().toUpperCase() + '(' + fieldDef.field + ')';\n  } else if (fieldDef.selection) {\n    return fieldDef.selection as string;\n  } else {\n    return fieldDef.field as string;\n  }\n}\n",
    "export interface LegendConfig {\n  /**\n   * The orientation of the legend. One of \"left\" or \"right\". This determines how the legend is positioned within the scene. The default is \"right\".\n   */\n  orient?: string;\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n  /**\n   * Optional mark property definitions for custom legend styling.\n   */\n  properties?: any; // TODO(#975) replace with config properties\n}\n\n/**\n * Properties of a legend or boolean flag for determining whether to show it.\n */\nexport interface LegendProperties extends LegendConfig {\n  /**\n   * An optional formatting pattern for legend labels. Vega uses D3\\'s format pattern.\n   */\n  format?: string;\n  /**\n   * A title for the legend. (Shows field name and its function by default.)\n   */\n  title?: string;\n  /**\n   * Explicitly set the visible legend values.\n   */\n  values?: Array<any>;\n}\n\nexport const defaultLegendConfig: LegendConfig = {\n  orient: undefined, // implicitly \"right\"\n  shortTimeLabels: false\n};\n",
    "export enum Mark {\n  AREA = 'area' as any,\n  BAR = 'bar' as any,\n  LINE = 'line' as any,\n  POINT = 'point' as any,\n  TEXT = 'text' as any,\n  TICK = 'tick' as any,\n  RULE = 'rule' as any,\n  CIRCLE = 'circle' as any,\n  SQUARE = 'square' as any\n}\n\nexport const AREA = Mark.AREA;\nexport const BAR = Mark.BAR;\nexport const LINE = Mark.LINE;\nexport const POINT = Mark.POINT;\nexport const TEXT = Mark.TEXT;\nexport const TICK = Mark.TICK;\nexport const RULE = Mark.RULE;\n\nexport const CIRCLE = Mark.CIRCLE;\nexport const SQUARE = Mark.SQUARE;\n",
    "export enum ScaleType {\n    LINEAR = 'linear' as any,\n    LOG = 'log' as any,\n    POW = 'pow' as any,\n    SQRT = 'sqrt' as any,\n    QUANTILE = 'quantile' as any,\n    QUANTIZE = 'quantize' as any,\n    ORDINAL = 'ordinal' as any,\n    TIME = 'time' as any,\n    UTC  = 'utc' as any,\n}\n\nexport enum NiceTime {\n    SECOND = 'second' as any,\n    MINUTE = 'minute' as any,\n    HOUR = 'hour' as any,\n    DAY = 'day' as any,\n    WEEK = 'week' as any,\n    MONTH = 'month' as any,\n    YEAR = 'year' as any,\n}\n\nexport interface ScaleConfig {\n  /**\n   * If true, rounds numeric output values to integers.\n   * This can be helpful for snapping to the pixel grid.\n   * (Only available for `x`, `y`, `size`, `row`, and `column` scales.)\n   */\n  round?: boolean;\n  /**\n   *  Default band width for `x` ordinal scale when is mark is `text`.\n   *  @minimum 0\n   */\n  textBandWidth?: number;\n  /**\n   * Default band size for (1) `y` ordinal scale,\n   * and (2) `x` ordinal scale when the mark is not `text`.\n   * @minimum 0\n   */\n  bandSize?: number;\n  /**\n   * Default padding for `x` and `y` ordinal scales.\n   */\n  padding?: number;\n\n  // Experimental Feature\n  includeRawDomain?: boolean;\n\n  /** Default range for nominal color scale */\n  nominalColorRange?: string | string[];\n  /** Default range for ordinal / continuous color scale */\n  sequentialColorRange?: string | string[];\n  /** Default range for shape */\n  shapeRange?: string|string[];\n\n  /** Default range for bar size scale */\n  barSizeRange?: number[];\n\n  /** Default range for font size scale */\n  fontSizeRange?: number[];\n\n  /** Default range for rule stroke widths */\n  ruleSizeRange?: number[];\n\n  /** Default range for bar size scale */\n  pointSizeRange?: number[];\n\n  // nice should depends on type (quantitative or temporal), so\n  // let's not make a config.\n}\n\nexport const defaultScaleConfig: ScaleConfig = {\n  round: true,\n  textBandWidth: 90,\n  bandSize: 21,\n  padding: 1,\n  includeRawDomain: false,\n\n  nominalColorRange: 'category10',\n  sequentialColorRange: ['#AFC6A3', '#09622A'], // tableau greens\n  shapeRange: 'shapes',\n  fontSizeRange: [8, 40],\n  ruleSizeRange: [1, 5]\n};\n\nexport interface FacetScaleConfig {\n  round?: boolean;\n  padding?: number;\n}\n\nexport const defaultFacetScaleConfig: FacetScaleConfig = {\n  round: true,\n  padding: 16\n};\n\nexport interface Scale {\n  type?: ScaleType;\n  /**\n   * The domain of the scale, representing the set of data values. For quantitative data, this can take the form of a two-element array with minimum and maximum values. For ordinal/categorical data, this may be an array of valid input values. The domain may also be specified by a reference to a data source.\n   */\n  domain?: string | number[] | string[] | any; // TODO: declare vgDataDomain\n  /**\n   * The range of the scale, representing the set of visual values. For numeric values, the range can take the form of a two-element array with minimum and maximum values. For ordinal or quantized data, the range may by an array of desired output values, which are mapped to elements in the specified domain. For ordinal scales only, the range can be defined using a DataRef: the range values are then drawn dynamically from a backing data set.\n   */\n  range?: string | number[] | string[]; // TODO: declare vgRangeDomain\n  /**\n   * If true, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.\n   */\n  round?: boolean;\n\n  // ordinal\n  /**\n   * @minimum 0\n   */\n  bandSize?: number;\n  /**\n   * Applies spacing among ordinal elements in the scale range. The actual effect depends on how the scale is configured. If the __points__ parameter is `true`, the padding value is interpreted as a multiple of the spacing between points. A reasonable value is 1.0, such that the first and last point will be offset from the minimum and maximum value by half the distance between points. Otherwise, padding is typically in the range [0, 1] and corresponds to the fraction of space in the range interval to allocate to padding. A value of 0.5 means that the range band width will be equal to the padding width. For more, see the [D3 ordinal scale documentation](https://github.com/mbostock/d3/wiki/Ordinal-Scales).\n   */\n  padding?: number;\n\n  // typical\n  /**\n   * If true, values that exceed the data domain are clamped to either the minimum or maximum range value\n   */\n  clamp?: boolean;\n  /**\n   * If specified, modifies the scale domain to use a more human-friendly value range. If specified as a true boolean, modifies the scale domain to use a more human-friendly number range (e.g., 7 instead of 6.96). If specified as a string, modifies the scale domain to use a more human-friendly value range. For time and utc scale types only, the nice value should be a string indicating the desired time interval.\n   */\n  nice?: boolean | NiceTime;\n  /**\n   * Sets the exponent of the scale transformation. For pow scale types only, otherwise ignored.\n   */\n  exponent?: number;\n  /**\n   * If true, ensures that a zero baseline value is included in the scale domain. This option is ignored for non-quantitative scales.\n   */\n  zero?: boolean;\n\n  // Vega-Lite only\n  /**\n   * Uses the source data range as scale domain instead of aggregated data for aggregate axis. This option does not work with sum or count aggregate as they might have a substantially larger scale range.\n   */\n  includeRawDomain?: boolean;\n}\n",
    "/** module for shorthand */\n\nimport {Encoding} from './encoding';\nimport {FieldDef} from './fielddef';\nimport {ExtendedUnitSpec} from './spec';\n\nimport {AggregateOp, AGGREGATE_OPS} from './aggregate';\nimport {TIMEUNITS} from './timeunit';\nimport {SHORT_TYPE, TYPE_FROM_SHORT_TYPE} from './type';\nimport * as vlEncoding from './encoding';\nimport {Mark} from './mark';\n\nexport const DELIM = '|';\nexport const ASSIGN = '=';\nexport const TYPE = ',';\nexport const FUNC = '_';\n\n\nexport function shorten(spec: ExtendedUnitSpec): string {\n  return 'mark' + ASSIGN + spec.mark +\n    DELIM + shortenEncoding(spec.encoding);\n}\n\nexport function parse(shorthand: string, data?, config?) {\n  let split = shorthand.split(DELIM),\n    mark = split.shift().split(ASSIGN)[1].trim(),\n    encoding = parseEncoding(split.join(DELIM));\n\n  let spec:ExtendedUnitSpec = {\n    mark: Mark[mark],\n    encoding: encoding\n  };\n\n  if (data !== undefined) {\n    spec.data = data;\n  }\n  if (config !== undefined) {\n    spec.config = config;\n  }\n  return spec;\n}\n\nexport function shortenEncoding(encoding: Encoding): string {\n  return vlEncoding.map(encoding, function(fieldDef, channel) {\n    return channel + ASSIGN + shortenFieldDef(fieldDef);\n  }).join(DELIM);\n}\n\nexport function parseEncoding(encodingShorthand: string): Encoding {\n  return encodingShorthand.split(DELIM).reduce(function(m, e) {\n    const split = e.split(ASSIGN),\n        enctype = split[0].trim(),\n        fieldDefShorthand = split[1];\n\n    m[enctype] = parseFieldDef(fieldDefShorthand);\n    return m;\n  }, {});\n}\n\nexport function shortenFieldDef(fieldDef: FieldDef): string {\n  return (fieldDef.aggregate ? fieldDef.aggregate + FUNC : '') +\n    (fieldDef.timeUnit ? fieldDef.timeUnit + FUNC : '') +\n    (fieldDef.bin ? 'bin' + FUNC : '') +\n    (fieldDef.field || '') + TYPE + SHORT_TYPE[fieldDef.type];\n}\n\nexport function shortenFieldDefs(fieldDefs: FieldDef[], delim = DELIM): string {\n  return fieldDefs.map(shortenFieldDef).join(delim);\n}\n\nexport function parseFieldDef(fieldDefShorthand: string): FieldDef {\n  const split = fieldDefShorthand.split(TYPE);\n\n  let fieldDef: any = {\n    field: split[0].trim(),\n    type: TYPE_FROM_SHORT_TYPE[split[1].trim()]\n  };\n\n  // check aggregate type\n  for (let i = 0; i < AGGREGATE_OPS.length; i++) {\n    let a = AGGREGATE_OPS[i];\n    if (fieldDef.field.indexOf(a + '_') === 0) {\n      fieldDef.field = fieldDef.field.substr(a.toString().length + 1);\n      if (a === AggregateOp.COUNT && fieldDef.field.length === 0) {\n        fieldDef.field = '*';\n      }\n      fieldDef.aggregate = a;\n      break;\n    }\n  }\n\n  for (let i = 0; i < TIMEUNITS.length; i++) {\n    let tu = TIMEUNITS[i];\n    if (fieldDef.field && fieldDef.field.indexOf(tu + '_') === 0) {\n      fieldDef.field = fieldDef.field.substr(fieldDef.field.length + 1);\n      fieldDef.timeUnit = tu;\n      break;\n    }\n  }\n\n  // check bin\n  if (fieldDef.field && fieldDef.field.indexOf('bin_') === 0) {\n    fieldDef.field = fieldDef.field.substr(4);\n    fieldDef.bin = true;\n  }\n\n  return fieldDef;\n}\n",
    "import {AggregateOp} from './aggregate';\n\nexport enum SortOrder {\n    ASCENDING = 'ascending' as any,\n    DESCENDING = 'descending' as any,\n    NONE = 'none' as any,\n}\n\nexport interface SortField {\n  /**\n   * The field name to aggregate over.\n   */\n  field: string;\n  /**\n   * The sort aggregation operator\n   */\n  op: AggregateOp;\n\n  order?: SortOrder;\n}\n",
    "/* Utilities for a Vega-Lite specificiation */\n\nimport {FieldDef} from './fielddef';\n// Package of defining Vega-lite Specification's json schema\n\nimport {Config} from './config';\nimport {Data} from './data';\nimport {Encoding, UnitEncoding, has} from './encoding';\nimport {Facet} from './facet';\nimport {Repeat} from './repeat';\nimport {Mark} from './mark';\nimport {Transform} from './transform';\n\nimport {COLOR, SHAPE, ROW, COLUMN} from './channel';\nimport * as vlEncoding from './encoding';\nimport {BAR, AREA} from './mark';\nimport {duplicate, extend} from './util';\n\nexport interface BaseSpec {\n  name?: string;\n  description?: string;\n  data?: Data;\n  transform?: Transform;\n  config?: Config;\n}\n\nexport interface UnitSpec extends BaseSpec {\n  select?: any;\n  mark: Mark;\n  encoding: UnitEncoding;\n}\n\n/**\n * Schema for a unit Vega-Lite specification, with the syntactic sugar extensions:\n * - `row` and `column` are included in the encoding.\n * - (Future) label, box plot\n *\n * Note: the spec could contain facet.\n *\n * @required [\"mark\", \"encoding\"]\n */\nexport interface ExtendedUnitSpec extends BaseSpec {\n  /**\n   * A name for the specification. The name is used to annotate marks, scale names, and more.\n   */\n  select?: any;\n  mark: Mark;\n  encoding: Encoding;\n}\n\nexport interface FacetSpec extends BaseSpec {\n  facet: Facet;\n  spec: Spec;\n}\n\nexport interface RepeatSpec {\n  name?: string;\n  description?: string;\n  repeat: Repeat;\n  spec: Spec;\n  config?: Config;\n}\n\nexport interface Resolve {\n  scale: 'independent' | 'shared';\n  guide?: 'independent' | 'shared';\n}\n\nexport interface ResolveMapping {\n  x?: Resolve;\n  y?: Resolve;\n}\n\nexport interface LayerSpec extends BaseSpec {\n  layers: UnitSpec[];\n  resolve?: ResolveMapping;\n}\n\nexport interface ConcatSpec extends BaseSpec {\n  // direction: 'horizontal' | 'vertical';\n  vconcat: Spec[];\n}\n\n/** This is for the future schema */\nexport interface ExtendedFacetSpec extends BaseSpec {\n  facet: Facet;\n\n  spec: ExtendedUnitSpec | FacetSpec;\n}\n\nexport type ExtendedSpec = ExtendedUnitSpec | FacetSpec | RepeatSpec | LayerSpec | ConcatSpec;\nexport type Spec = UnitSpec | FacetSpec | RepeatSpec | LayerSpec | ConcatSpec;\n\n/* Custom type guards */\n\nexport function isFacetSpec(spec: ExtendedSpec): spec is FacetSpec {\n  return spec['facet'] !== undefined;\n}\n\nexport function isRepeatSpec(spec: ExtendedSpec): spec is RepeatSpec {\n  return spec['repeat'] !== undefined;\n}\n\nexport function isExtendedUnitSpec(spec: ExtendedSpec): spec is ExtendedUnitSpec {\n  if (isSomeUnitSpec(spec)) {\n    const hasRow = has(spec.encoding, ROW);\n    const hasColumn = has(spec.encoding, COLUMN);\n\n    return hasRow || hasColumn;\n  }\n\n  return false;\n}\n\nexport function isUnitSpec(spec: ExtendedSpec): spec is UnitSpec {\n  if (isSomeUnitSpec(spec)) {\n    return !isExtendedUnitSpec(spec);\n  }\n\n  return false;\n}\n\nexport function isSomeUnitSpec(spec: ExtendedSpec): spec is ExtendedUnitSpec | UnitSpec {\n  return spec['encoding'] !== undefined;\n}\n\nexport function isLayerSpec(spec: ExtendedSpec): spec is LayerSpec {\n  return spec['layers'] !== undefined;\n}\n\nexport function isConcatSpec(spec: ExtendedSpec): spec is ConcatSpec {\n  return spec['vconcat'] !== undefined;\n}\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n */\nexport function normalize(spec: ExtendedSpec): Spec {\n  if (isExtendedUnitSpec(spec)) {\n    const hasRow = has(spec.encoding, ROW);\n    const hasColumn = has(spec.encoding, COLUMN);\n\n    // TODO: @arvind please  add interaction syntax here\n    let encoding = duplicate(spec.encoding);\n    delete encoding.column;\n    delete encoding.row;\n\n    return extend(\n      spec.name ? { name: spec.name } : {},\n      spec.description ? { description: spec.description } : {},\n      { data: spec.data },\n      spec.transform ? { transform: spec.transform } : {},\n      {\n        facet: extend(\n          hasRow ? { row: spec.encoding.row } : {},\n          hasColumn ? { column: spec.encoding.column } : {}\n        ),\n        spec: {\n          mark: spec.mark,\n          encoding: encoding\n        }\n      },\n      spec.config ? { config: spec.config } : {}\n    );\n  }\n\n  return spec;\n}\n\n// TODO: add vl.spec.validate & move stuff from vl.validate to here\n\nexport function alwaysNoOcclusion(spec: ExtendedUnitSpec): boolean {\n  // FIXME raw OxQ with # of rows = # of O\n  return vlEncoding.isAggregate(spec.encoding);\n}\n\nexport function fieldDefs(spec: ExtendedUnitSpec): FieldDef[] {\n  // TODO: refactor this once we have composition\n  return vlEncoding.fieldDefs(spec.encoding);\n};\n\nexport function getCleanSpec(spec: ExtendedUnitSpec): ExtendedUnitSpec {\n  // TODO: move toSpec to here!\n  return spec;\n}\n\nexport function isStack(spec: ExtendedUnitSpec): boolean {\n  return (vlEncoding.has(spec.encoding, COLOR) || vlEncoding.has(spec.encoding, SHAPE)) &&\n    (spec.mark === BAR || spec.mark === AREA) &&\n    (!spec.config || !spec.config.mark.stacked !== false) &&\n    vlEncoding.isAggregate(spec.encoding);\n}\n\n// TODO revise\nexport function transpose(spec: ExtendedUnitSpec): ExtendedUnitSpec {\n  const oldenc = spec.encoding;\n  let encoding = duplicate(spec.encoding);\n  encoding.x = oldenc.y;\n  encoding.y = oldenc.x;\n  encoding.row = oldenc.column;\n  encoding.column = oldenc.row;\n  spec.encoding = encoding;\n  return spec;\n}\n",
    "\nexport enum TimeUnit {\n    YEAR = 'year' as any,\n    MONTH = 'month' as any,\n    DAY = 'day' as any,\n    DATE = 'date' as any,\n    HOURS = 'hours' as any,\n    MINUTES = 'minutes' as any,\n    SECONDS = 'seconds' as any,\n    MILLISECONDS = 'milliseconds' as any,\n    YEARMONTH = 'yearmonth' as any,\n    YEARMONTHDAY = 'yearmonthday' as any,\n    YEARMONTHDATE = 'yearmonthdate' as any,\n    YEARDAY = 'yearday' as any,\n    YEARDATE = 'yeardate' as any,\n    YEARMONTHDAYHOURS = 'yearmonthdayhours' as any,\n    YEARMONTHDAYHOURSMINUTES = 'yearmonthdayhoursminutes' as any,\n    YEARMONTHDAYHOURSMINUTESSECONDS = 'yearmonthdayhoursminutesseconds' as any,\n    HOURSMINUTES = 'hoursminutes' as any,\n    HOURSMINUTESSECONDS = 'hoursminutesseconds' as any,\n    MINUTESSECONDS = 'minutesseconds' as any,\n    SECONDSMILLISECONDS = 'secondsmilliseconds' as any,\n}\n\nexport const TIMEUNITS = [\n    TimeUnit.YEAR,\n    TimeUnit.MONTH,\n    TimeUnit.DAY,\n    TimeUnit.DATE,\n    TimeUnit.HOURS,\n    TimeUnit.MINUTES,\n    TimeUnit.SECONDS,\n    TimeUnit.MILLISECONDS,\n    TimeUnit.YEARMONTH,\n    TimeUnit.YEARMONTHDAY,\n    TimeUnit.YEARMONTHDATE,\n    TimeUnit.YEARDAY,\n    TimeUnit.YEARDATE,\n    TimeUnit.YEARMONTHDAYHOURS,\n    TimeUnit.YEARMONTHDAYHOURSMINUTES,\n    TimeUnit.YEARMONTHDAYHOURSMINUTESSECONDS,\n    TimeUnit.HOURSMINUTES,\n    TimeUnit.HOURSMINUTESSECONDS,\n    TimeUnit.MINUTESSECONDS,\n    TimeUnit.SECONDSMILLISECONDS,\n];\n",
    "/** Constants and utilities for data type */\n\nexport enum Type {\n  QUANTITATIVE = 'quantitative' as any,\n  ORDINAL = 'ordinal' as any,\n  TEMPORAL = 'temporal' as any,\n  NOMINAL = 'nominal' as any\n}\n\nexport const QUANTITATIVE = Type.QUANTITATIVE;\nexport const ORDINAL = Type.ORDINAL;\nexport const TEMPORAL = Type.TEMPORAL;\nexport const NOMINAL = Type.NOMINAL;\n\n/**\n * Mapping from full type names to short type names.\n * @type {Object}\n */\nexport const SHORT_TYPE = {\n  quantitative: 'Q',\n  temporal: 'T',\n  nominal: 'N',\n  ordinal: 'O'\n};\n/**\n * Mapping from short type names to full type names.\n * @type {Object}\n */\nexport const TYPE_FROM_SHORT_TYPE = {\n  Q: QUANTITATIVE,\n  T: TEMPORAL,\n  O: ORDINAL,\n  N: NOMINAL\n};\n\n/**\n * Get full, lowercase type name for a given type.\n * @param  type\n * @return Full type name.\n */\nexport function getFullName(type: Type): Type {\n  const typeString = <any>type;  // force type as string so we can translate short types\n  return TYPE_FROM_SHORT_TYPE[typeString.toUpperCase()] || // short type is uppercase by default\n         typeString.toLowerCase();\n}\n",
    "/// <reference path=\"../typings/datalib.d.ts\"/>\n/// <reference path=\"../typings/json-stable-stringify.d.ts\"/>\n\nimport * as stringify from 'json-stable-stringify';\nexport {keys, extend, duplicate, isArray, vals, truncate, toMap, isObject, isString, isNumber, isBoolean, array, str} from 'datalib/src/util';\nexport {range} from 'datalib/src/generate';\nexport {has} from './encoding'\nexport {FieldDef} from './fielddef';\n\nimport {isString, isNumber, isBoolean} from 'datalib/src/util';\n\nexport function hash(a: any) {\n  if (isString(a) || isNumber(a) || isBoolean(a)) {\n    return String(a);\n  }\n  return stringify(a);\n}\n\nexport function contains<T>(array: Array<T>, item: T) {\n  return array.indexOf(item) > -1;\n}\n\n/** Returns the array without the elements in item */\nexport function without<T>(array: Array<T>, excludedItems: Array<T>) {\n  return array.filter(function(item) {\n    return !contains(excludedItems, item);\n  });\n}\n\nexport function union<T>(array: Array<T>, other: Array<T>) {\n  return unique(array.concat(other));\n}\n\nexport function forEach(obj, f: (a, d, k, o) => any, thisArg?) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        f.call(thisArg, obj[k], k, obj);\n      }\n    }\n  }\n}\n\nexport function reduce(obj, f: (a, i, d, k, o) => any, init, thisArg?) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        init = f.call(thisArg, init, obj[k], k, obj);\n      }\n    }\n    return init;\n  }\n}\n\nexport function map(obj, f: (a, d, k, o) => any, thisArg?) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    let output = [];\n    for (let k in obj) {\n      if (obj.hasOwnProperty(k)) {\n        output.push(f.call(thisArg, obj[k], k, obj));\n      }\n    }\n    return output;\n  }\n}\n\nexport function any<T>(arr: Array<T>, f: (d: T, k?, i?) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (f(arr[k], k, i++)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function all<T>(arr: Array<T>, f: (d: T, k?, i?) => boolean) {\n  let i = 0;\n  for (let k = 0; k<arr.length; k++) {\n    if (!f(arr[k], k, i++)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function flatten(arrays: any[]) {\n  return [].concat.apply([], arrays);\n}\n\nexport function mergeDeep(dest, ...src: any[]) {\n  for (let i = 0; i < src.length; i++) {\n    dest = deepMerge_(dest, src[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction deepMerge_(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (let p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      mergeDeep(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n\nexport function unique<T>(values: T[], f?: (item: T) => string): T[] {\n  let results = [];\n  var u = {}, v, i, n;\n  for (i = 0, n = values.length; i < n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      continue;\n    }\n    u[v] = 1;\n    results.push(values[i]);\n  }\n  return results;\n};\n\nexport function warning(message: any) {\n  console.warn('[VL Warning]', message);\n}\n\nexport function error(message: any) {\n  console.error('[VL Error]', message);\n}\n\nexport interface Dict<T> {\n  [key: string]: T;\n}\n\nexport type StringSet = Dict<boolean>;\n\n/**\n * Returns true if the two dicts disagree. Applies only to defined values.\n */\nexport function differ<T>(dict: Dict<T>, other: Dict<T>) {\n  for (let key in dict) {\n    if (dict.hasOwnProperty(key)) {\n      if (other[key] && dict[key] && other[key] !== dict[key]) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n",
    "import {ExtendedUnitSpec} from './spec';\n\n// TODO: move to vl.spec.validator?\n\nimport {toMap} from './util';\nimport {BAR} from './mark';\n\ninterface RequiredChannelMap {\n  [mark: string]: Array<string>;\n}\n\n/**\n * Required Encoding Channels for each mark type\n * @type {Object}\n */\nexport const DEFAULT_REQUIRED_CHANNEL_MAP: RequiredChannelMap = {\n  text: ['text'],\n  line: ['x', 'y'],\n  area: ['x', 'y']\n};\n\ninterface SupportedChannelMap {\n  [mark: string]: {\n    [channel: string]: number\n  };\n}\n\n/**\n * Supported Encoding Channel for each mark type\n */\nexport const DEFAULT_SUPPORTED_CHANNEL_TYPE: SupportedChannelMap = {\n  bar: toMap(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\n  line: toMap(['row', 'column', 'x', 'y', 'color', 'detail']), // TODO: add size when Vega supports\n  area: toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\n  tick: toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\n  circle: toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n  square: toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n  point: toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\n  text: toMap(['row', 'column', 'size', 'color', 'text']) // TODO(#724) revise\n};\n\n// TODO: consider if we should add validate method and\n// requires ZSchema in the main vega-lite repo\n\n/**\n * Further check if encoding mapping of a spec is invalid and\n * return error if it is invalid.\n *\n * This checks if\n * (1) all the required encoding channels for the mark type are specified\n * (2) all the specified encoding channels are supported by the mark type\n * @param  {[type]} spec [description]\n * @param  {RequiredChannelMap  = DefaultRequiredChannelMap}  requiredChannelMap\n * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap\n * @return {String} Return one reason why the encoding is invalid,\n *                  or null if the encoding is valid.\n */\nexport function getEncodingMappingError(spec: ExtendedUnitSpec,\n  requiredChannelMap: RequiredChannelMap = DEFAULT_REQUIRED_CHANNEL_MAP,\n  supportedChannelMap: SupportedChannelMap = DEFAULT_SUPPORTED_CHANNEL_TYPE\n  ) {\n  let mark = spec.mark;\n  let encoding = spec.encoding;\n  let requiredChannels = requiredChannelMap[mark];\n  let supportedChannels = supportedChannelMap[mark];\n\n  for (let i in requiredChannels) { // all required channels are in encoding`\n    if (!(requiredChannels[i] in encoding)) {\n      return 'Missing encoding channel \\\"' + requiredChannels[i] +\n        '\\\" for mark \\\"' + mark + '\\\"';\n    }\n  }\n\n  for (let channel in encoding) { // all channels in encoding are supported\n    if (!supportedChannels[channel]) {\n      return 'Encoding channel \\\"' + channel +\n        '\\\" is not supported by mark type \\\"' + mark + '\\\"';\n    }\n  }\n\n  if (mark === BAR && !encoding.x && !encoding.y) {\n    return 'Missing both x and y for bar';\n  }\n\n  return null;\n}\n",
    "import {isArray} from './util';\nimport {ScaleType, NiceTime} from './scale';\n\nexport interface VgData {\n  name: string;\n  source?: string;\n  values?: any;\n  format?: any;\n  url?: any;\n  transform?: any;\n}\n\n// Reference to field, only used in mark proeprties\nexport type VgFieldRef = string | {\n  datum: VgParentRef | VgGroupRef\n}\n\n// Reference to parent\nexport type VgParentRef = {\n  parent: string\n};\n\n// Reference to group\ntype VgGroupRef = {\n  group: string\n}\n\nexport type VgField = string | VgParentRef | VgParentRef[];\n\nexport type VgDataRef = {\n  data: string,\n  field: VgField,\n  sort: boolean | {\n    field: VgField,\n    op: string\n  }\n};\n\nexport type UnionedDomain = {\n  fields: VgDataRef[]\n};\n\nexport type VgScale = {\n  name: string,\n  type: ScaleType,\n  domain?: any[] | UnionedDomain | VgDataRef,\n  domainMin?: any,\n  domainMax?: any\n  range?: any[] | VgDataRef | string,\n  rangeMin?: any,\n  rangeMax?: any,\n\n  bandSize?: number,\n  clamp?: boolean,\n  exponent?: number,\n  nice?: boolean | NiceTime,\n  padding?: number,\n  points?: boolean,\n  reverse?: boolean,\n  round?: boolean,\n  zero?: boolean\n}\n\nexport function isUnionedDomain(domain: any[] | UnionedDomain | VgDataRef): domain is UnionedDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain;\n  }\n  return false;\n}\n\nexport function isDataRefDomain(domain: any[] | UnionedDomain | VgDataRef): domain is VgDataRef {\n  if (!isArray(domain)) {\n    return 'data' in domain;\n  }\n  return false;\n}\n\n// TODO: declare\nexport type VgMarkGroup = any;\nexport type VgAxis = any;\nexport type VgLegend = any;\nexport type VgTransform = any;\n",
    "import * as vlBin from './bin';\nimport * as vlChannel from './channel';\nimport * as vlConfig from './config';\nimport * as vlData from './data';\nimport * as vlEncoding from './encoding';\nimport * as vlFieldDef from './fielddef';\nimport * as vlCompile from './compile/compile';\nimport * as vlShorthand from './shorthand';\nimport * as vlSpec from './spec';\nimport * as vlTimeUnit from './timeunit';\nimport * as vlType from './type';\nimport * as vlValidate from './validate';\nimport * as vlUtil from './util';\n\nexport const bin = vlBin;\nexport const channel = vlChannel;\nexport const compile = vlCompile.compile;\nexport const config = vlConfig;\nexport const data = vlData;\nexport const encoding = vlEncoding;\nexport const fieldDef = vlFieldDef;\nexport const shorthand = vlShorthand;\nexport const spec = vlSpec;\nexport const timeUnit = vlTimeUnit;\nexport const type = vlType;\nexport const util = vlUtil;\nexport const validate = vlValidate;\n\nexport const version = '__VERSION__';\n",
    "module.exports = (function() {\n  \"use strict\";\n\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n        parser  = this,\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = \",\",\n        peg$c1 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n        peg$c2 = function(o, m) { return [o].concat(m); },\n        peg$c3 = function(o) { return [o]; },\n        peg$c4 = \"[\",\n        peg$c5 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n        peg$c6 = \"]\",\n        peg$c7 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n        peg$c8 = \">\",\n        peg$c9 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n        peg$c10 = function(f1, f2, o) {\n            return {\n              start: f1, middle: o, end: f2,\n              str: '['+f1.str+', '+f2.str+'] > '+o.str};\n            },\n        peg$c11 = function(s, f) {\n            s.filters = f;\n            s.str += f.map(function(x) { return '['+x+']'; }).join('');\n            return s;\n          },\n        peg$c12 = function(s) { return s; },\n        peg$c13 = \"(\",\n        peg$c14 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n        peg$c15 = \")\",\n        peg$c16 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n        peg$c17 = function(m) {\n            return {\n              stream: m,\n              str: '('+m.map(function(m) { return m.str; }).join(', ')+')'\n            };\n          },\n        peg$c18 = \"@\",\n        peg$c19 = { type: \"literal\", value: \"@\", description: \"\\\"@\\\"\" },\n        peg$c20 = \":\",\n        peg$c21 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c22 = function(n, e) { return {event: e, name: n, str: '@'+n+':'+e}; },\n        peg$c23 = function(m, e) { return {event: e, mark: m, str: m+':'+e}; },\n        peg$c24 = function(t, e) { return {event: e, target: t, str: t+':'+e}; },\n        peg$c25 = function(e) { return {event: e, str: e}; },\n        peg$c26 = function(s) { return {signal: s, str: s}; },\n        peg$c27 = \"rect\",\n        peg$c28 = { type: \"literal\", value: \"rect\", description: \"\\\"rect\\\"\" },\n        peg$c29 = \"symbol\",\n        peg$c30 = { type: \"literal\", value: \"symbol\", description: \"\\\"symbol\\\"\" },\n        peg$c31 = \"path\",\n        peg$c32 = { type: \"literal\", value: \"path\", description: \"\\\"path\\\"\" },\n        peg$c33 = \"arc\",\n        peg$c34 = { type: \"literal\", value: \"arc\", description: \"\\\"arc\\\"\" },\n        peg$c35 = \"area\",\n        peg$c36 = { type: \"literal\", value: \"area\", description: \"\\\"area\\\"\" },\n        peg$c37 = \"line\",\n        peg$c38 = { type: \"literal\", value: \"line\", description: \"\\\"line\\\"\" },\n        peg$c39 = \"rule\",\n        peg$c40 = { type: \"literal\", value: \"rule\", description: \"\\\"rule\\\"\" },\n        peg$c41 = \"image\",\n        peg$c42 = { type: \"literal\", value: \"image\", description: \"\\\"image\\\"\" },\n        peg$c43 = \"text\",\n        peg$c44 = { type: \"literal\", value: \"text\", description: \"\\\"text\\\"\" },\n        peg$c45 = \"group\",\n        peg$c46 = { type: \"literal\", value: \"group\", description: \"\\\"group\\\"\" },\n        peg$c47 = \"mousedown\",\n        peg$c48 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n        peg$c49 = \"mouseup\",\n        peg$c50 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n        peg$c51 = \"click\",\n        peg$c52 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n        peg$c53 = \"dblclick\",\n        peg$c54 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n        peg$c55 = \"wheel\",\n        peg$c56 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n        peg$c57 = \"keydown\",\n        peg$c58 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n        peg$c59 = \"keypress\",\n        peg$c60 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n        peg$c61 = \"keyup\",\n        peg$c62 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n        peg$c63 = \"mousewheel\",\n        peg$c64 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n        peg$c65 = \"mousemove\",\n        peg$c66 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n        peg$c67 = \"mouseout\",\n        peg$c68 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n        peg$c69 = \"mouseover\",\n        peg$c70 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n        peg$c71 = \"mouseenter\",\n        peg$c72 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n        peg$c73 = \"touchstart\",\n        peg$c74 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n        peg$c75 = \"touchmove\",\n        peg$c76 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n        peg$c77 = \"touchend\",\n        peg$c78 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n        peg$c79 = \"dragenter\",\n        peg$c80 = { type: \"literal\", value: \"dragenter\", description: \"\\\"dragenter\\\"\" },\n        peg$c81 = \"dragover\",\n        peg$c82 = { type: \"literal\", value: \"dragover\", description: \"\\\"dragover\\\"\" },\n        peg$c83 = \"dragleave\",\n        peg$c84 = { type: \"literal\", value: \"dragleave\", description: \"\\\"dragleave\\\"\" },\n        peg$c85 = function(e) { return e; },\n        peg$c86 = /^[a-zA-Z0-9_\\-]/,\n        peg$c87 = { type: \"class\", value: \"[a-zA-Z0-9_-]\", description: \"[a-zA-Z0-9_-]\" },\n        peg$c88 = function(n) { return n.join(''); },\n        peg$c89 = /^[a-zA-Z0-9\\-_  #.>+~[\\]=|\\^$*]/,\n        peg$c90 = { type: \"class\", value: \"[a-zA-Z0-9-_  #\\\\.\\\\>\\\\+~\\\\[\\\\]=|\\\\^\\\\$\\\\*]\", description: \"[a-zA-Z0-9-_  #\\\\.\\\\>\\\\+~\\\\[\\\\]=|\\\\^\\\\$\\\\*]\" },\n        peg$c91 = function(c) { return c.join(''); },\n        peg$c92 = /^['\"a-zA-Z0-9_().><=! \\t-&|~]/,\n        peg$c93 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_\\\\(\\\\)\\\\.\\\\>\\\\<\\\\=\\\\! \\\\t-&|~]\", description: \"['\\\"a-zA-Z0-9_\\\\(\\\\)\\\\.\\\\>\\\\<\\\\=\\\\! \\\\t-&|~]\" },\n        peg$c94 = function(v) { return v.join(''); },\n        peg$c95 = /^[ \\t\\r\\n]/,\n        peg$c96 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(\n        message,\n        null,\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n          p, ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0100-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1000-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0;\n\n      s0 = peg$parsemerged();\n\n      return s0;\n    }\n\n    function peg$parsemerged() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsesep();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c0;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c1); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsesep();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsemerged();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c2(s1, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseordered();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c3(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseordered() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c4;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsesep();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsefiltered();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsesep();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c0;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c1); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsesep();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parsefiltered();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parsesep();\n                    if (s8 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 93) {\n                        s9 = peg$c6;\n                        peg$currPos++;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c7); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        s10 = peg$parsesep();\n                        if (s10 !== peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 62) {\n                            s11 = peg$c8;\n                            peg$currPos++;\n                          } else {\n                            s11 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                          }\n                          if (s11 !== peg$FAILED) {\n                            s12 = peg$parsesep();\n                            if (s12 !== peg$FAILED) {\n                              s13 = peg$parseordered();\n                              if (s13 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$c10(s3, s7, s13);\n                                s0 = s1;\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsefiltered();\n      }\n\n      return s0;\n    }\n\n    function peg$parsefiltered() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsefilter();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsefilter();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c11(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsestream();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c12(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parsestream() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c13;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c14); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsemerged();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s3 = peg$c15;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c17(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 64) {\n          s1 = peg$c18;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsename();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s3 = peg$c20;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c21); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseeventType();\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c22(s2, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsemarkType();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s2 = peg$c20;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c21); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseeventType();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c23(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsecss();\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 58) {\n                s2 = peg$c20;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c21); }\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseeventType();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c24(s1, s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseeventType();\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c25(s1);\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsename();\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c26(s1);\n                }\n                s0 = s1;\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsemarkType() {\n      var s0;\n\n      if (input.substr(peg$currPos, 4) === peg$c27) {\n        s0 = peg$c27;\n        peg$currPos += 4;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c29) {\n          s0 = peg$c29;\n          peg$currPos += 6;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c30); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 4) === peg$c31) {\n            s0 = peg$c31;\n            peg$currPos += 4;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c33) {\n              s0 = peg$c33;\n              peg$currPos += 3;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c34); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 4) === peg$c35) {\n                s0 = peg$c35;\n                peg$currPos += 4;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c36); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 4) === peg$c37) {\n                  s0 = peg$c37;\n                  peg$currPos += 4;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 4) === peg$c39) {\n                    s0 = peg$c39;\n                    peg$currPos += 4;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c40); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 5) === peg$c41) {\n                      s0 = peg$c41;\n                      peg$currPos += 5;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c42); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 4) === peg$c43) {\n                        s0 = peg$c43;\n                        peg$currPos += 4;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 5) === peg$c45) {\n                          s0 = peg$c45;\n                          peg$currPos += 5;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseeventType() {\n      var s0;\n\n      if (input.substr(peg$currPos, 9) === peg$c47) {\n        s0 = peg$c47;\n        peg$currPos += 9;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c49) {\n          s0 = peg$c49;\n          peg$currPos += 7;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c50); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 5) === peg$c51) {\n            s0 = peg$c51;\n            peg$currPos += 5;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c52); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 8) === peg$c53) {\n              s0 = peg$c53;\n              peg$currPos += 8;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c54); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 5) === peg$c55) {\n                s0 = peg$c55;\n                peg$currPos += 5;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c56); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7) === peg$c57) {\n                  s0 = peg$c57;\n                  peg$currPos += 7;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 8) === peg$c59) {\n                    s0 = peg$c59;\n                    peg$currPos += 8;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 5) === peg$c61) {\n                      s0 = peg$c61;\n                      peg$currPos += 5;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 10) === peg$c63) {\n                        s0 = peg$c63;\n                        peg$currPos += 10;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 9) === peg$c65) {\n                          s0 = peg$c65;\n                          peg$currPos += 9;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c66); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 8) === peg$c67) {\n                            s0 = peg$c67;\n                            peg$currPos += 8;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c68); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 9) === peg$c69) {\n                              s0 = peg$c69;\n                              peg$currPos += 9;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c70); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c71) {\n                                s0 = peg$c71;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c72); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 10) === peg$c73) {\n                                  s0 = peg$c73;\n                                  peg$currPos += 10;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c74); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 9) === peg$c75) {\n                                    s0 = peg$c75;\n                                    peg$currPos += 9;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c76); }\n                                  }\n                                  if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 8) === peg$c77) {\n                                      s0 = peg$c77;\n                                      peg$currPos += 8;\n                                    } else {\n                                      s0 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c78); }\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                      if (input.substr(peg$currPos, 9) === peg$c79) {\n                                        s0 = peg$c79;\n                                        peg$currPos += 9;\n                                      } else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$c80); }\n                                      }\n                                      if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 8) === peg$c81) {\n                                          s0 = peg$c81;\n                                          peg$currPos += 8;\n                                        } else {\n                                          s0 = peg$FAILED;\n                                          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                          if (input.substr(peg$currPos, 9) === peg$c83) {\n                                            s0 = peg$c83;\n                                            peg$currPos += 9;\n                                          } else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) { peg$fail(peg$c84); }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsefilter() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c4;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c6;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c7); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c85(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsename() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c86.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c87); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c86.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c87); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c88(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecss() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c89.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c90); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c89.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c90); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c91(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseexpr() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c92.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c93); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c92.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c93); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c94(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesep() {\n      var s0, s1;\n\n      s0 = [];\n      if (peg$c95.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c96); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c95.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c96); }\n        }\n      }\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(\n        null,\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})();\n"
  ]
}